{"01":{"slug":"01","filePath":"01.md","title":"01","links":[],"tags":[],"content":"\nCet exercice a pour but de nous faire enregistrer un nombre √† virgule dans un int pour en faire un nombre √† virgule fixe. Il va nous permettre d‚Äôaborder les d√©calages de bit ainsi que la notion de surcharge de fonction et d‚Äôop√©rateur.\n"},"C++":{"slug":"C++","filePath":"C++.md","title":"C++","links":["programmation-orient√©e-objet","classe","h√©ritage","polymorphisme","surcharge","paradigme-de-programmation","programmation-imp√©rative","programmation-proc√©durale","programmation-fonctionnelle","C++98","STL","template","allocation-dynamique-de-la-m√©moire","C++11","Initiation-au-C++-(√†-destination-des-√©tudiants-de-42)"],"tags":[],"content":"\nNom anglais: C++\n\n\nLe C++ est un langage de programmation con√ßu pour √™tre rapide, puissant, et flexible. Il est bas√© sur le C, auquel il ajoute des fonctionnalit√©s majeures comme la programmation orient√©e objet (POO).\nComparaison C/C++ : Le C++ conserve toute la puissance du C, mais ajoute des concepts modernes comme les classes, l‚Äôh√©ritage, le polymorphisme, et la surcharge.\n\n\nOrigine du C++\n\nCr√©√© par Bjarne Stroustrup au d√©but des ann√©es 1980.\nSon but √©tait d‚Äôam√©liorer le C en y ajoutant la possibilit√© d‚Äôorganiser des programmes complexes de fa√ßon plus s√ªre et plus modulaire.\nInitialement appel√© ‚ÄúC with Classes‚Äù.\n\n\nCaract√©ristiques principales\n\nMulti-paradigme : permet plusieurs paradigme de programmation comme la programmation imp√©rative, programmation proc√©durale, programmation orient√©e objet, et m√™me programmation fonctionnelle.\nHaute performance : permet de programmer au plus proche de la machine tout en restant flexible.\nContr√¥le fin de la m√©moire (pas de ramasse-miettes automatique par d√©faut).\nExtensible : on peut cr√©er ses propres types complexes.\nCompatible avec le C pour faciliter la migration de projets.\n\n\nUtilisations du C++\nLe C++ est utilis√© dans de nombreux domaines :\n\nD√©veloppement de jeux vid√©o,\nSyst√®mes embarqu√©s,\nApplications lourdes (bases de donn√©es, navigateurs, moteurs 3D),\nLogiciels n√©cessitant vitesse et optimisation.\n\n\n√âvolution du langage C++\nLe langage C++ a connu plusieurs standards majeurs depuis sa premi√®re normalisation. Chaque version apporte son lot d‚Äôam√©liorations syntaxiques, de fonctionnalit√©s modernes, et d‚Äôoutils facilitant l‚Äô√©criture de code plus s√ªr, lisible et performant :\n\nC++98 : Premi√®re norme officielle, formalise la STL, la programmation orient√©e objet, les templates et l‚Äôallocation dynamique de la m√©moire. C‚Äôest le standard pour les premiers projets √† l‚Äô√©cole 42.\nC++03 : R√©vision mineure de C++98(corrections et clarifications, peu de nouveaut√©s visibles).\nC++11 : R√©volution moderne ! Ajoute auto, les lambdas, les smart pointers, les move semantics, la boucle range-based for, etc.\nC++14 : Affinage de C++11, am√©liore les lambdas, auto, make_unique, etc.\nC++17 : Introduit std::optional, if constexpr, structured bindings, am√©liore la STL.\nC++20 : Nouveau cap majeur avec les coroutines, concepts, ranges, modules, consteval, etc.\nC++23 : Affine encore C++20, avec de nouveaux utilitaires STL, des am√©liorations de performances et de lisibilit√©.\n\n\nExemple minimal en C++\n#include &lt;iostream&gt;\n \nint main()\n{\n    std::cout &lt;&lt; &quot;Bonjour, C++ !&quot; &lt;&lt; std::endl;\n    return 0;\n}\n\nPar o√π commencer?\n‚Üí Initiation au C++ (√† destination des √©tudiants de 42)"},"C++11":{"slug":"C++11","filePath":"C++11.md","title":"C++11","links":["C++","C++98"],"tags":[],"content":"\nNom anglais: C++11\n\n\nC++11 est une version du langage C++ publi√©e en 2011, qui introduit de nombreuses am√©liorations modernes par rapport aux versions pr√©c√©dentes (notamment C++98/C++03).\nIl rend le langage plus lisible, plus puissant et plus expressif.\n\n\nPrincipales nouveaut√©s\n\nBoucle range-based for :\nfor (int x : vecteur) { ... }\nMot-cl√© auto : d√©duction automatique du type\nInitialisation avec {} (uniform initialization)\nLambdas : fonctions anonymes inline\nSmart pointers : std::unique_ptr, std::shared_ptr\nPerformances : move semantics, rvalue references\n\n\nC++11 √† l‚Äô√©cole 42\nDans le cadre des exercices de l‚Äô√©cole 42, l‚Äôutilisation du C++11 est interdite dans les premiers modules du C++. Seul le C++98 est autoris√©.\nVoir aussi\n‚Üí C++, C++98"},"C++98":{"slug":"C++98","filePath":"C++98.md","title":"C++98","links":["C++","programmation-orient√©e-objet","template","STL","classe","h√©ritage","polymorphisme","m√©thode-virtuelle","surcharge-d'op√©rateur","constructeur","destructeur","encapsulation","dur√©e-de-vie-des-objets","allocation-dynamique-de-la-m√©moire","conteneur","it√©rateur","biblioth√®que-algorithm","foncteur","objet","C++11"],"tags":[],"content":"\nNom anglais: C++98\n\n\nC++98 est la premi√®re norme officielle du langage C++, publi√©e en 1998.\nElle √©tablit les fondations du C++ moderne : programmation orient√©e objet, templates, et int√©gration de la STL (Standard Template Library).\nComparaison C/C++ : Contrairement au langage C, C++98 introduit une programmation orient√©e objet compl√®te, ainsi que des outils puissants pour la programmation g√©n√©rique.\n\n\nFonctionnalit√©s principales\nProgrammation orient√©e objet\nC++98 prend en charge tous les concepts fondamentaux de la programmation orient√©e objet (POO):\n\nclasse, h√©ritage, polymorphisme, m√©thode virtuelle\nsurcharge d‚Äôop√©rateur, constructeur, destructeur\nGestion fine de l‚Äôencapsulation et de la dur√©e de vie des objets\n\nTemplates\n\nSupport complet des fonctions et classes g√©n√©riques\nUtilisation intensive dans la STL\nPermet la g√©n√©ration automatique de code adapt√© √† diff√©rents types\n\nGestion m√©moire manuelle\n\nallocation dynamique de la m√©moire avec new et delete\nPas de smart pointers (std::unique_ptr, std::shared_ptr)\nLe programmeur est responsable de lib√©rer la m√©moire\n\n\nSTL (Standard Template Library)\nC++98 officialise la STL, compos√©e de :\n\nconteneurs g√©n√©riques : std::vector, std::list, std::map, etc.\nit√©rateurs standards pour naviguer dans les conteneurs\nAlgorithmes dans la biblioth√®que algorithm: std::sort, std::find, std::copy, etc.\nfoncteurs (objets fonctionnels)\nInt√©gration fluide avec les templates\n\n\nLimitations (vs C++ modernes)\nC++98 ne propose aucune des fonctionnalit√©s modernes :\n\nPas de auto, nullptr, lambda, for-each, range-based loop\nTypage strict, pas d‚Äôinf√©rence\nSyntaxe longue et verbeuse\nGestion manuelle de la m√©moire\nPas de move semantics, constexpr, enum class, etc.\n\n\nC++98 √† l‚Äô√©cole 42\nDans les modules d‚Äôintroduction de l‚Äô√©cole 42 :\n\nL‚Äôusage du C++98 est obligatoire\nLa STL est interdite dans les premiers projets\nIl faut coder soi-m√™me toutes les structures de base (tableaux dynamiques, tri, structures de donn√©es, etc.)\nSeuls certains headers sont autoris√©s : &lt;iostream&gt;, &lt;string&gt;, etc.\n\n\nR√©sum√©\nC++98 est une version stable, rigoureuse, et exigeante du C++.\nElle forme les bases solides n√©cessaires √† la compr√©hension du langage, m√™me si elle manque des facilit√©s des versions modernes.\nApprendre C++98, c‚Äôest ma√Ætriser les fondations : m√©moire, objet, template, programmation orient√©e objet, sans l‚Äôaide des outils automatiques r√©cents.\n\nVoir aussi\n‚Üí C++, C++11\n‚Üí template, programmation orient√©e objet, allocation dynamique de la m√©moire\n‚Üí STL, biblioth√®que algorithm, it√©rateur"},"GNU":{"slug":"GNU","filePath":"GNU.md","title":"GNU","links":["syst√®me-d‚Äôexploitation","UNIX","compilateur"],"tags":[],"content":"Qu‚Äôest-ce que GNU?\n\nGNU est un projet lanc√© en 1983 par Richard Stallman pour cr√©er un syst√®me d‚Äôexploitation libre, c‚Äôest-√†-dire que tout le monde peut utiliser, modifier et partager les logiciels sans restrictions.\n\nLe nom GNU signifie ‚ÄúGNU‚Äôs Not Unix‚Äù (un acronyme r√©cursif), car le projet voulait recr√©er UNIX, mais en version enti√®rement libre.\nEn r√©sum√©\n\nGNU est une collection d‚Äôoutils et de programmes libres (compilateurs, √©diteurs de texte, commandes syst√®me, etc.).\nLe projet GNU est √† la base de beaucoup de logiciels libres modernes.\nQuand on utilises Linux, en r√©alit√© on utilise souvent GNU/Linux :\n\nLinux = noyau (kernel)\nGNU = outils autour (bash, gcc, g++, etc.)\n\n\n\nExemples de composants GNU c√©l√®bres :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nComposantR√¥legccCompilateur C (GNU Compiler Collection)g++Compilateur C++bashInterpr√©teur de commandesmakeOutil d‚Äôautomatisation de compilation\nFun fact\n\nLe projet GNU est aussi √† l‚Äôorigine de la philosophie du logiciel libre.\nLa Free Software Foundation (FSF) a √©t√© cr√©√©e pour le soutenir.\n"},"Module_00":{"slug":"Module_00","filePath":"Module_00.md","title":"Module_00","links":["classe","programmation-orient√©e-objet","Module_00/ex00","Module_00/ex01","Module_00/ex02"],"tags":[],"content":"\nCe module est constitu√© de trois exercices (de ex00 √† ex01) qui ont pour but d‚Äôintroduire l‚Äô√©tudiant aux concepts de classe et de programmation orient√©e objet.\n\nLes exercices\nex00\nex01\nex02"},"Module_00/ex00":{"slug":"Module_00/ex00","filePath":"Module_00/ex00.md","title":"ex00","links":["Module_00","biblioth√®que-standard-C++","objet","cout","nom-pleinement-qualifi√©","espace-de-noms","manipulateur-de-flux","endl","surcharge-d'op√©rateur","string","m√©thode","toupper","argument","param√®tre"],"tags":[],"content":"\nCe premier exercice du Module_00  a pour but de nous faire afficher du texte √† l‚Äô√©cran et d‚Äôutiliser une premi√®re fonction de la biblioth√®que standard C++\n\nAfficher du texte √† l‚Äô√©cran\nNous allons pour cela utiliser un objet de la biblioth√®que standard C++ :\n‚Üí cout(qui permet d‚Äôenvoyer des donn√©es vers la sortie standard).\nCet objet devra √™tre utilis√© en √©crivant son nom complet (on dit le nom pleinement qualifi√© ou fully qualified name en anglais) std::coutcar pour le moment nous n‚Äôavons pas le droit d‚Äôutiliser using namespace pour les espace de noms (namespace) et cela est de toute fa√ßon d√©conseill√© dans les projets s√©rieux. Nous devrons donc √©crire le nom pleinement qualifi√©:\n‚Üí std::cout\nAfficher un saut de ligne\nPour afficher un saut de ligne nous utiliserons un manipulateur de flux :\n‚Üí endl (en utilisant son nom pleinement qualifi√©: std::endl)\nExemple simple de texte affich√© √† l‚Äô√©cran\nint ecole = 42;\nstd::string message = &quot;Welcome at &quot;\n\t\nstd::cout &lt;&lt; &quot;Hello World ! &quot; &lt;&lt; message &lt;&lt; ecole &lt;&lt; std::endl;\n\nCe code affichera √† l‚Äô√©cran : Hello World ! Welcome at 42\nVous constaterez que le flux en question accepte des std::string et des int (gr√¢ce √† la surcharge d‚Äôop√©rateur, mais pas besoin de vous encombrer l‚Äôesprit avec cela √† ce stade).\n\nLa classe string\nLa classe string est une classe de la biblioth√®que standard C++ puissante pour manipuler des chaines de caract√®res. Elle comprend des m√©thodes typiques des manipulations de chaines de caract√®res (comme par exemple lenght()  pour obtenir la longueur de la chaine de caract√®re). Pour faire appel √† cet objet il faut √©crire:\n‚Üí std::string\nstd::string str = &quot;Ma chaine de caract√®re&quot;;\nNotre premi√®re fonction de la biblioth√®que standard\nPour afficher des majuscules √† l‚Äô√©cran lorsque le caract√®re initial est en minuscule, nous allons utiliser une fonction de la biblioth√®que standard C++:\n‚Üí toupper(en utilisant son nom pleinement qualifi√©: std::toupper)\nCette fonction prend un caract√®re (char) en argument et retourne sa version majuscule si c‚Äôest une lettre minuscule.\nInt√©grer tout √ßa dans des boucles\nL‚Äôappel √† cout et toupper doit √™tre int√©gr√© dans deux boucles imbriqu√©es afin de traiter chaque caract√®re de chaque argument pass√© en param√®tre √† notre programme (via int argc /  char ** argv)."},"Module_00/ex01":{"slug":"Module_00/ex01","filePath":"Module_00/ex01.md","title":"ex01","links":["Module_00","C++","programmation-orient√©e-objet","classe","forme-canonique-de-Coplien","paradigme-de-programmation","attribut","m√©thode","objet","priv√©","publique","UpperCamelCase","accesseur","mutateur","forme-canonique","lowerCamelCase","getline","Getline","biblioth√®que-standard-C++","op√©rateur","surcharg√©"],"tags":[],"content":"\nCe second exercice du Module_00 fait appel √† une notion fondamentale du C++et de la programmation orient√©e objet: les classes.\n\nVos premi√®res classes\nCet exercice va vous permettre d‚Äôaborder le concept de classe. Pour le moment, la forme canonique de Coplien n‚Äôest pas obligatoire pour le moment, donc inutile de vous encombrer avec des m√©thodes inutiles pour l‚Äôinstant.\nNotions fondamentales\nAvant d‚Äôattaquer l‚Äôexercice, familiarisez vous avec les concepts suivants (il n‚Äôest pas n√©cessaire de trop approfondir pour le moment) :\n\nLa programmation orient√©e objet : un paradigme de programmation qui repose sur la mod√©lisation du programme en objet.\nLes classes : des structures am√©lior√©es qui regroupent des donn√©es (attributs) et des fonctions (m√©thodes)\nLes attributs : les variables membres contenues dans une classe\nLes m√©thodes : les fonctions membres d√©finies dans une classe\nLes objets : les instances concr√®tes d‚Äôune classe\nPartie priv√©e : section d‚Äôune classe contenant les attributs et les m√©thodes inaccessibles de l‚Äôext√©rieur de la classe\nPartie publique : section d‚Äôune classe contenant les attributs et m√©thodes accessibles depuis l‚Äôext√©rieur** de la classe\n\nUne classe comme attribut d‚Äôune autre classe\nDe la m√™me fa√ßon qu‚Äôun structure peut elle-m√™me avoir une variable de type structure, une classe peut parfaitement avoir un attribut qui est lui-m√™me une classe.\nCela permet de composer des objets complexes √† partir d‚Äôobjets plus simples.\n\n‚Üí Vous devrez ainsi d‚Äôabord cr√©er une classe Contact avec plusieurs attributs (first name, last name, etc), puis une classe PhoneBookqui contiendra un attribut qui sera en fait un tableau de Contact.\n\n√ätre attentifs √† la forme\nBien qu‚Äôil n‚Äôy ait plus de norme au sens strict (nombres de lignes par fonction, etc),  lisez bien le pr√©ambule du sujet, car plusieurs conventions sont impos√©es par 42 au niveau de la forme, comme par exemple :\n\nle nommage des classes en UpperCamelCase\nla structure de fichiers de classes avec pour chaque classe :\n\nun .hpp contenant le prototype de la classe\nun .cpp contenant l‚Äôimpl√©mentation de la classe\nles attributs sont g√©n√©ralement en priv√©, ce qui implique g√©n√©ralement d‚Äôavoir des m√©thodes en publique si on a besoin de manipuler ces valeurs depuis l‚Äôext√©rieur, comme par exemple:\n\ndes accesseurs (getters) : m√©thodes qui permettent de renvoyer un attribut afin d‚Äôy acc√©der depuis l‚Äôext√©rieur\ndes mutateurs (setters) : m√©thodes qui permettent de fixer la valeur d‚Äôun attribut depuis l‚Äôext√©rieur\n\n\nl‚Äôutilisation de la forme canonique (√† partir du Module02 seulement)\n\n\n\nVous voudrez aussi peut-√™tre respecter d‚Äôautres conventions facultatives comme :\n\nle nommage des attributs en lowerCamelCase commen√ßant par un underscore (exemple : _maVariable)\n\nR√©cup√©rer la saisie de l‚Äôutilisateur\nPlusieurs m√©thodes sont possibles pour r√©cup√©rer le texte saisi par l‚Äôutilisateur, mais dans cette exercice je vous conseille d‚Äôopter pour la fonction getline (permet de r√©cup√©rer la saisie sans s‚Äôarr√™ter au premier espace).\nGetline faisant parti de la biblioth√®que standard C++, vous devrez y faire appel avec son nom pleinement qualifi√©:\n‚Üí std::getline\nComparaison de std::string\nEn C++, il est tout √† fait possible de comparer directement une std::string avec une cha√Æne de caract√®res (const char*) ou une autre std::string gr√¢ce √† la surcharge de l‚Äôop√©rateur ==.\nExemple\nstd::string myString = &quot;SEARCH&quot;;\n \nif (myString == &quot;SEARCH&quot;) {\n    // cette condition est vraie\n}\n\nIci, &quot;SEARCH&quot; est un const char*, mais la comparaison fonctionne car l‚Äôop√©rateur == est surcharg√© dans la classe std::string pour accepter aussi bien des std::string que des cha√Ænes C (const char*).\n\nAutres comparaisons possibles\nOn peut √©galement utiliser :\n\n!= (diff√©rent)\n&lt;, &gt;, &lt;=, &gt;= (ordre lexicographique)\n\nif (myString != &quot;ADD&quot;) { ... }\nif (myString &lt; &quot;ZEBRA&quot;) { ... }"},"Module_00/ex02":{"slug":"Module_00/ex02","filePath":"Module_00/ex02.md","title":"ex02","links":["Module_00","attribut-statique","objet","constructeur","destructeur","new","accesseur","m√©thode","time","gmtime","strftime"],"tags":[],"content":"\nCe dernier exercice du Module_00 va vous amener √† faire une sorte de reverse-engineering √† partir d‚Äôun code incomplet existant.\n\nCode incomplet\nVous allez devoir coder l‚Äôimpl√©mentation d‚Äôune classe (son .cpp) √† partir de son .hpp, de la fonction main du programme, et d‚Äôun fichier de log (qui est en fait la sortie attendue du programme).\nAttribut de classe\nVous allez d√©couvrir la notion d‚Äôattribut statique : un attribut dont la valeur est commune √† toutes les instances de la classe (les objets).\n‚Üí L‚Äôattribut de classe est d√©clar√© pr√©c√©d√© du mot cl√© static.\nM√©thodes √† impl√©menter\nVous allez devoir impl√©menter plusieurs m√©thodes :\n\nun constructeur : la m√©thode qui cr√©e une instance de la classe (un objet) et notamment qui va initialiser ses attributs si n√©cessaire\nun destructeur : la m√©thode qui est appel√© automatiquement pour d√©truire l‚Äôobjet quand on quitte le programme. La destruction de l‚Äôobjet est automatique (si il n‚Äôa pas √©t√© allou√© dynamiquement avec new) mais vous pouvez ex√©cuter du code au moment de la destruction de l‚Äôobjet.\ndes accesseurs : des m√©thodes pour acc√©der aux attributs depuis l‚Äôext√©rieur de la classe\nune m√©thode pour afficher le timestamp\nautres m√©thodes\n\nTimestamp\nPour impl√©menter le timestamp, j‚Äôai pour ma part utilis√© les fonctions suivantes :\n\ntime (`std::time)\ngmtime (std::gmtime)\nstrftime (std::strftime)\n"},"Module_01":{"slug":"Module_01","filePath":"Module_01.md","title":"Module_01","links":["classe","programmation-orient√©e-objet","ex00","ex01","ex02","ex03","ex04"],"tags":[],"content":"\nCe module est constitu√© de six exercices (de ex00 √† ex01) qui vont vous permettre d‚Äôapprofondir les notions de classe et de programmation orient√©e objet.\n\nLes exercices\nex00\nex01\nex02\nex03\nex04"},"Module_02":{"slug":"Module_02","filePath":"Module_02.md","title":"Module_02","links":["00","01"],"tags":[],"content":"\nCe module\n\nLes exercices\n00\n01\n/02\n/03"},"POSIX":{"slug":"POSIX","filePath":"POSIX.md","title":"POSIX","links":[],"tags":[],"content":"Qu‚Äôest-ce que?"},"STL":{"slug":"STL","filePath":"STL.md","title":"STL","links":[],"tags":[],"content":"\nNom anglais: Standard Template Library (STL)\n\n\nLa STL est une partie de la biblioth√®que standard C++ qui fournit des outils g√©n√©riques et efficaces pour g√©rer des donn√©es : conteneurs, algorithmes, it√©rateurs, etc.\nElle repose sur les templates, ce qui permet de l‚Äôutiliser avec n‚Äôimporte quel type.\n\nComposants principaux de la STL\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCat√©gorieExemplesR√¥leConteneursstd::vector, std::map, std::set, std::stackStocker des donn√©esAlgorithmesstd::sort, std::find, std::countManipuler les donn√©esIt√©rateursbegin(), end(), std::next()Parcourir les conteneursFoncteursstd::less, std::greaterObjets-fonctions pour comparer\nExemples simples\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n \nstd::vector&lt;int&gt; v = {3, 1, 4};\nstd::sort(v.begin(), v.end()); // trie le vecteur\nR√©sum√©\n\nüìå La STL est une biblioth√®que puissante et g√©n√©rique bas√©e sur les templates.\nElle permet de g√©rer et manipuler des collections de donn√©es de fa√ßon rapide et modulaire.\n"},"UNIX":{"slug":"UNIX","filePath":"UNIX.md","title":"UNIX","links":["syst√®me-d‚Äôexploitation","POSIX"],"tags":[],"content":"Qu‚Äôest-ce que UNIX?\n\nUNIX est un syst√®me d‚Äôexploitation cr√©√© dans les ann√©es 1970 au sein des laboratoires Bell (AT&amp;T).\nC‚Äôest un syst√®me rapide, puissant et modulaire, con√ßu pour √™tre simple, stable et multi-utilisateur.\nBeaucoup de syst√®mes modernes (Linux, macOS, BSD) sont directement inspir√©s d‚ÄôUNIX ou en sont des variantes.\n\nEn r√©sum√©\n\nUNIX = syst√®me d‚Äôexploitation multi-t√¢ches et multi-utilisateur.\nBas√© sur des concepts simples : tout est fichier, chaque t√¢che est un petit programme.\nFavorise la philosophie de la simplicit√© : faire une chose, mais la faire bien.\nTr√®s utilis√© dans les serveurs, infrastructures r√©seau, et syst√®mes critiques.\n\nExemples de descendants ou inspir√©s d‚ÄôUNIX\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyst√®meD√©tailLinuxUNIX-like libre et open sourcemacOSDirectement bas√© sur UNIX BSDFreeBSDVariante libre de UNIXSolarisUNIX d√©velopp√© par Sun Microsystems\n√Ä retenir :\n\nUNIX n‚Äôest pas un seul syst√®me, c‚Äôest une famille de syst√®mes qui partagent une philosophie.\nLa norme POSIX (standard pour compatibilit√© UNIX) est issue de cette culture.\n"},"UpperCamelCase":{"slug":"UpperCamelCase","filePath":"UpperCamelCase.md","title":"UpperCamelCase","links":["convention-de-nommage","classe","structure","√©num√©ration","C++"],"tags":[],"content":"\nNom anglais: UpperCamelCase / PascalCase (peu utilis√©)\n\n\nLe UpperCamelCase est une convention de nommage utilis√©e notamment pour nommer les classes.\nChaque mot commence par une majuscule, y compris le premier, et les mots sont coll√©s sans s√©parateurs.\n\n\nExemples\nclass PhoneBook {};\nclass ContactInfo {};\nstruct UserData {};\n\nUsage en C++\nLa convention de nommageUpperCamelCase est g√©n√©ralement utilis√©e pour :\n\nclasse class\nstructure struct\n√©num√©ration enum\ntype personnalis√©\n\n\nComparaison avec d‚Äôautres styles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStyleExempleUsage typiqueUpperCamelCaseMaClasseClasses, typeslowerCamelCasemaVariableFonctions, variablessnake_casema_variableVariables (C), fichiersSCREAMING_SNAKE_CASETAILLE_MAXConstantes, macros\nR√©sum√©\n\nLe UpperCamelCase est un style d‚Äô√©criture utilis√© pour nommer les types en C++ o√π chaque mot commence par une majuscule.\nIl am√©liore la lisibilit√© et permet de distinguer facilement les types des variables.\n"},"accesseur":{"slug":"accesseur","filePath":"accesseur.md","title":"accesseur","links":["m√©thode","classe","attribut","priv√©","membre","structure","C++","encapsulation","objet","publique","valeur","r√©f√©rence"],"tags":[],"content":"\nNom anglais: getter / accessor\n\n\nUn accesseur (getter) est une m√©thode d‚Äôune classe utilis√©e pour lire la valeur d‚Äôun attribut priv√© sans permettre de la modifier.\nComparaison C/C++ : En C, on acc√®de directement aux membres d‚Äôune structure. En C++, on privil√©gie les accesseurs pour respecter l‚Äôencapsulation des donn√©es et renforcer la s√©curit√©.\n\n\nPourquoi utiliser un accesseur\nLes attributs sont g√©n√©ralement d√©clar√©s en priv√© pour √©viter une modification directe depuis l‚Äôext√©rieur. Un accesseur fournit un moyen contr√¥l√© et s√ªr d‚Äôy acc√©der, permettant :\n\nde prot√©ger l‚Äô√©tat interne de l‚Äôobjet,\nde changer l‚Äôimpl√©mentation interne sans modifier l‚Äôinterface publique,\nde d√©boguer ou journaliser les acc√®s si n√©cessaire.\n\n\nEn r√®gle g√©n√©rale, un accesseur est une m√©thode publique, car son r√¥le est de permettre la lecture d‚Äôun attribut priv√© depuis l‚Äôext√©rieur de la classe, tout en respectant les principes d‚Äôencapsulation.\n\n\nD√©finir un accesseur simple\nUn accesseur est une m√©thode publique qui retourne la valeur d‚Äôun attribut priv√© :\nclass Voiture {\nprivate:\n    int vitesse;\n \npublic:\n    int getVitesse() const {\n        return vitesse;\n    }\n};\n\nBonne pratique : un accesseur ne modifiant pas l‚Äôobjet doit √™tre marqu√© const.\n\n\nUtilisation\nVoiture v;\nint vitesse = v.getVitesse();\nCela r√©cup√®re la valeur de vitesse sans modifier l‚Äôobjet v.\n\nRetour par r√©f√©rence constante\nQuand l‚Äôattribut est un type complexe (comme std::string, std::vector, ou tout objet non trivial), il est pr√©f√©rable de retourner une r√©f√©rence constante, pour √©viter une copie co√ªteuse :\nclass Voiture {\nprivate:\n    std::string marque;\n \npublic:\n    const std::string&amp; getMarque() const {\n        return marque;\n    }\n};\n\n‚úÖ Avantages :\n\n√âvite une copie inutile\nEmp√™che la modification de l‚Äôattribut retourn√©\nMaintient la performance et la s√©curit√©\n\n\nNe pas retourner une r√©f√©rence non-const si on ne veut pas que l‚Äôutilisateur modifie l‚Äôattribut :\n&gt; std::string&amp; getMarque(); // dangereux si l&#039;utilisateur modifie marque !\n&gt; ```\n \n---\n### Bonnes pratiques\n \n- Pr√©f√©rer `const T&amp;` pour les types complexes (ex: `std::string`, `std::vector`)\n- Pr√©f√©rer `T` pour les types simples (ex: `int`, `bool`, `float`)\n- Toujours marquer l&#039;accesseur `const`\n- Ne jamais exposer une r√©f√©rence non-const √† un attribut priv√© sauf n√©cessit√© absolue\n \n---\n### Convention de nommage\n \nLes accesseurs suivent en g√©n√©ral la forme `getNomDeLAttribut`. Par exemple :\n \n- `getCouleur()`\n- `getVitesse()`\n- `getMarque()`"},"allocateur":{"slug":"allocateur","filePath":"allocateur.md","title":"allocateur","links":["STL","conteneur","C++","objet","C++98","param√®tre","allocation-dynamique-de-la-m√©moire"],"tags":[],"content":"\nNom anglais: allocator\nNom pleinement qualifi√©: std::allocator\n\n\nUn allocateur allocator est une abstraction de la STL qui permet aux conteneurs C++ de g√©rer la m√©moire sans d√©pendre d‚Äôune impl√©mentation sp√©cifique.\nIl d√©finit les m√©canismes permettant d‚Äôallouer, construire, d√©truire et d√©sallouer dynamiquement les objets utilis√©s par un conteneur comme std::vector, std::list, std::map, etc.\n\n\nR√¥le principal\nUn allocator est utilis√© par d√©faut dans tous les conteneurs de la STL pour :\n\nr√©server un espace m√©moire (allocate)\nconstruire un objet (construct)\nd√©truire un objet (destroy)\nlib√©rer la m√©moire (deallocate)\n\nIl permet ainsi de d√©coupler la gestion m√©moire de la logique m√©tier du conteneur.\n\nImpl√©mentation par d√©faut\nEn C++98, le type d‚Äôallocateur par d√©faut est :\nstd::allocator&lt;T&gt;\n\nC‚Äôest l‚Äôallocateur standard qui utilise operator new et operator delete pour la gestion m√©moire.\n\nTous les conteneurs STL acceptent un param√®tre template optionnel pour sp√©cifier un autre allocateur :\nstd::vector&lt;int, std::allocator&lt;int&gt; &gt; myVec;\n\nM√©thodes typiques d‚Äôun allocateur (C++98)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionallocate(n)Alloue un bloc brut pour n objets de type Tconstruct(p, val)Construit un objet de type T √† l‚Äôadresse pdestroy(p)Appelle explicitement le destructeur de l‚Äôobjet √† pdeallocate(p, n)Lib√®re le bloc m√©moire pr√©c√©demment allou√©\n\nCes fonctions peuvent √™tre utilis√©es directement dans une impl√©mentation de conteneur personnalis√©.\n\n\nExemple d‚Äôutilisation par un conteneur\nLors d‚Äôun push_back() dans un std::vector :\n\nLe conteneur appelle allocate() si la capacit√© est d√©pass√©e\nIl appelle construct() pour construire l‚Äôobjet dans la m√©moire allou√©e\nSi un √©l√©ment est supprim√©, il appelle destroy(), puis deallocate()\n\n\nPersonnalisation\nIl est possible de cr√©er un allocator personnalis√© pour :\n\ntracer les allocations/d√©sallocations\nutiliser une m√©moire fixe ou partag√©e\nlimiter dynamiquement la quantit√© de m√©moire utilis√©e\nsimuler des politiques m√©moire sp√©cifiques √† un syst√®me embarqu√© ou temps r√©el\n\n\nExemples d‚Äôusage avanc√©\ntemplate&lt;typename T&gt;\nclass MyAlloc : public std::allocator&lt;T&gt; {\npublic:\n\tvoid* allocate(std::size_t n) {\n\t\tstd::cout &lt;&lt; &quot;Allocating &quot; &lt;&lt; n &lt;&lt; &quot; elements\\n&quot;;\n\t\treturn std::allocator&lt;T&gt;::allocate(n);\n\t}\n};\nstd::vector&lt;int, MyAlloc&lt;int&gt; &gt; trackedVec;\n\nVoir aussi\n‚Üí STL, conteneur, allocation dynamique de la m√©moire"},"allocation-dynamique-de-la-m√©moire":{"slug":"allocation-dynamique-de-la-m√©moire","filePath":"allocation dynamique de la m√©moire.md","title":"allocation dynamique de la m√©moire","links":["C++","tas","pile","op√©rateur","compilation","objet","bloc","destructeur","dur√©e-de-vie-des-objets","conteneur","structure","fonction","pointeur","C++11,","constructeur"],"tags":[],"content":"\nNom anglais: dynamic memory allocation\n\n\nEn C++, l‚Äôallocation dynamique de m√©moire permet de r√©server manuellement de l‚Äôespace sur le tas (heap) pendant l‚Äôex√©cution - √† la diff√©rence de la pile (stack).\nComparaison C/C++ : On utilise pour cela les op√©rateurs new, new[], delete et delete[], qui remplacent malloc() et free() de C (m√™me si ces derniers existent toujours en C++).\n\n\nPourquoi allouer dynamiquement ?\n\nQuand la taille des donn√©es n‚Äôest pas connue √† la compilation\nPour cr√©er des objets qui doivent persister au-del√† du bloc courant ({})\nPour g√©rer manuellement la dur√©e de vie, l‚Äôacc√®s ou la structure des donn√©es (ex: arbres, listes‚Ä¶)\n\n\nDur√©e de vie des objets en C++\nEn C++, un objet d√©clar√© sans new est dit automatique : il est cr√©√© sur la pile au moment o√π il entre en port√©e, puis d√©truit automatiquement √† la fin du bloc ({}) o√π il a √©t√© d√©clar√©.\nLe destructeur est alors appel√© sans intervention explicite.\n√Ä l‚Äôinverse, si l‚Äôobjet est cr√©√© avec new, il est allou√© sur le tas (heap) et doit √™tre d√©truit manuellement avec delete.\n‚Üí Voir la fiche d√©di√©e : dur√©e de vie des objets\n\nQuand utiliser new ?\nOn utilise new quand on veut que l‚Äôobjet continue d‚Äôexister apr√®s la fin du bloc, c‚Äôest-√†-dire :\n\nstock√© ailleurs (dans un conteneur ou une structure persistante)\npartag√© entre plusieurs fonctions\nrenvoy√© par une fonction (sans faire de copie)\ncontr√¥l√© manuellement (ex: destruction diff√©r√©e, patterns avanc√©s‚Ä¶)\n\n\nExemple avec new\nMyClass* create_object() {\n    MyClass* ptr = new MyClass(); // allou√© sur le tas (heap)\n    return ptr;                   // l&#039;objet vit en dehors de la fonction\n}\nL‚Äôobjet reste valide m√™me apr√®s le retour de la fonction, tant qu‚Äôil n‚Äôest pas supprim√© avec delete.\n\nOp√©rateurs d‚Äôallocation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOp√©rateurUsageDescriptionnewint *p = new int;Alloue un entier, retourne un pointeurnew[]int *t = new int[10];Alloue un tableau d‚Äôentiersdeletedelete p;Lib√®re la m√©moire allou√©e avec newdelete[]delete[] t;Lib√®re la m√©moire allou√©e avec new[]\n\nExemple simple\nint* a = new int(42);      // alloue un int initialis√© √† 42\nint* t = new int[3];       // alloue un tableau de 3 int\n \nt[0] = 1;\nt[1] = 2;\nt[2] = 3;\n \ndelete a;                  // lib√®re l&#039;entier\ndelete[] t;                // lib√®re le tableau\n\nBonnes pratiques\n\nNe jamais m√©langer new avec free() ou malloc() avec delete\nToujours utiliser delete / delete[] une seule fois par allocation\nNe pas oublier de lib√©rer la m√©moire ‚Üí sinon : fuites m√©moire\n√Ä partir de C++11, il est recommand√© d‚Äôutiliser des smart pointers (std::unique_ptr, std::shared_ptr) qui lib√®rent la m√©moire automatiquement\n\n\nVoir aussi\n‚Üí tas, pile,\n‚Üí pointeur, fonction, bloc, objet, constructeur, destructeur"},"ami":{"slug":"ami","filePath":"ami.md","title":"ami","links":["C++","fonction","classe","membre","priv√©","prot√©g√©","encapsulation","m√©thode","surcharge-d'op√©rateur","attribut","this","objet","accesseur","publique","classe-d√©riv√©e"],"tags":[],"content":"\nNom anglais: friend (friend function / friend class)\n\n\nEn C++, le mot-cl√© friend permet de d√©clarer une fonction ou une classe amie d‚Äôune autre classe. Cela signifie qu‚Äôelle a un acc√®s exceptionnel √† ses membres priv√©s ou prot√©g√©s,  sans en faire partie.\nUne fonction amie est une fonction externe √† la classe, mais d√©clar√©e avec friend √† l‚Äôint√©rieur de celle-ci.\nUne classe amie est une classe autoris√©e √† acc√©der aux membres internes d‚Äôune autre classe.\nComparaison C/C++ : En C, il n‚Äôexiste pas de protection entre les composants. En C++, le mot-cl√© friend permet d‚Äôaccorder un acc√®s limit√© √† un tiers, tout en maintenant une encapsulation rigoureuse ailleurs.\n\n\nUtilit√© du mot-cl√© friend\nLe mot-cl√© friend permet :\n\nd‚Äôautoriser explicitement l‚Äôacc√®s √† des membre priv√©s √† une fonction ou une classe sp√©cifique,\nd‚Äôimpl√©menter des fonctions globales fortement coupl√©es √† une classe sans en faire des m√©thodes,\nde g√©rer la surcharge d‚Äôop√©rateurs non membres (comme operator&lt;&lt; pour std::ostream par exemple),\nde donner un acc√®s privil√©gi√© √† une classe de support ou √† un outil interne.\n\n\nFonction amie\nD√©claration (prototype)\nUne fonction amie est d√©clar√©e avec le mot cl√© friend √† l‚Äôint√©rieur de la classe, mais d√©finie √† l‚Äôext√©rieur. Elle aura alors acc√®s aux m√©thodes et attributs priv√©s et prot√©g√©s de cette classe.\nclass Boite\n{\nprivate:\n    int _valeur;\n \npublic:\n    Boite(int v);\n    friend void afficher(const Boite&amp; b);\n};\n \nvoid afficher(const Boite&amp; b) {\n    std::cout &lt;&lt; b._valeur &lt;&lt; std::endl; // ‚úÖ autoris√© gr√¢ce √† friend\n}\nUtilisation\nLa fonction amie n‚Äôest pas une m√©thode de la classe : elle n‚Äôa pas de this et s‚Äôappelle sans op√©rateur . :\nBoite b(42);\nafficher(b);   // pas b.afficher()\n\nClasse amie\nOn peut aussi d√©clarer une classe amie. Cela donne √† toutes ses m√©thodes l‚Äôacc√®s aux membres priv√©s de la classe d√©clarant le friend.\nclass A;\n \nclass B {\n    friend class A; // A a acc√®s aux membres priv√©s de B\n};\nIl est √©galement possible de rendre amie une m√©thode pr√©cise d‚Äôune autre classe :\nclass A {\n    void speciale();\n};\n \nclass B {\n    friend void A::speciale(); // A::speciale() est autoris√©e √† acc√©der √† B\n};\n\nAcc√®s\nUne fonction ou classe amie peut acc√©der directement aux membres priv√©s et prot√©g√©s, mais elle ne devient pas membre de la classe et n‚Äôest pas appel√©e via un objet :\nvoid afficher(const Boite&amp; b) {\n    std::cout &lt;&lt; b._valeur; // autoris√©\n}\n\nBonnes pratiques\n\nL‚Äôusage de friend doit rester exceptionnel : il contourne l‚Äôencapsulation.\nPr√©f√©rer les accesseurs ou m√©thodes dans la majorit√© des cas.\nUtiliser friend uniquement si le besoin d‚Äôacc√®s est justifi√© et cibl√© (par exemple pour operator&lt;&lt;, classes de test, outils internes‚Ä¶).\n\nSon usage est justifi√© principalement lorsqu‚Äôune fonction ou une classe a un r√¥le √©troitement li√© √† l‚Äôimpl√©mentation interne sans en faire logiquement partie.\n\nVoir aussi\n‚Üí encapsulation, publique, priv√©, prot√©g√©\n‚Üí m√©thode, classe d√©riv√©e, surcharge d‚Äôop√©rateur, accesseur"},"argument":{"slug":"argument","filePath":"argument.md","title":"argument","links":["fonction","param√®tre","C++","r√©f√©rence","Param√®tre","variable","valeur","Litt√©ral","Variable"],"tags":[],"content":"\nNom anglais: argument\n\n\nUn argument est une valeur r√©elle transmise √† une fonction lors de son appel.\nCette valeur est affect√©e √† un param√®tre d√©clar√© dans la fonction.\nComparaison C/C++ : En C comme en C++, les arguments peuvent √™tre des valeurs, des adresses (pointeurs), et en C++uniquement, des r√©f√©rences.\n\n\nExemple\nvoid saluer(std::string nom) {\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n}\n \nsaluer(&quot;Alice&quot;);  // &quot;Alice&quot; est un argument\nIci, &quot;Alice&quot; est l‚Äôargument pass√© √† la fonction saluer.\n\nArgument vs param√®tre\nNe pas confondre ces notions proches :\n\nParam√®tre : variable d√©clar√©e dans la fonction (ex : std::string nom)\nArgument : valeur r√©ellement transmise (ex : &quot;Alice&quot;)\n\n‚Üí Voir la fiche d√©di√©e : param√®tre\n\nTypes d‚Äôarguments\n\nLitt√©ral : &quot;Salut&quot;, 42, 3.14\nVariable : nom, x, valeur\nExpression : a + b, fonction(), tab[i]\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint addition(int a, int b) {\n    return a + b;\n}\n \nint main() {\n    // Litt√©raux\n    std::string message = &quot;Salut&quot;; // &quot;Salut&quot; est un litt√©ral de type const char*\n    int x = 42;                    // 42 est un litt√©ral entier\n    double pi = 3.14;              // 3.14 est un litt√©ral flottant\n \n    // Variables\n    int a = 10;\n    int b = 5;\n    std::string nom = &quot;Alice&quot;;\n \n    // Expressions\n    int somme = a + b;               // a + b est une expression\n    int resultat = addition(a, b);   // addition(a, b) est une expression\n    char c = nom[0];                 // nom[0] est une expression (acc√®s √† un √©l√©ment)\n \n    // Affichage\n    std::cout &lt;&lt; message &lt;&lt; &quot;, &quot; &lt;&lt; nom &lt;&lt; &quot; !&quot; &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;La somme de &quot; &lt;&lt; a &lt;&lt; &quot; et &quot; &lt;&lt; b &lt;&lt; &quot; est &quot; &lt;&lt; somme &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;La premi√®re lettre de ton nom est : &quot; &lt;&lt; c &lt;&lt; std::endl;\n \n    return 0;\n}\n\nVoir aussi\n‚Üí fonction, param√®tre, r√©f√©rence"},"attribut-statique":{"slug":"attribut-statique","filePath":"attribut statique.md","title":"attribut statique","links":["membre-statique"],"tags":[],"content":"‚Üí Voir la fiche : membre statique"},"attribut":{"slug":"attribut","filePath":"attribut.md","title":"attribut","links":["objet","classe","variable","membre","structure","C++","encapsulation","accesseur","attribut","valeur","constructeur","liste-d'initialisation","biblioth√®que-standard-C++","priv√©","publique","prot√©g√©","m√©thode","r√©f√©rence","mutateur","convention-de-nommage","lowerCamelCase","param√®tre","constructeur-par-d√©faut","pointeur","C++11","C++98","membre-statique"],"tags":[],"content":"\nNom anglais: attribute / data members\n\n\nLes attributs repr√©sentent les donn√©es que chaque objet cr√©√© √† partir d‚Äôune classe va poss√©der.\nCe sont les variables membres qui d√©finissent l‚Äô√©tat interne d‚Äôun objet.\nComparaison C/C++ : Les attributs sont comparables aux champs (les variables) d‚Äôune structurestruct en langage C, mais en C++, ils sont encapsul√©s (voir encapsulation) et souvent prot√©g√©s via des accesseurs.\n\n\nAttributs, classes et objets\nChaque objet poss√®de ses propres copies des attributs d√©finis dans la classe.\nIls d√©crivent l‚Äô√©tat courant de l‚Äôobjet (valeurs, propri√©t√©s internes‚Ä¶).\nExemple :\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nclass Voiture {\nprivate:\n    std::string _couleur;\n};\n \nVoiture voiture1;    // voiture1 est un objet de type Voiture\nVoiture voiture2;    // voiture2 est un objet de type Voiture\n\nLa classe Voiture poss√®de un attribut _couleur priv√©.\nLe constructeur prend une cha√Æne de caract√®res pour initialiser _couleur via une liste d‚Äôinitialisation.\nChaque objet (voiture1, voiture2) a sa propre valeur de couleur, ind√©pendante de l‚Äôautre.\n\n\nAttributs et types\nLes attributs peuvent √™tre de tout type :\n\ntypes fondamentaux (int, float, bool, etc.)\ntypes de la biblioth√®que standard C++ (std::string, std::vector, etc.)\nou bien d‚Äôautres classes d√©finies par l‚Äôutilisateur.\n\n\nD√©claration d‚Äôun attribut\nLes attributs sont g√©n√©ralement d√©clar√©s dans la section priv√©e (private) d‚Äôune classe, afin d‚Äôemp√™cher tout acc√®s ou modification non contr√¥l√©e (comme dans l‚Äôexemple ci-dessus). Cela fait partie de l‚Äôencapsulation.\nLes attributs peuvent √™tre initialis√©s lors de la construction de l‚Äôobjet par le constructeur, g√©n√©ralement √† l‚Äôaide d‚Äôune liste d‚Äôinitialisation.\n‚Üí Voir les fiches d√©di√©es : priv√©, publique, prot√©g√©\n\nInteragir avec un attribut\nPour acc√©der ou modifier un attribut priv√©, on utilise g√©n√©ralement:\n\ndes accesseurs (getX()) : des m√©thodes qui retournent la valeur d‚Äôun attribut, souvent sous forme de r√©f√©rence constante\ndes mutateurs (setX(valeur)), des m√©thodes qui servent √† modifier un attribut de mani√®re encadr√©e\n\n**‚Üí Voir les fiches d√©di√©es : accesseur, mutateur\n\nConventions de nommage\nEn C++, on suit souvent ces convention de nommages pour nommer les attributs :\n\npr√©fixe _ (underscore) : exemple int _x;\nnom en lowerCamelCase : exemple int vitesseMax;\njamais de noms ambigus ou trop courts (a, b, c) sauf en contexte local\n\nExemple :\n_color\n_registrationDate\n_maxSpeed_\n\nCes conventions permettent de distinguer rapidement les attributs dans la classe et d‚Äô√©viter les conflits avec les param√®tres ou variables locales.\n\n\nExemple\nclass A {\nprivate:\n    int x;              // non initialis√© ‚Üí ind√©fini\n    std::string nom;    // bien initialis√© ‚Üí &quot;&quot;\n};\nSans action dans le constructeur, x contient une valeur ind√©finie, tandis que nom est une cha√Æne vide (&quot;&quot;), car std::string appelle son constructeur par d√©faut.\n\nAttributs non initialis√©s\nSi un attribut n‚Äôest pas initialis√© explicitement lors de la construction de l‚Äôobjet par le constructeur, sa valeur d√©pend de son type :\n\nLes types fondamentaux (int, float, bool, etc.) auront une valeur ind√©termin√©e (contenu m√©moire brut).\nLes attributs qui sont des objets seront initialis√©s par leur constructeur par d√©faut (√† condition que celui-ci soit impl√©ment√© pour les initialiser). Par exemple un attribut de type std::string sera initialis√© par le constructeur de std::string avec une cha√Æne vide (&quot;&quot;).\nLes pointeurs (int*, etc.) auront eux aussi une valeur ind√©termin√©e, sauf s‚Äôils sont explicitement initialis√©s √† nullptr.\n\nCela signifie que le constructeur de la classe doit initialiser explicitement tous les attributs, soit :\n\ndans une liste d‚Äôinitialisation,\nsoit via une initialisation directe (√† partir de C++11),\nmais jamais en les laissant non initialis√©s.\n\n\nEn C++98, on ne peut pas initialiser directement un attribut dans sa d√©claration. Il faut utiliser la liste d‚Äôinitialisation du constructeur.\n\n\nAttributs statiques\nUn attribut statique (ou attribut de classe) est un membre statique partag√© par toutes les instances d‚Äôune m√™me classe.\nContrairement aux attributs ordinaires, il n‚Äôappartient pas √† un objet particulier, mais √† la classe elle-m√™me.\nCela signifie que :\n\nil n‚Äôexiste qu‚Äôen un seul exemplaire, peu importe le nombre d‚Äôobjets cr√©√©s,\nil peut √™tre acc√©d√© directement via le nom de la classe : MaClasse::monAttributStatique.\n\nLes attributs statiques sont utiles pour partager des valeurs globales, des compteurs, ou des constantes communes √† tous les objets.\n‚Üí Voir la fiche d√©di√©e : membre statique\n\nVoir aussi\n‚Üí classe, objet, accesseur, mutateur , priv√©, publique, prot√©g√©, convention de nommage, lowerCamelCase, membre statique"},"biblioth√®que-algorithm":{"slug":"biblioth√®que-algorithm","filePath":"biblioth√®que algorithm.md","title":"biblioth√®que algorithm","links":["biblioth√®que","STL","C++","fonction","membre","vecteur","liste","it√©rateur","espace-de-noms","nom-pleinement-qualifi√©","conteneur","foncteur","C++11","param√®tre","biblioth√®que-standard","biblioth√®que-numeric","conteneur-associatif","pr√©dicat","objet","√™tre","op√©rateur"],"tags":[],"content":"\nBiblioth√®que standard: &lt;algorithm&gt;\n\n\nLa biblioth√®que &lt;algorithm&gt; fait partie de la STL en C++.\nElle fournit un ensemble riche de fonctions g√©n√©riques (sous forme de fonction libres, non membres) pour le traitement de collections des la STL, telles que vecteur vector, liste list,  etc.\nCes fonctions couvrent des op√©rations courantes : parcours, tri, recherche, manipulation, fusion, et plus encore. Elles sont toutes bas√©es sur des it√©rateurs, ce qui les rend tr√®s g√©n√©rales.\n\n\nInclusion\nPour utiliser la biblioth√®que &lt;algorithm&gt; :\n#include &lt;algorithm&gt;\n\nNom pleinement qualifi√©\nLes fonctions de &lt;algorithm&gt; sont d√©finies dans l‚Äôespace de noms std.  Elles doivent donc √™tre appel√©es avec leur nom pleinement qualifi√©:\n‚Üí std::sort, std::find, std::max, etc.\nOu bien √©crire:\n‚Üí using namespace std\nCependant, cela peut entra√Æner des conflits de nom si on inclut d‚Äôautres biblioth√®ques.\nIl est donc recommand√© de pr√©fixer explicitement les appels aux fonctions de &lt;algorithm&gt; avec std::\n\nFonctionnement\nLes fonctions de algorithm&gt; sont con√ßues pour travailler sur deux it√©rateurs : un d√©but et une fin. Elles ne manipulent pas directement les conteneurs, mais les intervalles que ceux-ci exposent via begin() et end().\nstd::sort(vec.begin(), vec.end());\n\nBeaucoup de ces fonctions utilisent des foncteurs ou des fonctions lambda (√† partir de C++11) comme param√®tres personnalis√©s.\n\n\nPrincipales cat√©gories de fonctions\nRecherche &amp; test\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionfindCherche un √©l√©ment √©gal √† une valeurfind_ifCherche selon un pr√©dicatcountCompte le nombre d‚Äôoccurrencescount_ifCompte selon un pr√©dicatany_of / all_of / none_ofV√©rifie une condition sur un intervalle (C++11)equalCompare deux s√©quencesmismatchCompare deux s√©quences jusqu‚Äô√† divergencesearchRecherche une sous-s√©quence\nManipulation d‚Äô√©l√©ments\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptioncopyCopie une s√©quencecopy_ifCopie selon un pr√©dicat (C++11)moveD√©place des √©l√©ments (C++11)fill / fill_nRemplit avec une valeurreplace / replace_ifRemplace des valeursremove / remove_ifSupprime (logiquement) les √©l√©mentstransformApplique une fonction √† chaque √©l√©mentswap_ranges√âchange deux intervalles\nTri &amp; ordre\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionsortTrie l‚Äôintervallestable_sortTrie en conservant l‚Äôordre relatifpartial_sortTrie partiellement le d√©butnth_elementPositionne le n-i√®me √©l√©ment comme s‚Äôil √©tait tri√©is_sortedV√©rifie si c‚Äôest tri√©is_sorted_untilDonne l‚Äôendroit o√π le tri s‚Äôarr√™te\nMinimum, maximum\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionmin, maxRenvoie le plus petit / grand de deux √©l√©mentsmin_element / max_elementCherche le min / max dans un intervalle\nR√©organisation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionreverseInverse l‚ÄôordrerotateD√©place une section du tableaushuffle / random_shuffleM√©lange les √©l√©ments (d√©pr√©ci√© en C++14/17)partition / stable_partitionS√©pare selon un pr√©dicatuniqueSupprime les doublons cons√©cutifs\nFusion &amp; ensembles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionmergeFusionne deux s√©quences tri√©esinplace_mergeFusionne deux parties contigu√´s d‚Äôun conteneurincludesV√©rifie si un ensemble est inclus dans l‚Äôautreset_union / set_intersection / set_difference / set_symmetric_differenceOp√©rations ensemblistes\n‚Üí Pour une description plus d√©taill√©e, voir en fin de page\nOp√©rations num√©riques\nCertaines fonctions num√©riques associ√©es aux s√©quences sont d√©finies non pas dans algorithm, mais dans une biblioth√®que standard s√©par√©e : la biblioth√®que numeric.\nElles permettent de faire des sommations, produits, diff√©rences et sommes cumul√©es sur des intervalles d‚Äôit√©rateurs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstd::accumulateCalcule une somme ou accumulation personnalis√©e.std::inner_productProduit scalaire entre deux s√©quences.std::partial_sumCalcule les sommes cumul√©es d‚Äôune s√©quence.std::adjacent_differenceCalcule les diff√©rences successives entre √©l√©ments.\n‚Üí Voir la fiche d√©di√©e biblioth√®que numeric.\nRemarques importantes\n\nLes fonctions de &lt;algorithm&gt; sont g√©n√©riques et d√©pendent uniquement du type d‚Äôit√©rateur\nElles ne modifient pas la taille du conteneur sauf si combin√©es √† des op√©rations comme erase\nBeaucoup d‚Äôentre elles ont une version avec pr√©dicat personnalis√© (find_if, sort(pred), etc.)\nPour les conteneur associatifs (map, set), certaines fonctions ne sont pas applicables car ces conteneurs g√®rent leur propre ordre.\n\n\nExemple simple\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::vector&lt;int&gt; v = {4, 2, 1, 3};\n    std::sort(v.begin(), v.end());\n    for (int n : v)\n        std::cout &lt;&lt; n &lt;&lt; &#039; &#039;; // 1 2 3 4\n}\n\nDescription d√©taill√©e des fonctions (avec valeurs de retour et param√®tres)\nRecherche &amp; test\nfind\ntemplate &lt;class InputIterator, class T&gt; InputIterator find(InputIterator first, InputIterator last, const T&amp; val);\nDescription : La fonction find recherche le premier √©l√©ment dans l‚Äôintervalle [first, last) qui est √©gal √† val. Elle retourne un it√©rateur pointant sur cet √©l√©ment s‚Äôil est trouv√©, sinon elle retourne last.\nType de retour : InputIterator\nCas d‚Äôerreurs/Remarques : Si l‚Äô√©l√©ment n‚Äôest pas trouv√©, l‚Äôit√©rateur retourn√© sera √©gal √† last. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nfind_if\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; InputIterator find_if(InputIterator first, InputIterator last, UnaryPredicate p);\nDescription : La fonction find_if recherche le premier √©l√©ment dans l‚Äôintervalle [first, last) pour lequel le pr√©dicat p retourne true. Elle retourne un it√©rateur pointant sur cet √©l√©ment s‚Äôil est trouv√©, sinon elle retourne last.\nType de retour : InputIterator\nCas d‚Äôerreurs/Remarques : Si aucun √©l√©ment ne satisfait le pr√©dicat, l‚Äôit√©rateur retourn√© sera √©gal √† last. Le pr√©dicat doit √™tre une fonction ou un objet fonction qui accepte un argument du type point√© par InputIterator.\ncount\ntemplate &lt;class InputIterator, class T&gt; typename iterator_traits&lt;InputIterator&gt;::difference_type count(InputIterator first, InputIterator last, const T&amp; val);\nDescription : La fonction count compte le nombre d‚Äô√©l√©ments dans l‚Äôintervalle [first, last) qui sont √©gaux √† val.\nType de retour : typename iterator_traits&lt;InputIterator&gt;::difference_type\nCas d‚Äôerreurs/Remarques : Retourne 0 si aucun √©l√©ment n‚Äôest trouv√©. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\ncount_if\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; typename iterator_traits&lt;InputIterator&gt;::difference_type count_if(InputIterator first, InputIterator last, UnaryPredicate p);\nDescription : La fonction count_if compte le nombre d‚Äô√©l√©ments dans l‚Äôintervalle [first, last) pour lesquels le pr√©dicat p retourne true.\nType de retour : typename iterator_traits&lt;InputIterator&gt;::difference_type\nCas d‚Äôerreurs/Remarques : Retourne 0 si aucun √©l√©ment ne satisfait le pr√©dicat. Le pr√©dicat doit √™tre une fonction ou un objet fonction qui accepte un argument du type point√© par InputIterator.\nany_of / all_of / none_of\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; bool any_of(InputIterator first, InputIterator last, UnaryPredicate p);\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; bool all_of(InputIterator first, InputIterator last, UnaryPredicate p);\ntemplate &lt;class InputIterator, class UnaryPredicate&gt; bool none_of(InputIterator first, InputIterator last, UnaryPredicate p);\nDescription :\n\nany_of : Retourne true si au moins un √©l√©ment dans l‚Äôintervalle [first, last) satisfait le pr√©dicat p.\nall_of : Retourne true si tous les √©l√©ments dans l‚Äôintervalle [first, last) satisfont le pr√©dicat p.\nnone_of : Retourne true si aucun √©l√©ment dans l‚Äôintervalle [first, last) ne satisfait le pr√©dicat p.\n\nType de retour : bool\nCas d‚Äôerreurs/Remarques : Ces fonctions n√©cessitent que le pr√©dicat soit une fonction ou un objet fonction qui accepte un argument du type point√© par InputIterator.\nequal\ntemplate &lt;class InputIterator1, class InputIterator2&gt; bool equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\nDescription : La fonction equal compare deux s√©quences. Elle retourne true si tous les √©l√©ments de l‚Äôintervalle [first1, last1) sont √©gaux aux √©l√©ments de la s√©quence commen√ßant √† first2.\nType de retour : bool\nCas d‚Äôerreurs/Remarques : Les deux s√©quences doivent avoir au moins last1 - first1 √©l√©ments. Sinon, le comportement est ind√©fini.\nmismatch\ntemplate &lt;class InputIterator1, class InputIterator2&gt; pair&lt;InputIterator1, InputIterator2&gt; mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\nDescription : La fonction mismatch compare deux s√©quences et retourne une paire d‚Äôit√©rateurs pointant sur le premier √©l√©ment o√π les deux s√©quences diff√®rent.\nType de retour : pair&lt;InputIterator1, InputIterator2&gt;\nCas d‚Äôerreurs/Remarques : Si les s√©quences sont identiques jusqu‚Äô√† last1, la paire retourn√©e sera (last1, first2 + (last1 - first1)).\nsearch\ntemplate &lt;class ForwardIterator1, class ForwardIterator2&gt; ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);\nDescription : La fonction search recherche la premi√®re occurrence de la sous-s√©quence [first2, last2) dans la s√©quence [first1, last1).\nType de retour : ForwardIterator1\nCas d‚Äôerreurs/Remarques : Si la sous-s√©quence n‚Äôest pas trouv√©e, l‚Äôit√©rateur retourn√© sera √©gal √† last1. Assurez-vous que les it√©rateurs sont valides et que les intervalles sont correctement d√©finis.\nManipulation d‚Äô√©l√©ments\nstd::copy\ntemplate &lt;class InputIterator, class OutputIterator&gt; OutputIterator copy(InputIterator first, InputIterator last, OutputIterator dest);\nDescription : La fonction std::copy copie les √©l√©ments de l‚Äôintervalle [first, last) vers la destination commen√ßant √† dest. Elle retourne un it√©rateur pointant sur la fin de la destination.\nType de retour : OutputIterator\nCas d‚Äôerreurs/Remarques : Assurez-vous que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments copi√©s.\nstd::copy_if\ntemplate &lt;class InputIterator, class OutputIterator, class UnaryPredicate&gt; OutputIterator copy_if(InputIterator first, InputIterator last, OutputIterator dest, UnaryPredicate pred);\nDescription : La fonction std::copy_if copie les √©l√©ments de l‚Äôintervalle [first, last) pour lesquels le pr√©dicat pred retourne true vers la destination commen√ßant √† dest.\nType de retour : OutputIterator\nCas d‚Äôerreurs/Remarques : Assurez-vous que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments copi√©s. Le pr√©dicat doit √™tre une fonction ou un objet fonction qui accepte un argument du type point√© par InputIterator.\nstd::move\ntemplate &lt;class InputIterator, class OutputIterator&gt; OutputIterator move(InputIterator first, InputIterator last, OutputIterator dest);\nDescription : La fonction std::move d√©place les √©l√©ments de l‚Äôintervalle [first, last) vers la destination commen√ßant √† dest. Elle retourne un it√©rateur pointant sur la fin de la destination.\nType de retour : OutputIterator\nCas d‚Äôerreurs/Remarques : Assurez-vous que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments d√©plac√©s. Apr√®s le d√©placement, les √©l√©ments source sont laiss√©s dans un √©tat valide mais non sp√©cifi√©.\nstd::fill\ntemplate &lt;class ForwardIterator, class T&gt; void fill(ForwardIterator first, ForwardIterator last, const T&amp; value);\nDescription : La fonction std::fill remplit l‚Äôintervalle [first, last) avec la valeur value.\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que l‚Äôintervalle est valide et que les it√©rateurs sont correctement d√©finis.\nstd::fill_n\ntemplate &lt;class OutputIterator, class Size, class T&gt; OutputIterator fill_n(OutputIterator first, Size count, const T&amp; value);\nDescription : La fonction std::fill_n remplit count √©l√©ments avec la valeur value, √† partir de first.\nType de retour : OutputIterator\nCas d‚Äôerreurs/Remarques : Assurez-vous que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments remplis.\nstd::replace\ntemplate &lt;class ForwardIterator, class T&gt; void replace(ForwardIterator first, ForwardIterator last, const T&amp; old_value, const T&amp; new_value);\nDescription : La fonction std::replace remplace tous les √©l√©ments √©gaux √† old_value par new_value dans l‚Äôintervalle [first, last).\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que l‚Äôintervalle est valide et que les it√©rateurs sont correctement d√©finis.\nstd::replace_if\ntemplate &lt;class ForwardIterator, class UnaryPredicate, class T&gt; void replace_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred, const T&amp; new_value);\nDescription : La fonction std::replace_if remplace les √©l√©ments satisfaisant le pr√©dicat pred par new_value dans l‚Äôintervalle [first, last).\nType de retour : void\nCas d‚Äôerreurs/Remarques : Le pr√©dicat doit √™tre une fonction ou un objet fonction qui accepte un argument du type point√© par ForwardIterator.\nstd::remove\ntemplate &lt;class ForwardIterator, class T&gt; ForwardIterator remove(ForwardIterator first, ForwardIterator last, const T&amp; value);\nDescription : La fonction std::remove r√©arrange les √©l√©ments dans l‚Äôintervalle [first, last) pour supprimer tous les √©l√©ments √©gaux √† value. Elle retourne un it√©rateur pointant sur la nouvelle fin de l‚Äôintervalle.\nType de retour : ForwardIterator\nCas d‚Äôerreurs/Remarques : La taille de l‚Äôintervalle n‚Äôest pas modifi√©e. Les √©l√©ments apr√®s la nouvelle fin sont laiss√©s dans un √©tat valide mais non sp√©cifi√©.\nstd::remove_if\ntemplate &lt;class ForwardIterator, class UnaryPredicate&gt; ForwardIterator remove_if(ForwardIterator first, ForwardIterator last, UnaryPredicate pred);\nDescription : La fonction std::remove_if r√©arrange les √©l√©ments dans l‚Äôintervalle [first, last) pour supprimer tous les √©l√©ments satisfaisant le pr√©dicat pred. Elle retourne un it√©rateur pointant sur la nouvelle fin de l‚Äôintervalle.\nType de retour : ForwardIterator\nCas d‚Äôerreurs/Remarques : La taille de l‚Äôintervalle n‚Äôest pas modifi√©e. Les √©l√©ments apr√®s la nouvelle fin sont laiss√©s dans un √©tat valide mais non sp√©cifi√©.\nstd::transform\ntemplate &lt;class InputIterator, class OutputIterator, class UnaryOperation&gt; OutputIterator transform(InputIterator first, InputIterator last, OutputIterator dest, UnaryOperation op);\nDescription : La fonction std::transform applique l‚Äôop√©ration unaire op √† chaque √©l√©ment de l‚Äôintervalle [first, last) et stocke le r√©sultat dans la destination commen√ßant √† dest.\nType de retour : OutputIterator\nCas d‚Äôerreurs/Remarques : Assurez-vous que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments transform√©s.\nstd::transform (binaire)\ntemplate &lt;class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation&gt; OutputIterator transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator dest, BinaryOperation op);\nDescription : La fonction std::transform applique l‚Äôop√©ration binaire op √† deux s√©quences en parall√®le et stocke le r√©sultat dans la destination commen√ßant √† dest.\nType de retour : OutputIterator\nCas d‚Äôerreurs/Remarques : Assurez-vous que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments transform√©s. Les deux s√©quences doivent avoir au moins last1 - first1 √©l√©ments.\nstd::swap_ranges\ntemplate &lt;class ForwardIterator1, class ForwardIterator2&gt; ForwardIterator2 swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\nDescription : La fonction std::swap_ranges √©change les √©l√©ments des deux s√©quences [first1, last1) et [first2, first2 + (last1 - first1)) √©l√©ment par √©l√©ment.\nType de retour : ForwardIterator2\nCas d‚Äôerreurs/Remarques : Les deux s√©quences doivent avoir au moins last1 - first1 √©l√©ments. Sinon, le comportement est ind√©fini.\nTri &amp; ordre\nstd::sort\ntemplate &lt;class RandomIt&gt; void sort(RandomIt first, RandomIt last);\ntemplate &lt;class RandomIt, class Compare&gt; void sort(RandomIt first, RandomIt last, Compare comp);\nDescription : La fonction std::sort trie les √©l√©ments dans l‚Äôintervalle [first, last) en utilisant soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini. Le comparateur doit √™tre une fonction ou un objet fonction qui accepte deux arguments du type point√© par RandomIt.\nstd::stable_sort\ntemplate &lt;class RandomIt&gt; void stable_sort(RandomIt first, RandomIt last);\ntemplate &lt;class RandomIt, class Compare&gt; void stable_sort(RandomIt first, RandomIt last, Compare comp);\nDescription : La fonction std::stable_sort trie les √©l√©ments dans l‚Äôintervalle [first, last) tout en conservant l‚Äôordre relatif des √©l√©ments √©gaux. Elle utilise soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini. Le comparateur doit √™tre une fonction ou un objet fonction qui accepte deux arguments du type point√© par RandomIt.\nstd::partial_sort\ntemplate &lt;class RandomIt&gt; void partial_sort(RandomIt first, RandomIt middle, RandomIt last);\ntemplate &lt;class RandomIt, class Compare&gt; void partial_sort(RandomIt first, RandomIt middle, RandomIt last, Compare comp);\nDescription : La fonction std::partial_sort trie les middle - first plus petits √©l√©ments dans l‚Äôintervalle [first, last) en utilisant soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini. Le comparateur doit √™tre une fonction ou un objet fonction qui accepte deux arguments du type point√© par RandomIt.\nstd::nth_element\ntemplate &lt;class RandomIt&gt; void nth_element(RandomIt first, RandomIt nth, RandomIt last);\ntemplate &lt;class RandomIt, class Compare&gt; void nth_element(RandomIt first, RandomIt nth, RandomIt last, Compare comp);\nDescription : La fonction std::nth_element r√©organise les √©l√©ments dans l‚Äôintervalle [first, last) de sorte que l‚Äô√©l√©ment point√© par nth soit celui qui serait √† cette position dans un tri complet. Les √©l√©ments avant nth sont inf√©rieurs ou √©gaux √† ceux apr√®s nth.\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini. Le comparateur doit √™tre une fonction ou un objet fonction qui accepte deux arguments du type point√© par RandomIt.\nstd::is_sorted\ntemplate &lt;class ForwardIt&gt; bool is_sorted(ForwardIt first, ForwardIt last);\ntemplate &lt;class ForwardIt, class Compare&gt; bool is_sorted(ForwardIt first, ForwardIt last, Compare comp);\nDescription : La fonction std::is_sorted v√©rifie si les √©l√©ments dans l‚Äôintervalle [first, last) sont tri√©s en utilisant soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : bool\nCas d‚Äôerreurs/Remarques : Retourne true si les √©l√©ments sont tri√©s, sinon false. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nstd::is_sorted_until\ntemplate &lt;class ForwardIt&gt; ForwardIt is_sorted_until(ForwardIt first, ForwardIt last);\ntemplate &lt;class ForwardIt, class Compare&gt; ForwardIt is_sorted_until(ForwardIt first, ForwardIt last, Compare comp);\nDescription : La fonction std::is_sorted_until retourne un it√©rateur pointant sur le premier √©l√©ment non tri√© dans l‚Äôintervalle [first, last) en utilisant soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : ForwardIt\nCas d‚Äôerreurs/Remarques : Si tous les √©l√©ments sont tri√©s, retourne last. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nMinimum, maximum\nVoici les descriptions des fonctions C++ avec la pr√©sentation demand√©e :\nstd::min\ntemplate &lt;class T&gt; const T&amp; min(const T&amp; a, const T&amp; b);\ntemplate &lt;class T, class Compare&gt; const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);\nDescription : La fonction std::min renvoie le plus petit des deux √©l√©ments a et b en utilisant soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : const T&amp;\nCas d‚Äôerreurs/Remarques : Le comparateur doit √™tre une fonction ou un objet fonction qui accepte deux arguments du type T.\nstd::max\ntemplate &lt;class T&gt; const T&amp; max(const T&amp; a, const T&amp; b);\ntemplate &lt;class T, class Compare&gt; const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);\nDescription : La fonction std::max renvoie le plus grand des deux √©l√©ments a et b en utilisant soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : const T&amp;\nCas d‚Äôerreurs/Remarques : Le comparateur doit √™tre une fonction ou un objet fonction qui accepte deux arguments du type T.\nstd::min_element\ntemplate &lt;class ForwardIterator&gt; ForwardIterator min_element(ForwardIterator first, ForwardIterator last);\ntemplate &lt;class ForwardIterator, class Compare&gt; ForwardIterator min_element(ForwardIterator first, ForwardIterator last, Compare comp);\nDescription : La fonction std::min_element renvoie un it√©rateur pointant sur le plus petit √©l√©ment dans l‚Äôintervalle [first, last) en utilisant soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : ForwardIterator\nCas d‚Äôerreurs/Remarques : Si l‚Äôintervalle est vide, retourne last. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nstd::max_element\ntemplate &lt;class ForwardIterator&gt; ForwardIterator max_element(ForwardIterator first, ForwardIterator last);\ntemplate &lt;class ForwardIterator, class Compare&gt; ForwardIterator max_element(ForwardIterator first, ForwardIterator last, Compare comp);\nDescription : La fonction std::max_element renvoie un it√©rateur pointant sur le plus grand √©l√©ment dans l‚Äôintervalle [first, last) en utilisant soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : ForwardIterator\nCas d‚Äôerreurs/Remarques : Si l‚Äôintervalle est vide, retourne last. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nR√©organisation\nstd::reverse\ntemplate &lt;class BidirectionalIterator&gt; void reverse(BidirectionalIterator first, BidirectionalIterator last);\nDescription : La fonction std::reverse inverse l‚Äôordre des √©l√©ments dans l‚Äôintervalle [first, last).\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nstd::rotate\ntemplate &lt;class ForwardIterator&gt; ForwardIterator rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\nDescription : La fonction std::rotate d√©place les √©l√©ments de l‚Äôintervalle [first, middle) apr√®s l‚Äôintervalle [middle, last).\nType de retour : ForwardIterator\nCas d‚Äôerreurs/Remarques : Retourne un it√©rateur pointant sur le premier √©l√©ment de l‚Äôintervalle transform√©. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nstd::random_shuffle (C++98)\ntemplate &lt;class RandomIt&gt; void random_shuffle(RandomIt first, RandomIt last);\ntemplate &lt;class RandomIt, class RandomFunc&gt; void random_shuffle(RandomIt first, RandomIt last, RandomFunc&amp;&amp; r);\nDescription : La fonction std::random_shuffle m√©lange les √©l√©ments dans l‚Äôintervalle [first, last) en utilisant une fonction de g√©n√©ration al√©atoire r.\nType de retour : void\nCas d‚Äôerreurs/Remarques : Cette fonction est obsol√®te depuis C++14 et supprim√©e en C++17. Utilisez std::shuffle √† la place.\nstd::shuffle (C++11)\ntemplate &lt;class RandomIt, class URNG&gt; void shuffle(RandomIt first, RandomIt last, URNG&amp;&amp; g);\nDescription : La fonction std::shuffle m√©lange les √©l√©ments dans l‚Äôintervalle [first, last) en utilisant un g√©n√©rateur de nombres al√©atoires uniforme g.\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini. Le g√©n√©rateur de nombres al√©atoires doit √™tre conforme aux exigences d‚Äôun g√©n√©rateur de nombres al√©atoires uniforme.\nstd::partition\ntemplate &lt;class ForwardIt, class UnaryPredicate&gt; ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate pred);\nDescription : La fonction std::partition regroupe les √©l√©ments pour lesquels le pr√©dicat pred est vrai en t√™te de la s√©quence [first, last).\nType de retour : ForwardIt\nCas d‚Äôerreurs/Remarques : Retourne un it√©rateur pointant sur le premier √©l√©ment pour lequel le pr√©dicat est faux. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nstd::stable_partition\ntemplate &lt;class ForwardIt, class UnaryPredicate&gt; ForwardIt stable_partition(ForwardIt first, ForwardIt last, UnaryPredicate pred);\nDescription : La fonction std::stable_partition regroupe les √©l√©ments pour lesquels le pr√©dicat pred est vrai en t√™te de la s√©quence [first, last) tout en conservant l‚Äôordre relatif des √©l√©ments.\nType de retour : ForwardIt\nCas d‚Äôerreurs/Remarques : Retourne un it√©rateur pointant sur le premier √©l√©ment pour lequel le pr√©dicat est faux. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nstd::unique\ntemplate &lt;class ForwardIt&gt; ForwardIt unique(ForwardIt first, ForwardIt last);\ntemplate &lt;class ForwardIt, class BinaryPredicate&gt; ForwardIt unique(ForwardIt first, ForwardIt last, BinaryPredicate eq);\nDescription : La fonction std::unique supprime les doublons cons√©cutifs dans l‚Äôintervalle [first, last) en utilisant soit l‚Äôop√©rateur == par d√©faut, soit un pr√©dicat binaire eq.\nType de retour : ForwardIt\nCas d‚Äôerreurs/Remarques : Retourne un it√©rateur pointant sur la nouvelle fin logique de l‚Äôintervalle. Assurez-vous que les it√©rateurs sont valides et que l‚Äôintervalle est correctement d√©fini.\nFusion &amp; ensembles\nstd::merge\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt merge(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::merge fusionne deux s√©quences tri√©es [first1, last1) et [first2, last2) en une seule s√©quence tri√©e, stock√©e √† partir de dest. Elle utilise soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d‚Äôerreurs/Remarques : Assurez-vous que les s√©quences d‚Äôentr√©e sont tri√©es et que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments fusionn√©s.\nstd::inplace_merge\ntemplate &lt;class BidirectionalIt&gt; void inplace_merge(BidirectionalIt first, BidirectionalIt middle, BidirectionalIt last);\ntemplate &lt;class BidirectionalIt, class Compare&gt; void inplace_merge(BidirectionalIt first, BidirectionalIt middle, BidirectionalIt last, Compare comp);\nDescription : La fonction std::inplace_merge fusionne in-place deux sous-s√©quences contigu√´s tri√©es [first, middle) et [middle, last) en une seule s√©quence tri√©e. Elle utilise soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : void\nCas d‚Äôerreurs/Remarques : Assurez-vous que les sous-s√©quences sont tri√©es et que les it√©rateurs sont valides.\nstd::includes\ntemplate &lt;class InputIt1, class InputIt2&gt; bool includes(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2);\ntemplate &lt;class InputIt1, class InputIt2, class Compare&gt; bool includes(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, Compare comp);\nDescription : La fonction std::includes v√©rifie si tous les √©l√©ments de la deuxi√®me s√©quence tri√©e [first2, last2) sont pr√©sents dans la premi√®re s√©quence tri√©e [first1, last1). Elle utilise soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : bool\nCas d‚Äôerreurs/Remarques : Retourne true si la deuxi√®me s√©quence est un sous-ensemble de la premi√®re, sinon false. Assurez-vous que les s√©quences sont tri√©es.\nstd::set_union\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt set_union(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::set_union calcule l‚Äôunion de deux ensembles tri√©s [first1, last1) et [first2, last2) et stocke le r√©sultat √† partir de dest. Elle utilise soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d‚Äôerreurs/Remarques : Assurez-vous que les s√©quences d‚Äôentr√©e sont tri√©es et que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments de l‚Äôunion.\nstd::set_intersection\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt set_intersection(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::set_intersection calcule l‚Äôintersection de deux ensembles tri√©s [first1, last1) et [first2, last2) et stocke le r√©sultat √† partir de dest. Elle utilise soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d‚Äôerreurs/Remarques : Assurez-vous que les s√©quences d‚Äôentr√©e sont tri√©es et que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments de l‚Äôintersection.\nstd::set_difference\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt set_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::set_difference calcule la diff√©rence entre deux ensembles tri√©s [first1, last1) et [first2, last2) (√©l√©ments pr√©sents dans le premier mais pas dans le second) et stocke le r√©sultat √† partir de dest. Elle utilise soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d‚Äôerreurs/Remarques : Assurez-vous que les s√©quences d‚Äôentr√©e sont tri√©es et que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments de la diff√©rence.\nstd::set_symmetric_difference\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt&gt; OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest);\ntemplate &lt;class InputIt1, class InputIt2, class OutputIt, class Compare&gt; OutputIt set_symmetric_difference(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, OutputIt dest, Compare comp);\nDescription : La fonction std::set_symmetric_difference calcule la diff√©rence sym√©trique entre deux ensembles tri√©s [first1, last1) et [first2, last2) (√©l√©ments pr√©sents dans l‚Äôun ou l‚Äôautre ensemble, mais pas dans les deux) et stocke le r√©sultat √† partir de dest. Elle utilise soit l‚Äôop√©rateur &lt; par d√©faut, soit un comparateur comp fourni.\nType de retour : OutputIt\nCas d‚Äôerreurs/Remarques : Assurez-vous que les s√©quences d‚Äôentr√©e sont tri√©es et que la destination a suffisamment d‚Äôespace pour contenir tous les √©l√©ments de la diff√©rence sym√©trique."},"biblioth√®que-fstream":{"slug":"biblioth√®que-fstream","filePath":"biblioth√®que fstream.md","title":"biblioth√®que fstream","links":["biblioth√®que","biblioth√®que-standard-C++","flux","objet","m√©thode","STL","espace-de-noms","classe","classe-d√©riv√©e","biblioth√®que-iostream","classe-de-base","op√©rateur","valeur","surcharg√©","fonction","bloc","destructeur","manipulateur-de-flux"],"tags":[],"content":"\nBiblioth√®que standard: &lt;fstream&gt;\n\n\nLa biblioth√®que &lt;fstream&gt; fait partie de la biblioth√®que standard C++.\nElle permet de manipuler des flux associ√©s √† des fichiers : lecture, √©criture ou les deux, selon le type d‚Äôobjet utilis√© (std::ifstream, std::ofstream, std::fstream).\n\n\nInclusion\nPour utiliser les flux de fichiers :\n#include &lt;fstream&gt;\nCela rend accessibles les objets et [[classs]s] suivantes :\n\nstd::ifstream : lecture depuis un fichier\nstd::ofstream : √©criture dans un fichier\nstd::fstream : lecture et √©criture\n\nainsi que les m√©thodes associ√©es comme open(), close(), is_open(), etc.\n\nEspace de nom\nComme toutes les biblioth√®ques de la STL, fstream appartient √† l‚Äôespace de nom std.\nIl faut donc √©crire :\n‚Üí std::ifstream, std::ofstream, std::fstream\nOu importer l‚Äôespace de noms :\n‚Üí using namespace std\n\n‚ö†Ô∏è L‚Äôimport de using namespace std; reste d√©conseill√© dans les fichiers d‚Äôen-t√™te.\n\n\nPrincipaux flux de fichier\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNomTypeDescriptionstd::ifstreamstd::istreamLecture depuis un fichier texte ou binairestd::ofstreamstd::ostream√âcriture dans un fichier (√©crase ou cr√©e)std::fstreamstd::iostreamLecture et √©criture dans un m√™me fichier\n\nLes classes std::ifstream, std::ofstream, std::fstream sont des classe d√©riv√©es respectivement des flux de la biblioth√®que iostream std::istream, std::ostream, std::iostream. Ces classes √©tendent les fonctionnalit√©s de leurs classe de base respectives pour permettre la manipulation de fichiers.\nPour autant, il n‚Äôest pas n√©cessaire d‚Äôinclure &lt;iostream&gt; si on veut se servir exclusivement des flux de fichiers.\n\n\nModes d‚Äôouverture\nLes flux de fstream acceptent plusieurs modificateurs de mode :\n\nstd::ios::in : lecture\nstd::ios::out : √©criture\nstd::ios::app : ajout √† la fin (append)\nstd::ios::trunc : tronque le fichier (supprime le contenu)\nstd::ios::binary : mode binaire (par d√©faut : texte)\n\n\nOn peut combiner plusieurs modes avec | , par exemple :\n\nstd::fstream f(&quot;data.txt&quot;, std::ios::in | std::ios::out);\n\nUtilisation des op√©rateurs &lt;&lt; et &gt;&gt;\n\n&lt;&lt; pour insertion dans une cha√Æne (comme std::cout)\n&gt;&gt; pour extraction depuis une cha√Æne (comme std::cin)\n\n\nTr√®s utile pour formater des cha√Ænes, convertir des nombres, ou parser du texte ligne par ligne.\n\nInsertion dans un flux (&lt;&lt;)\nL‚Äôop√©rateur &lt;&lt; ins√®re une repr√©sentation textuelle d‚Äôune valeur dans un flux de sortie (std::ostream, std::ofstream, std::stringstream, etc.).\nIl n‚Äôajoute aucun espace ni retour √† la ligne automatique : c‚Äôest au programmeur de les ins√©rer si n√©cessaire.\nL‚Äôinsertion est s√©quentielle et continue : tout ce qui est envoy√© est √©crit tel quel dans le flux.\n\nCet op√©rateur est surcharg√© pour les types standards (int, std::string, etc.), et peut l‚Äô√™tre pour des classes personnalis√©es.\n\nLecture depuis un flux (&gt;&gt;)\nL‚Äôop√©rateur &gt;&gt; extrait des donn√©es d‚Äôun flux d‚Äôentr√©e (std::istream, std::ifstream, std::istringstream, etc.) vers une variable.\nIl ignore les caract√®res blancs (whitespace) en d√©but de flux, puis lit jusqu‚Äôau prochain caract√®re blanc (espace, tabulation, saut de ligne).\nLa lecture s‚Äôinterrompt d√®s qu‚Äôun s√©parateur est rencontr√©.\n\nPour lire une ligne compl√®te, il faut utiliser std::getline(), car &gt;&gt; ne lit qu‚Äôun mot √† la fois.\n\n\nExemple simple\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::ofstream fichier(&quot;donnees.txt&quot;);\n    fichier &lt;&lt; &quot;Nom: Alice\\n&quot;;\n    fichier.close();\n \n    std::ifstream lecture(&quot;donnees.txt&quot;);\n    std::string ligne;\n    while (std::getline(lecture, ligne)) {\n        std::cout &lt;&lt; ligne &lt;&lt; std::endl;\n    }\n}\n\nPositionnement du curseur\nLes objets std::ifstream, std::ofstream et std::fstream permettent de manipuler le curseur de lecture ou d‚Äô√©criture dans un fichier, gr√¢ce aux m√©thodes suivantes :\n\nseekg(pos) : d√©place le curseur de lecture (g pour get) √† la position pos\nseekp(pos) : d√©place le curseur d‚Äô√©criture (p pour put) √† la position pos\ntellg() : retourne la position actuelle du curseur de lecture\ntellp() : retourne la position actuelle du curseur d‚Äô√©criture\n\nOn peut aussi utiliser des d√©placements relatifs :\nflux.seekg(offset, std::ios::beg);  // depuis le d√©but\nflux.seekg(offset, std::ios::cur);  // depuis la position actuelle\nflux.seekg(offset, std::ios::end);  // depuis la fin du fichier\n\nCes fonctions sont utiles pour obtenir la taille d‚Äôun fichier, revenir au d√©but, sauter des blocs de donn√©es, etc.\n\n√Ä propos de offset et des points d‚Äôancrage\nLes m√©thodes seekg() et seekp() acceptent un d√©calage (offset) exprim√© en caract√®res (ou octets), ainsi qu‚Äôun point de d√©part (appel√© ancrage) :\n\noffset : entier indiquant le nombre de caract√®res √† d√©placer\nstd::ios::beg : depuis le d√©but du fichier\nstd::ios::cur : depuis la position actuelle\nstd::ios::end : depuis la fin du fichier\n\nExemples :\nfichier.seekg(0, std::ios::beg);    // aller au d√©but\nfichier.seekg(5, std::ios::cur);    // avancer de 5 caract√®res\nfichier.seekg(-10, std::ios::end);  // reculer de 10 caract√®res depuis la fin\n\nCes manipulations sont utiles pour sauter des donn√©es, relire une section, ou calculer la taille totale du fichier.\n\n√Ä propos de std::ios::beg, cur, end\nLes constantes std::ios::beg, std::ios::cur et std::ios::end sont des valeurs d‚Äô√©num√©ration appartenant √† std::ios_base::seekdir.\nElles indiquent le point d‚Äôorigine (ancrage) √† partir duquel appliquer un d√©calage (offset) lors d‚Äôun repositionnement de curseur avec seekg() ou seekp() :\n\nstd::ios::beg ‚Üí depuis le d√©but du fichier\nstd::ios::cur ‚Üí depuis la position actuelle\nstd::ios::end ‚Üí depuis la fin du fichier\n\n\nCes constantes sont d√©finies dans la biblioth√®que &lt;ios&gt; (incluses automatiquement avec &lt;fstream&gt; ou &lt;iostream&gt;).\n\n\nPr√©cautions √† prendre avec les flux de fichier\n1. Toujours v√©rifier que le fichier a bien √©t√© ouvert\nAvant toute lecture ou √©criture, il est essentiel de s‚Äôassurer que l‚Äôouverture a r√©ussi :\nstd::ifstream fichier(&quot;data.txt&quot;);\nif (!fichier.is_open()) {\n\tstd::cerr &lt;&lt; &quot;Erreur : impossible d‚Äôouvrir le fichier.&quot; &lt;&lt; std::endl;\n\treturn 1;\n}\n \n// ou bien\n \nstd::ifstream fichier(&quot;data.txt&quot;);\nif (!fichier)) {\n\tstd::cerr &lt;&lt; &quot;Erreur : impossible d‚Äôouvrir le fichier.&quot; &lt;&lt; std::endl;\n\treturn 1;\n}\n \n\nM√™me chose avec std::ofstream ou std::fstream.\n\n2. V√©rifier que le fichier n‚Äôest pas un dossier\nfstream ne permet pas directement de v√©rifier si le chemin est un r√©pertoire.\nPour ce faire, il faut utiliser la biblioth√®que &lt;sys/stat.h&gt; (POSIX) ou &lt;filesystem&gt; (C++17) :\nEn C++98/POSIX :\n#include &lt;sys/stat.h&gt;\n \nstruct stat s;\nif (stat(&quot;nom&quot;, &amp;s) == 0 &amp;&amp; S_ISDIR(s.st_mode)) {\n\tstd::cerr &lt;&lt; &quot;Erreur : c‚Äôest un dossier, pas un fichier.&quot; &lt;&lt; std::endl;\n}\n3. Prendre en compte les permissions du fichier\nSi le fichier est en lecture seule, un std::ofstream √©chouera √† l‚Äôouverture.\nstd::ofstream out(&quot;protected.txt&quot;);\nif (!out) {\n\tstd::cerr &lt;&lt; &quot;Erreur : impossible d‚Äô√©crire dans le fichier (permissions ?)&quot; &lt;&lt; std::endl;\n}\n4. Penser √† fermer explicitement (close())\nM√™me si le destructeur le fait automatiquement √† la fin du bloc, il est bon usage de fermer manuellement si :\n\non rouvre le fichier ensuite\non veux s‚Äôassurer que les donn√©es sont bien √©crites imm√©diatement\n\nfichier.close();\n5. Toujours tester l‚Äô√©tat du flux apr√®s lecture\nSi une lecture √©choue (fichier corrompu, fin de fichier‚Ä¶), il faut le d√©tecter, avec la m√©thode fail() :\nint x;\nfichier &gt;&gt; x;\nif (fichier.fail()) {\n\tstd::cerr &lt;&lt; &quot;Erreur de lecture (mauvais type, fin pr√©matur√©e...)&quot; &lt;&lt; std::endl;\n}\n\nRemarques\n\nIl est possible de tester si un fichier est ouvert avec is_open().\nToujours appeler close() √† la fin pour lib√©rer les ressources (ou laisser le destructeur le faire).\nPar d√©faut, les fichiers sont trait√©s en mode texte (les fins de ligne peuvent √™tre interpr√©t√©es selon le syst√®me d‚Äôexploitation).\nfstream est compatible avec les manipulateur de flux comme std::setw, std::setprecision, etc.\n"},"biblioth√®que-iostream":{"slug":"biblioth√®que-iostream","filePath":"biblioth√®que iostream.md","title":"biblioth√®que iostream","links":["biblioth√®que-standard-C++","flux","espace-de-noms","surcharg√©","classe","surcharge-d'op√©rateur","objet"],"tags":[],"content":"\nBiblioth√®que standard: `\n\n\nLa biblioth√®que iostream est une composante fondamentale de la biblioth√®que standard C++ .\nElle fournit les flux standards d‚Äôentr√©e et de sortie (std::cin, std::cout, etc.), permettant d‚Äôinteragir avec l‚Äôutilisateur ou le syst√®me via des op√©rations de lecture/√©criture textuelle.\n\n\nInclusion n√©cessaire\nPour acc√©der aux flux standards :\n#include &lt;iostream&gt;\nCela rend accessibles les objets suivants : std::cin, std::cout, std::cerr, std::clog, ainsi que les classes std::istream, std::ostream et les op√©rateurs &lt;&lt; et &gt;&gt;.\n\nEspace de nom\nLes flux cin, cout, etc., sont d√©finis dans l‚Äôespace de nom std.\nIl faut les utiliser en les pr√©fixant :\n‚Üí std::cout, std::cin, etc\nOu importer l‚Äôespace de noms:\n‚Üí using namespace std\n‚ö†Ô∏è L‚Äôimport de using namespace std; est d√©conseill√© dans les headers et les grands projets √† cause des risques de conflits.\n\nPrincipaux flux fournis\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNomTypeDescriptionstd::cinstd::istreamEntr√©e standard (lecture depuis le clavier)std::coutstd::ostreamSortie standard (affichage √† l‚Äô√©cran)std::cerrstd::ostreamSortie d‚Äôerreur non tamponn√©e (affichage imm√©diat)std::clogstd::ostreamSortie d‚Äôerreur tamponn√©e (utilis√©e pour les logs)\n\nUtilisation des op√©rateurs &lt;&lt; et &gt;&gt;\n\n&lt;&lt; pour insertion dans une cha√Æne (comme std::cout)\n&gt;&gt; pour extraction depuis une cha√Æne (comme std::cin)\n\n\nTr√®s utile pour formater des cha√Ænes, convertir des nombres, ou parser du texte ligne par ligne.\n\nInsertion dans un flux (&lt;&lt;)\nL‚Äôop√©rateur &lt;&lt; ins√®re une repr√©sentation textuelle d‚Äôune valeur dans un flux de sortie (std::ostream, std::ofstream, std::stringstream, etc.).\nIl n‚Äôajoute aucun espace ni retour √† la ligne automatique : c‚Äôest au programmeur de les ins√©rer si n√©cessaire.\nL‚Äôinsertion est s√©quentielle et continue : tout ce qui est envoy√© est √©crit tel quel dans le flux.\n\nCet op√©rateur est surcharg√© pour les types standards (int, std::string, etc.), et peut l‚Äô√™tre pour des classes personnalis√©es.\n\nLecture depuis un flux (&gt;&gt;)\nL‚Äôop√©rateur &gt;&gt; extrait des donn√©es d‚Äôun flux d‚Äôentr√©e (std::istream, std::ifstream, std::istringstream, etc.) vers une variable.\nIl ignore les caract√®res blancs (whitespace) en d√©but de flux, puis lit jusqu‚Äôau prochain caract√®re blanc (espace, tabulation, saut de ligne).\nLa lecture s‚Äôinterrompt d√®s qu‚Äôun s√©parateur est rencontr√©.\n\nPour lire une ligne compl√®te, il faut utiliser std::getline(), car &gt;&gt; ne lit qu‚Äôun mot √† la fois.\n\n\nExemple simple\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::string nom;\n    int age;\n \n    std::cout &lt;&lt; &quot;Nom : &quot;;\n    std::cin &gt;&gt; nom;\n \n    std::cout &lt;&lt; &quot;√Çge : &quot;;\n    std::cin &gt;&gt; age;\n \n    std::clog &lt;&lt; &quot;Utilisateur connect√©\\n&quot;;\n    std::cerr &lt;&lt; &quot;Aucune erreur d√©tect√©e\\n&quot;;\n}\n\nRemarques\n\nLes flux de iostream sont tamponn√©s (sauf std::cerr), ce qui am√©liore les performances mais peut retarder l‚Äôaffichage.\nIls sont automatiquement ouverts √† l‚Äôex√©cution du programme.\niostream est extensible : vous pouvez faire de la surcharge d‚Äôop√©rateur&lt;&lt; et &gt;&gt; pour vos propres objets.\n"},"biblioth√®que-numeric":{"slug":"biblioth√®que-numeric","filePath":"biblioth√®que numeric.md","title":"biblioth√®que numeric","links":["biblioth√®que","STL","C++","vecteur","liste","conteneur","it√©rateur","biblioth√®que-algorithm","foncteur"],"tags":[],"content":"\nBiblioth√®que standard: &lt;numeric&gt;\n\n\nLa biblioth√®que &lt;numeric&gt; fait partie de la STL en C++.\nElle fournit des algorithmes num√©riques g√©n√©riques, principalement destin√©s √† travailler sur des s√©quences de type vecteur vector, liste list, ou tout conteneur d‚Äô√©l√©ments num√©riques via des it√©rateurs.\nElle compl√®te la biblioth√®que algorithm]], mais n‚Äôen fait pas partie : &lt;numeric&gt; est un en-t√™te distinct, centr√© sur les accumulations, produits, sommes partielles, etc.\n\n\nInclude\nPour utiliser &lt;numeric&gt; :\n#include &lt;numeric&gt;\n\nFonctionnement\nLes fonctions de &lt;numeric&gt; sont g√©n√©riques et travaillent uniquement sur des intervalles d‚Äôit√©rateurs.\nElles permettent d‚Äôappliquer rapidement des op√©rations math√©matiques de type accumulation, somme partielle ou transformation.\n\nElles sont souvent utilis√©es en combinaison avec des foncteurs ou des fonctions personnalis√©es.\n\n\nPrincipales fonctions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionaccumulateFait une somme ou accumulationinner_productProduit scalaireadjacent_differenceDiff√©rences successivespartial_sumSomme cumulative\n‚Üí Pour plus de d√©tail voir le bas de la page\n\nExemples\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::vector&lt;int&gt; v = {1, 2, 3, 4};\n \n    int sum = std::accumulate(v.begin(), v.end(), 0); // 10\n \n    int product = std::inner_product(v.begin(), v.end(), v.begin(), 0); // 1¬≤ + 2¬≤ + 3¬≤ + 4¬≤ = 30\n \n    std::vector&lt;int&gt; partial(v.size());\n    std::partial_sum(v.begin(), v.end(), partial.begin()); // {1, 3, 6, 10}\n \n    std::vector&lt;int&gt; diffs(v.size());\n    std::adjacent_difference(v.begin(), v.end(), diffs.begin()); // {1, 1, 1, 1}\n \n    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; &quot;, Product: &quot; &lt;&lt; product &lt;&lt; std::endl;\n}\n\nRemarques importantes\n\n&lt;numeric&gt; est distinct de &lt;algorithm&gt;, bien qu‚Äôils partagent une logique bas√©e sur les it√©rateurs.\nToutes les fonctions de &lt;numeric&gt; sont non destructrices : elles produisent leurs r√©sultats sans modifier la s√©quence source.\nstd::accumulate est souvent utilis√© pour des sommations ou produits simples, mais devient extr√™mement puissant avec une fonction personnalis√©e (comme une concat√©nation, une combinaison logique, etc.).\nCes fonctions sont particuli√®rement utiles dans les cas de traitement de donn√©es num√©riques, calculs statistiques, ou algorithmes personnalis√©s.\n\n\nFonctions avec retour et param√®tres\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionRetourParam√®tres principauxDescriptionstd::accumulateT(InputIt first, InputIt last, T init) (..., BinaryOp op)Calcule une somme ou une accumulation personnalis√©e sur une s√©quence.std::inner_productT(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init) (..., BinaryOp1, BinaryOp2)Calcule le produit scalaire ou une accumulation crois√©e personnalis√©e.std::partial_sumOutputIt(InputIt first, InputIt last, OutputIt dest) (..., BinaryOp op)√âcrit les sommes cumul√©es successives dans dest.std::adjacent_differenceOutputIt(InputIt first, InputIt last, OutputIt dest) (..., BinaryOp op)√âcrit dans dest les diff√©rences entre √©l√©ments cons√©cutifs."},"biblioth√®que-sstream":{"slug":"biblioth√®que-sstream","filePath":"biblioth√®que sstream.md","title":"biblioth√®que sstream","links":["biblioth√®que","biblioth√®que-standard-C++","flux","objet","classe","m√©thode","espace-de-noms","biblioth√®que-iostream","surcharg√©","manipulateur-de-flux"],"tags":[],"content":"\nBiblioth√®que standard: &lt;sstream&gt;\n\n\nLa biblioth√®que sstream fait partie de la biblioth√®que standard C++.\nElle permet de manipuler des flux en m√©moire, gr√¢ce √† des cha√Ænes de caract√®res. Cela permet d‚Äôutiliser les op√©rateurs &lt;&lt; et &gt;&gt; comme avec cin et cout, mais en lisant ou √©crivant dans une std::string.\n\n\nInclusion n√©cessaire\nPour utiliser les flux de cha√Ænes :\n#include &lt;sstream&gt;\nCela rend accessibles les objets et classes suivantes :\n\nstd::stringstream : flux bidirectionnel (lecture/√©criture)\nstd::istringstream : flux en lecture uniquement\nstd::ostringstream : flux en √©criture uniquement\n\nainsi que les m√©thodes associ√©es comme str(), clear(), seekg(), etc.\n\nEspace de nom\nComme les autres biblioth√®ques de la biblioth√®que standard C++, sstream appartient √† l‚Äôespace de nom std.\nIl faut donc √©crire :\n‚Üí std::stringstream, std::ostringstream, etc.\nOu importer l‚Äôespace de noms :\n‚Üí using namespace std\n\n‚ö†Ô∏è L‚Äôimport de using namespace std; reste d√©conseill√© dans les fichiers d‚Äôen-t√™te.\n\n\nPrincipaux flux de cha√Ænes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNomTypeDescriptionstd::istringstreamstd::istreamLecture depuis une cha√Ænestd::ostringstreamstd::ostream√âcriture vers une cha√Ænestd::stringstreamstd::iostreamLecture et √©criture dans une m√™me cha√Æne de texte\n\nCes classes h√©ritent des classes de la biblioth√®que iostream et peuvent √™tre utilis√©es de la m√™me mani√®re que cin ou cout.\n\n\nUtilisation des op√©rateurs &lt;&lt; et &gt;&gt;\n\n&lt;&lt; pour insertion dans une cha√Æne (comme std::cout)\n&gt;&gt; pour extraction depuis une cha√Æne (comme std::cin)\n\n\nTr√®s utile pour formater des cha√Ænes, convertir des nombres, ou parser du texte ligne par ligne.\n\nInsertion dans un flux (&lt;&lt;)\nL‚Äôop√©rateur &lt;&lt; ins√®re une repr√©sentation textuelle d‚Äôune valeur dans un flux de sortie (std::ostream, std::ofstream, std::stringstream, etc.).\nIl n‚Äôajoute aucun espace ni retour √† la ligne automatique : c‚Äôest au programmeur de les ins√©rer si n√©cessaire.\nL‚Äôinsertion est s√©quentielle et continue : tout ce qui est envoy√© est √©crit tel quel dans le flux.\n\nCet op√©rateur est surcharg√© pour les types standards (int, std::string, etc.), et peut l‚Äô√™tre pour des classes personnalis√©es.\n\nLecture depuis un flux (&gt;&gt;)\nL‚Äôop√©rateur &gt;&gt; extrait des donn√©es d‚Äôun flux d‚Äôentr√©e (std::istream, std::ifstream, std::istringstream, etc.) vers une variable.\nIl ignore les caract√®res blancs (whitespace) en d√©but de flux, puis lit jusqu‚Äôau prochain caract√®re blanc (espace, tabulation, saut de ligne).\nLa lecture s‚Äôinterrompt d√®s qu‚Äôun s√©parateur est rencontr√©.\n\nPour lire une ligne compl√®te, il faut utiliser std::getline(), car &gt;&gt; ne lit qu‚Äôun mot √† la fois.\n\n\nExemple simple\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::stringstream ss;\n    ss &lt;&lt; &quot;42 3.14 Hello&quot;;\n \n    int a;\n    float b;\n    std::string c;\n \n    ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    std::cout &lt;&lt; &quot;int = &quot; &lt;&lt; a &lt;&lt; &quot;, float = &quot; &lt;&lt; b &lt;&lt; &quot;, string = &quot; &lt;&lt; c &lt;&lt; std::endl;\n}\n\nPr√©cautions √† prendre\n\nToujours v√©rifier l‚Äô√©tat du flux (fail(), eof()) apr√®s extraction.\nUtiliser clear() si on r√©utilise un m√™me stringstream pour une autre op√©ration.\nUtiliser str() pour r√©cup√©rer ou d√©finir le contenu de la cha√Æne associ√©e.\n\nstd::ostringstream out;\nout &lt;&lt; 123;\nstd::string result = out.str(); // r√©cup√®re la cha√Æne &quot;123&quot;\n\nRemarques\n\nTr√®s utile pour formater des cha√Ænes sans utiliser sprintf.\nUtile aussi pour convertir une string en int ou float de mani√®re s√ªre :\n\nstd::istringstream(&quot;42&quot;) &gt;&gt; myInt;\n\nCompatible avec les manipulateur de flux (std::setw, std::fixed, etc.)\n"},"biblioth√®que-standard-C++":{"slug":"biblioth√®que-standard-C++","filePath":"biblioth√®que standard C++.md","title":"biblioth√®que standard C++","links":["fonction","classe","type","C++","flux","espace-de-noms","STL","string"],"tags":[],"content":"\nNom anglais: C++ Standard Library\n\n\nLa biblioth√®que standard C++ est un ensemble d‚Äôoutils fournis avec le langage C++, regroupant des fonctions, des classes, des types et des structures utiles pour le d√©veloppement.\nComparaison C/C++ : Le C a une biblioth√®que standard plus limit√©e. En C++ la biblioth√®que standard est plus riche, orient√©e objet, et largement template-based (bas√© sur des mod√®les g√©n√©riques).\n\nContenu de la biblioth√®que standard\nElle contient notamment :\n\nLes flux d‚Äôentr√©e/sortie : std::cout, std::cin, std::cerr (&lt;iostream&gt;)\nLes cha√Ænes de caract√®res : std::string (&lt;string&gt;)\nLes conteneurs g√©n√©riques : std::vector, std::map, std::set, etc. (&lt;vector&gt;, &lt;map&gt;, etc.)\nLes algorithmes : std::sort, std::find, std::count‚Ä¶ (&lt;algorithm&gt;)\nLes outils math√©matiques : std::pow, std::sqrt, etc. (&lt;cmath&gt;)\nLes types utilitaires : std::pair, std::tuple, std::optional‚Ä¶\nLes fonctions de gestion de caract√®res : std::toupper, std::tolower, etc. (&lt;cctype&gt;)\nLes fonctions de temps / date : std::chrono, std::time\n\nNamespace de la biblioth√®que standard\n\nEn C++, tous les √©l√©ments de la biblioth√®que standard sont d√©finis dans l‚Äôespace de noms std (abr√©viation de standard). C‚Äôest une r√®gle syst√©matique.\n\nTous les composants standards comme :\n\ncout, cin, cerr\nstring, vector, map, set, pair\nsort, find, sqrt, toupper, endl\netc.\n\n‚Ä¶ sont dans l‚Äôespace de noms std.\nIl faut donc les appeler comme ceci :\nstd::cout &lt;&lt; &quot;Bonjour&quot;;\nstd::vector&lt;int&gt; liste;\nstd::sort(...);\nOu bien utiliser :\nusing namespace std;\nUtilisation\nPour utiliser un composant de la biblioth√®que standard :\n\nInclure l‚Äôen-t√™te correspondant (ex. #include &lt;vector&gt;)\nPour l‚Äôespace de noms utiliser l‚Äô√©l√©ment avec le pr√©fixe std::, ou bien √©crire using namespace std;\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main()\n{\n    std::string nom = &quot;Alice&quot;;\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n    return 0;\n}\nSTL (Standard Template Library)\nLa STL est une partie sp√©cifique de la biblioth√®que standard, regroupant :\n\ndes conteneurs g√©n√©riques (ex : std::vector)\ndes it√©rateurs\ndes algorithmes (ex : std::sort)\ndes foncteurs / lambdas\n\nElle repose fortement sur les templates, pour permettre une r√©utilisabilit√© maximale du code.\nFiches associees\n\nstring\n\n\nR√©sum√©\n\nüìå La biblioth√®que standard C++ fournit des outils essentiels pr√™ts √† l‚Äôemploi, couvrant les besoins courants (affichage, traitement de texte, calculs, conteneurs, algorithmes‚Ä¶).\nElle est organis√©e par modules, accessibles via les #include et l‚Äôespace de noms (namespace) std.\n"},"biblioth√®que-standard":{"slug":"biblioth√®que-standard","filePath":"biblioth√®que standard.md","title":"biblioth√®que standard","links":["C++","compilateur"],"tags":[],"content":"Qu‚Äôest-ce qu‚Äôune biblioth√®que standard?\n\nUne biblioth√®que standard en C++ est l‚Äôensemble officiel de fonctionnalit√©s (fonctions, classes, algorithmes, structures de donn√©es) fourni directement avec le langage.\nElle est norm√©e, universelle, disponible par d√©faut avec tout compilateur C++, et permet de r√©aliser plein de t√¢ches courantes sans devoir r√©inventer la roue.\n\nEn r√©sum√©\n\nC‚Äôest inclus automatiquement avec C++.\nOn y trouve tout ce qui est de base : affichage, calculs, structures de donn√©es, algorithmes, gestion de fichiers, etc.\nElle est g√©r√©e par le standard du C++ (ISO C++ Standard).\n\nExemples de composants de la biblioth√®que standard\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModuleFonctionnalit√© principaleiostreamEntr√©es/sorties (std::cout, std::cin)vectorTableaux dynamiquesstringGestion des cha√Ænes de caract√®resmapTableaux associatifs (cl√©/valeur)algorithmFonctions pr√™tes √† l‚Äôemploi (tri, recherche, etc.)memoryGestion fine de la m√©moire dynamiquechronoGestion du temps et des dur√©es\nüîé Pourquoi utiliser la biblioth√®que standard ?\n\nGain de temps √©norme : pas besoin de recoder les fonctions basiques.\nS√©curit√© : elle est largement test√©e et fiable.\nPortabilit√© : ton code fonctionne de la m√™me mani√®re sur tous les syst√®mes.\n\nImportant\n\nPour utiliser une fonctionnalit√©, il faut g√©n√©ralement :\n\nInclure le header correspondant (ex: #include &lt;vector&gt;)\nUtiliser l‚Äôespace de noms std:: (ex: std::vector&lt;int&gt;).\n\n\n\nR√©sum√© ultra rapide\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCe que c‚ÄôestPourquoi c‚Äôest utileEnsemble d‚Äôoutils de base du C++Tu n‚Äôas pas besoin de tout r√©√©crireLivr√© avec ton compilateurAccessible imm√©diatementNorm√©M√™me comportement partout"},"biblioth√®que":{"slug":"biblioth√®que","filePath":"biblioth√®que.md","title":"biblioth√®que","links":["fonction","classe","C++","biblioth√®que-standard-C++","biblioth√®que-sstream","biblioth√®que-fstream","biblioth√®que-numeric","biblioth√®que-algorithm"],"tags":[],"content":"\nNom anglais: library\n\n\nUne biblioth√®que est un ensemble de fonctions, de classes ou d‚Äôoutils regroup√©s dans un fichier s√©par√©, que l‚Äôon peut r√©utiliser dans plusieurs programmes.\nElle permet d‚Äôorganiser et de partager du code sans le r√©√©crire √† chaque fois.\nComparaison C/C++ : En C et en C++, les biblioth√®ques sont tr√®s utilis√©es, via les fichiers d‚Äôen-t√™te (.h, .hpp) et les fichiers compil√©s (.a, .so, .lib, .dll, etc.).\n\n\nTypes de biblioth√®ques\n\nBiblioth√®que standard : livr√©e avec le langage (ex : std::cout, std::string, std::vector, etc.) - voir biblioth√®que standard C++\nBiblioth√®que externe : cr√©√©e par des tiers (ex : SFML, Boost, Qt‚Ä¶)\nBiblioth√®que personnelle : √©crite par le d√©veloppeur pour organiser son propre projet\n\n‚Üí Voir la fiche d√©di√©e : biblioth√®que standard C++\n\nUtilisation\nPour utiliser une biblioth√®que :\n\nOn inclut un fichier d‚Äôen-t√™te (ex: #include &lt;iostream&gt;)\nOn compile en liant le fichier binaire correspondant (automatique pour la biblioth√®que standard)\n\n\nExemple\n#include &lt;cmath&gt; // biblioth√®que standard math√©matique\n \ndouble racine = std::sqrt(9.0);\n\nVoir aussi\n‚Üí biblioth√®que standard C++, biblioth√®que sstream\n‚Üí biblioth√®que fstream, biblioth√®que numeric, biblioth√®que algorithm"},"bloc":{"slug":"bloc","filePath":"bloc.md","title":"bloc","links":["variable","objet","fonction","dur√©e-de-vie-des-objets"],"tags":[],"content":"\nNom anglais: block\n\n\nUn bloc est une portion de code d√©limit√©e par des accolades {}, qui d√©finit une port√©e locale (scope).  Les variables et objets d√©clar√©es √† l‚Äôint√©rieur du bloc n‚Äôexistent que pendant son ex√©cution.\nComparaison C/C++ : cette notion est identique dans les deux langages.\n\n\nExemple\nLe code situ√© entre les accolades constitue un bloc.\n{\n    int x = 42;\n}\n\nUtilisations courantes\n\nCorps de fonction\nBoucles (for, while)\nConditions (if, else)\nD√©limitation volontaire de port√©e temporaire\n\n\nDur√©e de vie dans un bloc\nUn bloc {} cr√©e une port√©e locale, dans laquelle on peut d√©clarer des variables qui seront automatiquement d√©truites √† sa fermeture.\n‚Üí Voir la fiche d√©di√©e : dur√©e de vie des objets\n\nVoir aussi\n‚Üí variable, objet, dur√©e de vie des objets"},"cache":{"slug":"cache","filePath":"cache.md","title":"cache","links":["C++","vecteur","liste"],"tags":[],"content":"\nNom anglais: cache (CPU cache)\n\n\nLe cache est une m√©moire rapide situ√©e √† l‚Äôint√©rieur ou au plus proche du processeur (CPU).\nSon r√¥le est de stocker temporairement les donn√©es et instructions les plus r√©cemment utilis√©es ou les plus souvent demand√©es, afin d‚Äôacc√©l√©rer leur acc√®s.\n\n\nOrganisation hi√©rarchique\nLe cache est g√©n√©ralement organis√© en plusieurs niveaux, chacun √©tant plus grand mais plus lent que le pr√©c√©dent :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNiveauNomTaille typiqueVitesseLocalisationL1Cache L116 √† 128 KoTr√®s rapidedans chaque c≈ìurL2Cache L2256 Ko √† 1 MoRapidedans chaque c≈ìurL3Cache L32 √† 64 MoMoins rapidepartag√© entre c≈ìursRAMM√©moire principalePlusieurs GoBeaucoup plus lenthors CPU (sur la carte m√®re)\n\nFonctionnement\nLorsqu‚Äôun programme acc√®de √† une donn√©e :\n\nLe CPU cherche d‚Äôabord dans le cache (L1 ‚Üí L2 ‚Üí L3).\nSi la donn√©e est pr√©sente (cache hit), elle est utilis√©e imm√©diatement.\nSinon (cache miss), elle est charg√©e depuis la RAM (beaucoup plus lent).\n\nLe cache fonctionne souvent par blocs contigus (appel√©s lignes de cache), ce qui favorise les acc√®s s√©quentiels.\n\nImportance en C++\nLe comportement d‚Äôun programme C++peut √™tre grandement influenc√© par le cache :\n\nles vecteurs std::vector utilise de la m√©moire contigu√´, ce qui favorise les acc√®s s√©quentiels efficaces (cache-friendly).\nles listes std::list utilise des pointeurs dispers√©s en m√©moire, ce qui entra√Æne de nombreux cache misses (moins performant).\nUn parcours lin√©aire sur un tableau est souvent beaucoup plus rapide qu‚Äôun acc√®s al√©atoire sur une liste, m√™me si la complexit√© algorithmique est √©quivalente.\n\n\nExemple\nint arr[100000];\nfor (int i = 0; i &lt; 100000; ++i)\n    arr[i] += 1;\nCe code b√©n√©ficie du cache car les √©l√©ments sont lus de mani√®re contigu√´. Le CPU charge plusieurs √©l√©ments √† la fois gr√¢ce aux lignes de cache.\nEn revanche, avec des acc√®s al√©atoires ou des listes cha√Æn√©es, le cache est beaucoup moins efficace."},"cast":{"slug":"cast","filePath":"cast.md","title":"cast","links":["C++98","C++","compilation","pointeur","classe","RTTI","polymorphisme","compilateur","r√©f√©rence","classe-d√©riv√©e","exception","m√©thode","classe-de-base","objet","m√©thode-virtuelle","h√©ritage","encapsulation"],"tags":[],"content":"\nNom anglais : type casting\n\n\nEn C++98, le cast permet de convertir une expression d‚Äôun type vers un autre.\nLe langage h√©rite de la syntaxe (Type) du C, mais introduit quatre op√©rateurs sp√©cifiques :\nstatic_cast, dynamic_cast, reinterpret_cast, const_cast\nIls sont plus s√©curis√©s, lisibles et adapt√©s aux intentions.\nComparaison C/C++ : En C, tous les casts passent par une conversion brute non v√©rifi√©e (Type), ce qui peut masquer des erreurs. En C++, les casts sont explicites, typ√©s, et souvent v√©rifi√©s √† la compilation ou √† l‚Äôex√©cution selon le type de cast.\n\n\nPourquoi caster en C++\n\nPour convertir une valeur d‚Äôun type vers un autre\nPour interpr√©ter ou manipuler un pointeur dans une hi√©rarchie de classes\nPour supprimer un const de mani√®re contr√¥l√©e\nPour faire une conversion polymorphe s√©curis√©e gr√¢ce au RTTI (voir polymorphisme)\n\n\nLe cast en style C\nfloat f = 3.14f;\nint i = (int)f;\n\nSimple et rapide, mais :\nDangereux, car il bypasse toutes les v√©rifications\nAmbigu : le compilateur ne peut pas distinguer l‚Äôintention r√©elle du programmeur.\n\nC‚Äôest pourquoi le C++ introduit 4 formes de cast sp√©cialis√©es.\n\nstatic_cast\n\nConversion explicite, v√©rifi√©e √† la compilation.\n\nSert √† effectuer des conversions s√ªres : entre types num√©riques compatibles, entre types d‚Äôune m√™me hi√©rarchie sans RTTI, ou entre pointeurs vers types compatibles.\nint i = static_cast&lt;int&gt;(3.14);           // OK\nBase* b = static_cast&lt;Base*&gt;(derivedPtr); // OK si d√©riv√©e de Base\n\nV√©rifications √† la compilation\nPas de v√©rification √† l‚Äôex√©cution ‚Üí attention aux conversions incorrectes\n\n\nUtilisation : pr√©f√©r√©e pour la majorit√© des conversions non polymorphes (valeurs simples, h√©ritage connu).\n\n\nreinterpret_cast\n\nConversion bas niveau, non v√©rifi√©e.\n\nPermet d‚Äôinterpr√©ter les bits d‚Äôun pointeur ou d‚Äôun type comme un autre type totalement incompatible.\nint* p = reinterpret_cast&lt;int*&gt;(0xDEADBEEF); // cast d‚Äôadresse brut\n\nPuissant\nTr√®s risqu√© ‚Üí peut casser le programme ou provoquer un comportement ind√©fini\n\n\nUtilisation : r√©serv√© √† des cas tr√®s particuliers (interop√©rabilit√© bas niveau, I/O m√©moire brute, etc.)\n\n\nconst_cast\n\nAjoute ou retire un const ou volatile.\n\nPermet de supprimer le const pour appeler une fonction non-const ou modifier temporairement une valeur\nconst int* p = &amp;x;\nint* q = const_cast&lt;int*&gt;(p);\n\nUtilis√© pour r√©tablir la mutabilit√©\nNe jamais l‚Äôutiliser sur un objet qui a √©t√© d√©clar√© const, sous peine de comportement ind√©fini\n\n\nUtilisation : manipulation contr√¥l√©e, souvent en interne (appel d‚ÄôAPI non const, etc.)\n\n\ndynamic_cast\n\nConversion descendante (downcast) s√©curis√©e gr√¢ce au RTTI.\n\nPermet de convertir un pointeur ou une r√©f√©rence vers une classe d√©riv√©e dans une hi√©rarchie polymorphe.\nBase* b = new Derived();\nDerived* d = dynamic_cast&lt;Derived*&gt;(b);\n \nif (d) d-&gt;fonctionSpecifique(); // OK si le cast a r√©ussi\n\nV√©rifie dynamiquement si le cast est valide\nRetourne nullptr (ou l√®ve une exception  std::bad_cast en cas de r√©f√©rence) si la conversion √©choue\n\n\nUtilisation : n√©cessaire uniquement avec le polymorphisme (au moins une m√©thode virtual dans la classe de base).\n\n\nQu‚Äôest-ce que le RTTI ?\n\nRTTI : Run-Time Type Information (informations de type √† l‚Äôex√©cution)\n\nRTTI est un m√©canisme du C++ qui permet de conna√Ætre le type r√©el d‚Äôun objet √† l‚Äôex√©cution.\nIl est n√©cessaire pour dynamic_cast et typeid. Il s‚Äôappuie sur la table virtuelle (vtable) g√©n√©r√©e pour les classes contenant au moins une m√©thode virtuelle.\n\nSi le RTTI est d√©sactiv√© (-fno-rtti), dynamic_cast et typeid ne sont plus disponibles.\n\n\nComparaison\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCastUsage principalV√©rificationDanger principalstatic_castConversion simple entre types compatiblesCompilationerreurs silencieusesreinterpret_castConversion brute (pointeurs, donn√©es)AucuneUB, non portableconst_castAjout/retrait de constCompilationmodifier un vrai objet constdynamic_castCast polymorphe (h√©ritage)Ex√©cutionn√©cessite RTTI, sinon nullptr\n\nVoir aussi\n‚Üí pointeur, r√©f√©rence\n‚Üí classe, h√©ritage, m√©thode virtuelle, encapsulation"},"cin":{"slug":"cin","filePath":"cin.md","title":"cin","links":["Nom-pleinement-qualifi√©","biblioth√®que-standard-C++","biblioth√®que-iostream","espace-de-noms","flux","C++","objet","op√©rateur","surcharg√©"],"tags":[],"content":"\nNom pleinement qualifi√©: std::cin\n\n\nstd::cin est un objet de la biblioth√®que standard C++ qui permet de lire des donn√©es depuis l‚Äôentr√©e standard (g√©n√©ralement le clavier).\nIl fait partie de la biblioth√®que iostream et appartient √† l‚Äôespace de noms std.\nOn l‚Äôutilise avec l‚Äôop√©rateur &gt;&gt; (appel√© op√©rateur d‚Äôextraction) pour extraire des valeurs tap√©es par l‚Äôutilisateur dans le flux d‚Äôentr√©e standard.\nComparaison C/C++ : En C, on utilise scanf() ou fgets(). En C++, on utilise std::cin, un objet de type std::istream, avec l‚Äôop√©rateur &gt;&gt;.\n\nFonctionnement de base\nstd::cin &gt;&gt; nom;\n\nCela attend une saisie clavier et stocke la valeur dans la variable nom.\nL‚Äôop√©rateur &gt;&gt; signifie ici ‚Äúextrait depuis le flux d‚Äôentr√©e‚Äù.\n\nLire plusieurs √©l√©ments\nOn peut encha√Æner plusieurs lectures sur une m√™me ligne :\nstd::cin &gt;&gt; nom &gt;&gt; age;\n\nL‚Äôutilisateur doit saisir deux valeurs, s√©par√©es par des espaces.\nChaque &gt;&gt; extrait une valeur dans une variable, dans l‚Äôordre.\n\nTypes accept√©s\nstd::cin fonctionne avec les types de base :\n\nint, float, double\nchar, std::string\net d‚Äôautres types pour lesquels l‚Äôop√©rateur &gt;&gt; est surcharg√©\n\n\nAttention : std::cin s‚Äôarr√™te √† l‚Äôespace lorsqu‚Äôon lit une std::string. Pour lire une ligne compl√®te, on utilise std::getline().\n\nExemple complet\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main()\n{\n    std::string nom;\n    int age;\n \n    std::cout &lt;&lt; &quot;Entrez votre nom : &quot;;\n    std::cin &gt;&gt; nom;\n \n    std::cout &lt;&lt; &quot;Entrez votre √¢ge : &quot;;\n    std::cin &gt;&gt; age;\n \n    std::cout &lt;&lt; &quot;Bonjour &quot; &lt;&lt; nom &lt;&lt; &quot;, vous avez &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot; &lt;&lt; std::endl;\n    return 0;\n}\nR√©sum√©\n\nstd::cin permet de lire des valeurs depuis l‚Äôentr√©e standard, encha√Æn√©es avec l‚Äôop√©rateur &gt;&gt;.\nChaque &gt;&gt; extrait une valeur depuis le flux dans une variable. C‚Äôest un m√©canisme simple, direct, et parfaitement int√©gr√© √† la syntaxe C++.\n"},"classe-de-base":{"slug":"classe-de-base","filePath":"classe de base.md","title":"classe de base","links":["classe","attribut","m√©thode","h√©ritage","classe-d√©riv√©e","objet"],"tags":[],"content":"\nNom anglais: parent class / base class\n\n\nUne classe parente (ou classe de base) est une classe dont les caract√©ristiques (ses attributs et ses m√©thodes) peuvent √™tre h√©rit√©es (on appelle √ßa l‚Äôh√©ritage) par d‚Äôautres classes appel√©es classe d√©riv√©es.\nComparaison avec le C: En C, il n‚Äôexiste pas d‚Äôh√©ritage natif. En C++, une classe parente permet de cr√©er une base commune pour plusieurs objets.\n\nR√¥le de la classe parente\nLa classe parente permet :\n\nde regrouper des comportements communs √† plusieurs classes,\nde r√©duire la duplication de code,\nde organiser le programme sous forme d‚Äôune hi√©rarchie logique.\n\nElle sert de fondation pour ses classe d√©riv√©es.\nD√©finir une classe parente\nToute classe normale peut devenir une classe parente si une autre classe h√©rite d‚Äôelle :\nclass Vehicule\n{\npublic:\n    void demarrer();\n};\nIci, Vehicule peut devenir une classe parente.\nExemple\nAvec l‚Äôh√©ritage :\nclass Voiture : public Vehicule\n{\n    // Voiture h√©rite de Vehicule\n};\nVehicule est la classe parente de Voiture."},"classe-d√©riv√©e":{"slug":"classe-d√©riv√©e","filePath":"classe d√©riv√©e.md","title":"classe d√©riv√©e","links":["classe","classe-de-base","h√©ritage","attribut","m√©thode","C++","surcharge","publique","prot√©g√©","priv√©"],"tags":[],"content":"\nNom anglais: derived class / child class\n\n\nUne classe d√©riv√©e (ou classe enfant) est une classe qui h√©rite d‚Äôune classe de base (ou classe parent) : on parle d‚Äôh√©ritage. Elle reprend les attributs et m√©thodes de la classe de base et peut ajouter ses propres √©l√©ments ou modifier ceux qu‚Äôelle h√©rite.\nComparaison avec le C: Le C ne propose pas d‚Äôh√©ritage. En C++, une classe d√©riv√©e permet de sp√©cialiser une classe de base existante.\n\n\nR√¥le de la classe d√©riv√©e\nLa classe enfant :\n\nr√©utilise le code de la classe de base,\npeut ajouter de nouveaux comportements,\npeut red√©finir (on parle de surcharge ou override) certaines m√©thodes si n√©cessaire.\n\nD√©finir une classe d√©riv√©e\nOn utilise l‚Äôop√©rateur : et un niveau d‚Äôacc√®s (publique, prot√©g√©, ou priv√©) :\nclass Voiture : public Vehicule\n{\npublic:\n    void ouvrirCoffre();\n};\nVoiture h√©rite de tout ce qui est publique ou prot√©g√© dans Vehicule.\nExemple\nVoiture v;\nv.demarrer();    // h√©rit√© de Vehicule\nv.ouvrirCoffre(); // sp√©cifique √† Voiture\nVoiture est une classe d√©riv√©e (ou classe enfant) de Vehicule."},"classe-imbriqu√©e":{"slug":"classe-imbriqu√©e","filePath":"classe imbriqu√©e.md","title":"classe imbriqu√©e","links":["classe","type-interne","C++","d√©claration-anticip√©e"],"tags":[],"content":"\nNom anglais: nested class\n\n\nUne classe imbriqu√©e est une classe d√©finie √† l‚Äôint√©rieur d‚Äôune autre classe. C‚Äôest un type interne particulier, utilis√© pour structurer le code en hi√©rarchisant les √©l√©ments √©troitement li√©s.\nComparaison C/C++ : Le C ne permet pas d‚Äôimbriquer des struct ou des typedef aussi librement. En C++, une classe imbriqu√©e est un outil puissant pour l‚Äôorganisation interne.\n\nPourquoi utiliser une classe imbriqu√©e\nLes classes imbriqu√©es permettent :\n\nde grouper ensemble des concepts fortement li√©s,\nde cacher certains d√©tails d‚Äôimpl√©mentation,\nde limiter la port√©e d‚Äôune classe auxiliaire au sein d‚Äôune seule classe.\n\nD√©finir une classe imbriqu√©e\nOn d√©finit une classe √† l‚Äôint√©rieur d‚Äôune autre :\nclass Voiture\n{\npublic:\n    class Moteur // classe imbriqu√©e\n    {\n    public:\n        void demarrer();\n    };\n \nprivate:\n    Moteur moteur;\n};\nIci, Moteur est une classe imbriqu√©e dans Voiture.\n\nNote : Parfois, pour utiliser une classe imbriqu√©e proprement, on utilise une d√©claration anticip√©e.\n\nAcc√©der √† une classe imbriqu√©e\nVoiture::Moteur m;\nm.demarrer();\nOn utilise la syntaxe NomDeLaClasseParent::NomClasseImbriqu√©e.\n\nVeux-tu aussi une mini-fiche apr√®s sur forward declaration (parce que parfois, pour utiliser des classes imbriqu√©es proprement, on utilise aussi des d√©clarations anticip√©es) ? üöÄüìö\n(Si tu veux un Obsidian vraiment complet !)"},"classe":{"slug":"classe","filePath":"classe.md","title":"classe","links":["objet","attribut","m√©thode","structure","fonction","membre","C++","classe","publique","priv√©","prot√©g√©","polymorphisme","h√©ritage","convention-de-nommage","UpperCamelCase","STL","lowerCamelCase","biblioth√®que","organisation-des-fichiers-d'une-classe","forme-canonique","constructeur-par-d√©faut","constructeur-par-copie","op√©rateur-d‚Äôaffectation-par-copie","destructeur","classe-d√©riv√©e","classe-de-base","virtuel","C++11","membre-statique","fonction-statique","attribut-statique","exception","bloc"],"tags":[],"content":"\nNom anglais: class\n\n\nUne classe est un mod√®le ou un plan qui d√©finit la structure et le comportement d‚Äôobjets. Elle regroupe des attributs (donn√©es) et des m√©thodes (fonctions) qui d√©crivent ce que les objets de cette classe savent et savent faire.\nUne classe est donc un un type d√©fini par le programmeur, structurant des donn√©es (attribut) et des comportements (m√©thode).\nComparaison C/C++: Une classe ressemble √† une structure (struct) en C, mais avec en plus la possibilit√© de contenir des fonctions et de contr√¥ler l‚Äôacc√®s aux membres avec private, public, protected.\n\n\nClasses et objets\nLa classe sert de plan pour cr√©er des objets. Tous les objets cr√©√©s √† partir d‚Äôune m√™me classe partageront la m√™me structure, mais chacun aura ses propres donn√©es (ses propres attributs). L‚Äôobjet est donc une it√©ration particuli√®re d‚Äôune classe.\n\nComparaison C/C++ : En C, on utilise une structure struct pour d√©finir un nouveau type, puis on d√©clare des variables de ce type.\nEn C++, une classe joue un r√¥le √©quivalent : elle d√©finit un type structur√©, et un objet est une variable (ou instance) de ce type.\n\nPar exemple, en C, on peut d√©finir une structure Voiture, en faire un type avec typedef, puis d√©clarer une variable ma_voiture de ce type.\nDe mani√®re √©quivalente, en C++, on peut d√©finir une classe Voiture, puis d√©clarer un objet Voiture maVoiture qui est une instance de cette classe.\n\nClasses et membres\nUne classe contient :\n\ndes attributs (des variables) : ils repr√©sentent l‚Äô√©tat des objets\ndes m√©thodes (des fonctions) : ils d√©finissent le comportement des objets\n\n\nParties publique, priv√©e et prot√©g√©e\nUne classe peut contr√¥ler l‚Äôacc√®s √† ses membres en les regroupant sous trois sections : publique (public), priv√©e (private), et prot√©g√©e (protected).\n\nLes membres public sont accessibles depuis l‚Äôext√©rieur de la classe.\nLes membres private ne sont accessibles que depuis l‚Äôint√©rieur de la classe.\nLes membres protected sont comme private, mais accessibles √©galement aux classes d√©riv√©es (voir polymorphisme et h√©ritage).\n\nUne classe n‚Äôa pas n√©cessairement besoin d‚Äôavoir les trois parties, elle peut n‚Äôavoir par exemple qu‚Äôune partie publique, ou seulement une publique et une priv√©e, en fonction de ses besoins.\n\nSi aucune partie public, protectedou private n‚Äôest d√©clar√©e, par d√©faut tous les membres de la classe seront priv√©s.\n\n‚Üí Voir les fiches d√©di√©es : publique, priv√©, prot√©g√©\n\nD√©finition d‚Äôune classe\nLa d√©claration d‚Äôune classe utilise le mot-cl√© class, puis son nom, puis les accolades {} entre lesquelles seront d√©finis les attributs et les m√©thodes :\nclass NomDeLaClasse\n{\n\tprivate:\n\t    // attributs priv√©s\n\t    // m√©thodes priv√©es\n\tprotected:\n\t\t// attributs prot√©g√©s\n\t\t// m√©thodes prot√©g√©es\n\tpublic:\n\t\t// attributs publics\n\t\t// m√©thodes publiques\n};\n\nConvention de nommage\nLes classes utilisent g√©n√©ralement la convention de nommage UpperCamelCase : les mots composants le nom de la classe sont coll√©s, commencent par une majuscule, y compris le premier mot. Exemples :\n\nMaClasse\nCharacter\nTwoHandedAxe\n\n\nRemarque : dans la STL, les types comme std::vector, std::string, etc., sont en lowerCamelCase, car ce sont des mod√®les de classe dans une biblioth√®que tr√®s ancienne, avant la g√©n√©ralisation d‚ÄôUpperCamelCase pour les types d√©finis par l‚Äôutilisateur.\n\n\nOrganisation des fichiers\nEn C++, chaque classe doit √™tre r√©partie dans deux fichiers distincts :\n\nun fichier d‚Äôen-t√™te (.hpp) contenant la d√©claration de la classe (attributs et prototypes des m√©thodes, sans leur code),\nun fichier d‚Äôimpl√©mentation (.cpp) contenant la d√©finition des m√©thodes (c‚Äôest-√†-dire leur corps).\n\nCette s√©paration favorise la clart√©, la compilation efficace et la r√©utilisabilit√©.\n√Ä 42, cette organisation est obligatoire, et doit inclure les quatre √©l√©ments de la forme canonique :  le constructeur par d√©faut, le constructeur par copie, l‚Äôop√©rateur d‚Äôaffectation, et le destructeur.\n‚Üí Voir la fiche d√©di√©e: organisation des fichiers d‚Äôune classe\n\nUtiliser une classe\nUne fois la classe d√©finie, on peut cr√©er des objets (instances) de cette classe :\nMaClasse objet1;\nMaClasse objet2;\nChaque objet aura ses propres attributs, mais pourra utiliser les m√™mes m√©thodes.\n\nExemple\nVoici une d√©finition simple de classe :\nclass Voiture\n{\nprivate:\n    string couleur;\n    string marque;\n    int vitesse;\n \npublic:\n    void accelerer();\n    void freiner();\n};\nLa classe Voiture contient :\n\ndes attributs (couleur, marque, vitesse)\ndes m√©thodes (accelerer, freiner)\n\nOn pourra ensuite cr√©er plusieurs objets de type Voiture, chacun ayant ses propres caract√©ristiques.\n\nForme canonique\nEn C++, la forme canonique (ou canonical form) est une convention de conception qui consiste √† fournir les quatre m√©thodes fondamentales d‚Äôune classe.\nElle est particuli√®rement recommand√©e lorsqu‚Äôune classe g√®re des ressources, ou lorsqu‚Äôon souhaite ma√Ætriser explicitement les op√©rations de copie, d‚Äôaffectation et de destruction.\nCes quatre m√©thodes sont :\n\nle constructeur par d√©faut\nle constructeur par copie\nl‚Äôop√©rateur d‚Äôaffectation par copie\nle destructeur\n\n\n√Ä 42, la forme canonique est souvent exig√©e pour garantir un comportement pr√©visible et propre des objets, m√™me si certains de ces membres ne sont pas strictement n√©cessaires √† chaque fois.\n\n‚Üí Voir la fiche d√©di√©e : forme canonique\n\nPolymorphisme\nLe polymorphisme permet de manipuler plusieurs types d‚Äôobjets diff√©rents comme s‚Äôils √©taient du m√™me type, en s‚Äôappuyant sur une classe parente commune.\nConcr√®tement, on peut appeler la m√™me m√©thode sur des objets appartenant √† des classe d√©riv√©es diff√©rentes, du moment qu‚Äôils h√©ritent tous d‚Äôune m√™me classe de base.\nCe m√©canisme repose sur :\n\nl‚Äôh√©ritage entre classes (une classe d√©riv√©e h√©rite d‚Äôune classe de base)\nl‚Äôutilisation de m√©thodes virtuelles (virtual), √©ventuellement red√©finies avec override (√† partir du C++11 uniquement).\n\nCela permet, par exemple, d‚Äô√©crire des fonctions qui traitent n‚Äôimporte quel type d√©riv√© d‚Äôune m√™me classe de base.\n‚Üí Voir la fiche d√©di√©e : polymorphisme\n\nFonctions et attributs statiques\nUne classe peut poss√©der des membre statiques : des fonctions ou des attributs qui sont partag√©s par toutes les instances de la classe.\n\nUne fonction statique peut √™tre appel√©e sans cr√©er d‚Äôobjet.\nUn attribut statique est commun √† tous les objets (valeur partag√©e).\n\n‚Üí Voir la fiche d√©di√©e : membre statique\n\nExceptions\nLes classes peuvent √™tre utilis√©es pour lancer ou attraper des exceptions en C++, via les blocs try, throw, catch.\nIl est fr√©quent de cr√©er des classes d‚Äôexception personnalis√©es pour d√©crire des erreurs sp√©cifiques √† un contexte.\n‚Üí Voir la fiche d√©di√©e : exception"},"code-source":{"slug":"code-source","filePath":"code source.md","title":"code source","links":["C++","syntaxe","langage-compil√©","langage-interpr√©t√©","compilateur","interpr√©teur"],"tags":[],"content":"Qu‚Äôest-ce que le code source?\n\nLe code source est le texte √©crit par un programmeur dans un langage de programmation (comme C++, Python, Java).\nCe texte suit une certaine syntaxe et d√©crit ce que doit faire un programme. Avant d‚Äô√™tre ex√©cutable, le code source doit souvent √™tre compil√© (on parle alors d‚Äôun langage compil√©) ou interpr√©t√© (on part d‚Äôun langage interpr√©t√©).\n\nEn r√©sum√©\n\nC‚Äôest le ‚Äúplan‚Äù d‚Äôun programme.\nC‚Äôest lisible et modifiable par un humain.\nIl est √©crit dans des fichiers .cpp, .py, .java, etc.\nLe compilateur ou l‚Äôinterpr√©teur transforme ce code pour l‚Äôordinateur.\n\nExemples de code source\n#include &lt;iostream&gt;\n \nint main() {\n    std::cout &lt;&lt; &quot;Hello, World!&quot; &lt;&lt; std::endl;\n    return 0;\n}\n√Ä retenir\n\nLe code source est indispensable : sans lui, pas de programme.\nIl doit respecter les r√®gles du langage choisi (syntaxe).\nC‚Äôest ce que tu √©cris, modifies, am√©liores pendant le d√©veloppement.\n"},"compilateur":{"slug":"compilateur","filePath":"compilateur.md","title":"compilateur","links":["code-source","C++","fichier-binaire","compilation","GNU"],"tags":[],"content":"Qu‚Äôest-ce qu‚Äôun compilateur?\n\nUn compilateur est un programme qui traduit un code source√©crit dans un langage de programmation (comme C++) en un fichier ex√©cutable (le fichier binaire) que l‚Äôordinateur peut directement comprendre et ex√©cuter (on appelle √ßa la compilation).\nLe compilateur analyse tout le code, v√©rifie les erreurs, et produit un fichier binaire optimis√© pour √™tre rapide √† l‚Äôex√©cution.\n\nEn r√©sum√©\n\nEntr√©e : fichier .cpp (le code source).\nTraitement : analyse, optimisation, traduction vers du langage machine.\nSortie : fichier ex√©cutable (le fichier binaire).\n\nExemple de compilateurs C++\n\ng++ ‚Üí Compilateur C++ (GNU)\nclang++ ‚Üí Compilateur C++ bas√© sur LLVM\nMSVC ‚Üí Compilateur C++ de Microsoft\n"},"compilation":{"slug":"compilation","filePath":"compilation.md","title":"compilation","links":["code-source","C++","fichier-binaire","compilateur","syntaxe","GNU","terminal"],"tags":[],"content":"Qu‚Äôest-ce que la compilation?\n\nLa compilation est le processus de traduction d‚Äôun code source√©crit dans un langage de programmation (comme C++) en un fichier binaireque l‚Äôordinateur peut ex√©cuter directement.\n\nCe travail est effectu√© par un compilateur, qui transforme tout le programme d‚Äôun seul coup, en v√©rifiant aussi s‚Äôil contient des erreurs de syntaxe.\nCompiler du C++\nPour compiler du C++, il faut utiliser un compilateur comme g++ (GNU Compiler Collection pour C++): On lui donne un fichier source .cpp, et il cr√©e un ex√©cutable (le fichier binaire).\nCommande de base\nPour compiler\nCommande √† saisir dans un terminal:\ng++ mon_programme.cpp -o mon_programme\n\ng++ : lance le compilateur C++.\nmon_programme.cpp : le fichier source.\n-o mon_programme : option pour nommer l‚Äôex√©cutable (le fichier binaire, par exemple: mon_programme).\n\nPour ex√©cuter\nCommande √† saisir dans un terminal:\n./mon_programme\nAvec plusieurs fichiers\nS‚Äôil y a plusieurs fichiers, il faut les compiler ensemble avec cette commande √† saisir dans un terminal:\ng++ src/main.cpp src/utils.cpp -Iinclude -o build/mon_programme\n\n-Iinclude : indique o√π trouver tes fichiers d‚Äôen-t√™te .hpp (appel√©s  headers).\n"},"constructeur-par-copie":{"slug":"constructeur-par-copie","filePath":"constructeur par copie.md","title":"constructeur par copie","links":["m√©thode","objet","forme-canonique","fonction","r√©f√©rence","classe","attribut","prototype"],"tags":[],"content":"\nNom anglais: copy constructor\n\n\nLe constructeur par copie est une m√©thode sp√©ciale qui permet de cr√©er un nouvel objet en copiant un autre objet existant.\nIl est appel√© automatiquement dans certaines situations, et fait partie de la forme canonique exig√©e √† 42.\n\nQuand est-il utilis√© ?\n\n\nLorsqu‚Äôon cr√©e un objet √† partir d‚Äôun autre :\nmaClasse a;    // appelle le constructeur par d√©faut\nmaClasse b(a); // appelle le constructeur par copie\n\n\nLorsqu‚Äôon passe un objet par valeur √† une fonction :\nvoid f(maClasse x); // x est une copie de l‚Äôobjet pass√©\n\n\nSyntaxe\nLe constructeur par copie est une m√©thode sp√©ciale qui prend en param√®tre une r√©f√©rence constante √† un objet de la m√™me classe.\nLa fonction contient :\n\nle nomDeLaFonction (obligatoirement le m√™me nom que la classe)\ndes parenth√®ses () contenant un seul argument :\n\nune r√©f√©rence (&amp;) √† un objet de m√™me type\npr√©c√©d√©e du mot-cl√© const pour garantir qu‚Äôil ne sera pas modifi√© (r√©f√©rence constante)\n\n\ndeux points : pour introduire la liste d‚Äôinitialisation\nune liste d‚Äôinitialisation avec pour chaque attribut √† copier :\n\nl‚Äôattribut\ndes parenth√®ses () contenant l‚Äôattribut de l‚Äôobjet source √† copier (souvent nomm√© other)\nune virgule , pour s√©parer chaque attribut initialis√©\n\n\ndes accolades {} contenant le corps de la fonction (qui peut √™tre vide ou contenir une logique de copie plus complexe)\n\nComme pour toute m√©thode d‚Äôune classe, le .hpp doit contenir le prototype, et le .cpp doit contenir l‚Äôimpl√©mentation en elle-m√™me.\nExemple\nExemple de constructeur par copie pour une classe nomm√©e maClasse et pour laquelle je vais copier deux attributs :\nDans le .hpp :\n‚Üí On √©crit le prototype seulement :\nclass maClasse {\n\tpublic:\n\t\tmaClasse(const maClasse&amp; other);\n\tprivate:\n\t\tint _attribut1;\n\t\tchar _attribut2;\n};\nDans le .cpp :\n‚Üí On √©crit l‚Äôimpl√©mentation :\nmaClasse::maClasse(const maClasse&amp; other)\n\t: _attribut1(other._attribut1)\n\t, _attribut2(other._attribut2)\n{\n\t// corps de la fonction √©ventuellement vide\n}\nOn peut aussi copier les valeurs dans le corps de la fonction (mais c‚Äôest moins optimal) :\nmaClasse::maClasse(const maClasse&amp; other)\n{\n\t_attribut1 = other._attribut1;\n\t_attribut2 = other._attribut2;\n}\nPourquoi l‚Äô√©crire soi-m√™me ?\nLe compilateur g√©n√®re automatiquement un constructeur par copie par d√©faut.\nMais il effectue une copie membre √† membre (shallow copy) qui peut poser probl√®me si :\n\nla classe g√®re de la m√©moire dynamique\nelle contient des pointeurs\nelle utilise des ressources syst√®me (fichiers, sockets‚Ä¶)\n\nIl faut alors √©crire un constructeur par copie personnalis√© pour √©viter les fuites, les partages non souhait√©s ou les doubles lib√©rations.\nDe plus, le constructeur par copie est obligatoire dans la forme canonique.\nR√©sum√©\n\nLe constructeur par copie permet de cr√©er un objet en copiant un autre.\nIl est appel√© automatiquement dans de nombreuses situations et doit √™tre d√©fini manuellement si la classe g√®re des ressources sensibles.\nIl est obligatoire dans la forme canonique √† 42.\n"},"constructeur-par-d√©faut":{"slug":"constructeur-par-d√©faut","filePath":"constructeur par d√©faut.md","title":"constructeur par d√©faut","links":["m√©thode","classe","objet","forme-canonique","attribut","fonction","prototype","constructeur","compilateur"],"tags":[],"content":"\nNom anglais: default constructor\n\n\nLe constructeur par d√©faut est une m√©thode sp√©ciale d‚Äôune classe qui est appel√©e automatiquement lors de la cr√©ation d‚Äôun objet sans argument.\nIl fait partie de la forme canonique exig√©e √† 42.\n\nQuand est-il utilis√© ?\n\n\nLorsqu‚Äôon d√©clare un objet sans fournir de param√®tre :\nmaClasse a; // appelle le constructeur par d√©faut\n\n\nLorsqu‚Äôon cr√©e un tableau d‚Äôobjets ou un objet membre dans une autre classe sans initialisation explicite.\n\n\nSyntaxe\nLe constructeur par d√©faut est une m√©thode sans param√®tre, qui peut initialiser les attributs de l‚Äôobjet.\nLa fonction contient :\n\nle nomDeLaFonction (obligatoirement le m√™me nom que la classe)\ndes parenth√®ses vides (), car il ne prend aucun argument\ndeux points : pour introduire la liste d‚Äôinitialisation (facultative mais recommand√©e)\nune liste d‚Äôinitialisation avec pour chaque attribut √† initialiser :\n\nl‚Äôattribut\ndes parenth√®ses () contenant une valeur initiale\nune virgule , pour s√©parer chaque attribut initialis√©\n\n\ndes accolades {} contenant le corps de la fonction (qui peut √™tre vide ou contenir une logique par d√©faut)\n\nComme pour toute m√©thode d‚Äôune classe, le .hpp doit contenir le prototype, et le .cpp doit contenir l‚Äôimpl√©mentation en elle-m√™me.\nExemple\nExemple de constructeur par d√©faut pour une classe nomm√©e maClasse et pour laquelle je vais initialiser deux attributs :\nDans le .hpp :\n‚Üí On √©crit le prototype seulement :\nclass maClasse {\n\tpublic:\n\t\tmaClasse();\n\tprivate:\n\t\tint _attribut1;\n\t\tchar _attribut2;\n};\nDans le .cpp :\n‚Üí On √©crit l‚Äôimpl√©mentation :\nmaClasse::maClasse()\n\t: _attribut1(0)\n\t, _attribut2(&#039;A&#039;)\n{\n\t// corps de la fonction √©ventuellement vide\n}\nOn peut aussi initialiser les valeurs dans le corps de la fonction (mais c‚Äôest moins optimal) :\nmaClasse::maClasse()\n{\n\t_attribut1 = 0;\n\t_attribut2 = &#039;A&#039;;\n}\nIl est √©galement possible de laisser le constructeur par d√©faut vide, sans initialisation explicite, mais cela a des cons√©quences :\n\nles attributs primitifs (int, char, etc) contiendront alors des valeurs ind√©termin√©es\nles attributs de type objet (comme par exemple std::string) seront initialis√©s par le constructeur par d√©faut de l‚Äôobjet en question\n\nmaClasse::maClasse()\n{\n}\nPourquoi l‚Äô√©crire soi-m√™me ?\n\nSi aucun constructeur n‚Äôest d√©fini, le compilateur en cr√©e un automatiquement (appel√© constructeur implicite).\nMais d√®s qu‚Äôun autre constructeur est d√©fini (ex. avec param√®tres), le constructeur par d√©faut n‚Äôest plus g√©n√©r√©.\nIl est donc n√©cessaire de l‚Äô√©crire manuellement si l‚Äôon veut continuer √† pouvoir cr√©er des objets sans argument.\nDe plus, il est obligatoire dans la forme canonique.\n\nR√©sum√©\n\nLe constructeur par d√©faut permet de cr√©er un objet sans argument. Il est appel√© automatiquement dans de nombreuses situations et doit √™tre d√©fini manuellement si un autre constructeur existe.\nIl est obligatoire dans la forme canonique √† 42.\n"},"constructeur":{"slug":"constructeur","filePath":"constructeur.md","title":"constructeur","links":["m√©thode","classe","objet","attribut","fonction","publique","liste-d'initialisation","C++11","forme-canonique","constructeur-par-d√©faut","constructeur-par-copie","forme-canonique-de-Coplien"],"tags":[],"content":"\nNom anglais: constructor\n\n\nUn constructeur est une m√©thode sp√©ciale d‚Äôune classe qui est appel√©e automatiquement lors de la cr√©ation d‚Äôun objet.\nIl sert √† initialiser les attributs de cet objet (ses variables).\n\n\nDe quoi est compos√© un constructeur\n\nC‚Äôest une fonction sans type de retour (pas m√™me void)\nde m√™me nom que la classe\ng√©n√©ralement dans la partie publique de la classe\nelle contient g√©n√©ralement une liste d‚Äôinitialisation (qui va initialiser les attributs) situ√©e entre le prototype et le corps de la fonction\n\n\nSyntaxe\nLe constructeur contient:\n\nle NomDeLaFonction (obligatoirement le m√™me nom que la classe)\ndes parenth√®ses ()contenant les arguments attendus\ndeux points : pour introduire la liste d‚Äôinitialisation\nla liste d‚Äôinitialisation avec pour chaque attribut √† initialiser:\n\nl‚Äôattribut\ndes parenth√®ses () contenant la valeur √† affecter √† l‚Äôattribut\nune virgule ,pour s√©parer chaque attribut initialis√©\n\n\ndes accolades {}contenant le corps de la fonction (qui peut √™tre vide)\n\nComme pour tout m√©thode d‚Äôune classe, le .hpp doit contenir le prototype et le .cpp doit contenir l‚Äôimpl√©mentation.\n\nExemple\nExemple de constructeur pour une classe nomm√©e maClasse et pour laquelle je vais initialiser deux attributs :\nTu as eu raison de te poser la question ‚Äî et en effet, il y a une l√©g√®re confusion dans ta fiche concernant la s√©paration entre .hpp et .cpp.\nDans le .hpp :\n‚Üí On √©crit le prototype seulement :\nclass maClasse {\n\tpublic:\n\t\tmaClasse(int variable1, char variable2);\n\tprivate:\n\t\tint _attribut1;\n\t\tchar _attribut2;\n};\nDans le .cpp :\n‚Üí On √©crit l‚Äôimpl√©mentation :\nmaClasse::maClasse(int variable1, char variable2)\n\t: _attribut1(variable1)\n\t, _attribut2(variable2)\n{\n\t// corps de la fonction √©ventuellement vide\n}\nOn peut aussi initialiser dans le corps de la fonction mais c‚Äôest moins optimal :\nmaClasse::maClasse(int variable1, char variable2)\n{\n\t_attribut1 = variable1;\n\t_attribut2 = variable2;\n}\n\nEn C++11\nLa liste d‚Äôinitialisation peut utiliser des accolades {} mais pour rappel le C++11 est interdit dans les premiers modules 42 :\nclass maClasse {\n\tpublic:\n\t\tmaClasse(int variable1, char variable2)\n\t\t\t: _attribut1 { variable1 }\n\t\t\t, _attribut2 { variable2 }\n\t\t{\n\t\t\t// corps de la fonction\n\t\t\t// qui peut rester vide si elle ne fait rien d&#039;autre qu&#039;initialiser)\n\t\t}\n\tprivate:\n\t\tint _attribut1;\n\t\tchar _attribut2;\n};\nCela permet d‚Äô√©viter les ambigu√Øt√©s comme par exemple :\nMyClass obj1(1);   // Appelle le constructeur\nMyClass obj2();    // Ce n‚Äôest pas un objet : d√©claration d‚Äôune fonction !\nMyClass obj3{1};   // Appelle le constructeur sans ambigu√Øt√©\n\nDans quels cas impl√©menter le corps du constructeur\nLe corps de la fonction peut contenir du code si besoin, comme par exemple :\n\ninitialisation des attributs dans le corps de la fonction - possible mais pas optimal (voir au-dessus)\nfaire un traitement apr√®s initilaisation (comme par exemple afficher un message)\nappeler une m√©thode interne\nfaire des calculs √† partir des param√®tres (par exemple variable3 = variable1 + variable2)\ninitialiser un attribut dans constructeur par d√©faut (si cet attribut est un objet complexe et qu‚Äôil n‚Äôa pas de constructeur accessible)\n\n\nConstructeurs et forme canonique\nLa forme canonique (obligatoire dans la plupart des projets 42) exige de d√©finir, entre autres, deux constructeurs particuliers :\n\nle constructeur par d√©faut\nle constructeur par copie\n\n‚Üí Voir la fiche d√©di√©e : forme canonique de Coplien"},"conteneur-adaptateur":{"slug":"conteneur-adaptateur","filePath":"conteneur adaptateur.md","title":"conteneur adaptateur","links":["conteneur-standard-de-la-STL","conteneur","file-double","vecteur","pile","file-FIFO","file-de-priorit√©"],"tags":[],"content":"\nNom anglais: container adaptor\n\n\nUn conteneur adaptateur est un conteneur standard de la STL qui ne stocke pas directement les √©l√©ments, mais fournit une interface restreinte sur un conteneur sous-jacent (g√©n√©ralement une file double dequeou un vecteur vector).\nLes adaptateurs permettent d‚Äôutiliser des structures classiques comme des piles ou des files, sans exposer toute l‚Äôinterface du conteneur de base.\n\n\nFonctionnement\nUn adaptateur encapsule un conteneur standard (deque, vector, etc.) et restreint son interface √† un mode d‚Äôacc√®s sp√©cifique :\n\nLIFO (Last In First Out) pour stack\nFIFO (First In First Out) pour queue\nmax-priority pour priority_queue\n\nIl ne permet ni acc√®s par index, ni parcours complet, mais fournit une interface simple et adapt√©e √† un comportement algorithmique particulier.\n\nCaract√©ristiques\n\nInterface limit√©e √† quelques fonctions essentielles (push, pop, top, etc.)\nUtilise en interne un conteneur s√©quentiel (deque, vector, etc.)\nNe fournit pas d‚Äôit√©rateur\nNe permet pas le parcours ou l‚Äôinsertion arbitraire\n\n\nTypes principaux\nLes principaux conteneurs adaptateurs sont :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConteneurDescriptionConteneur sous-jacent (par d√©faut)std::stackpile LIFO (acc√®s par le haut)deque (file double)std::queuefile FIFO (ajout fin, retrait d√©but)deque (file double)std::priority_queuefile de priorit√© (tri√©e par max)vector (vecteur)\n‚Üí Voir les fiches d√©di√©es : pile, file FIFO, file de priorit√©\n\nComparaison avec les autres conteneurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectAdaptateursS√©quentiels / AssociatifsInterface restreinte‚úÖ oui‚ùå non (interface compl√®te)It√©rateurs‚ùå non‚úÖ oui (begin(), end(), etc.)Parcours possible‚ùå non‚úÖ ouiAcc√®s par index‚ùå non‚úÖ pour certains (vector, deque)Usage algorithmique‚úÖ sp√©cialis√© (FIFO, LIFO)‚ö†Ô∏è plus g√©n√©raliste\n\nUsage typique\n\nImpl√©mentation d‚Äôune pile de traitement (stack)\nTraitement en file d‚Äôattente (ex√©cution diff√©r√©e, gestion d‚Äô√©v√©nements) via queue\nTri dynamique par priorit√© dans les algorithmes gloutons (priority_queue)\n"},"conteneur-associatif":{"slug":"conteneur-associatif","filePath":"conteneur associatif.md","title":"conteneur associatif","links":["conteneur-standard-de-la-STL","C++98","it√©rateur","ensemble","dictionnaire"],"tags":[],"content":"\nNom anglais: associative container\n\n\nUn conteneur associatif est un conteneur standard de la STL con√ßu pour stocker des √©l√©ments accessibles via une cl√©, plut√¥t que par une position ou un index.\nIl repose sur une structure de donn√©es permettant une recherche rapide des √©l√©ments par leur cl√©.\n\n\nFonctionnement\nLes conteneurs associatifs C++98 utilisent en interne un arbre binaire de recherche √©quilibr√© (g√©n√©ralement un arbre rouge-noir), ce qui garantit des op√©rations en temps O(log n) pour :\n\nl‚Äôinsertion (insert)\nla recherche (find)\nla suppression (erase)\n\n\nCaract√©ristiques\n\nLes √©l√©ments sont tri√©s automatiquement selon operator&lt; sur la cl√©\nL‚Äôacc√®s se fait via des it√©rateurs (parcours tri√© possible)\nChaque √©l√©ment est soit une cl√© (set), soit une paire cl√©/valeur (map)\n\n\nTypes principaux\nLes principaux conteneurs associatifs sont :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConteneurDescriptionstd::setEnsemble tri√© de valeurs uniquesstd::multisetEnsemble tri√© avec doublons autoris√©sstd::mapTable tri√©e de paires cl√©/valeur uniquesstd::multimapTable tri√©e avec plusieurs valeurs par cl√©\n‚Üí Voir les fiches d√©di√©es: ensemble, dictionnaire\n\nComparaison avec les conteneurs s√©quentiels\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectAssociatifS√©quentiel (vector, list, ‚Ä¶)Acc√®s par cl√©‚úÖ oui‚ùå nonTri automatique‚úÖ oui‚ùå nonAcc√®s par index‚ùå non‚úÖ oui (vector, deque)Performance acc√®sO(log n)O(1) √† O(n) selon structure\n\nUsage typique\n\nTables de correspondance, dictionnaires\nIndexation par identifiant\nComptage de fr√©quences\nStructure d‚Äôacc√®s rapide par nom, cat√©gorie ou cl√©\n"},"conteneur-standard-de-la-STL":{"slug":"conteneur-standard-de-la-STL","filePath":"conteneur standard de la STL.md","title":"conteneur standard de la STL","links":["conteneur","STL","C++","vecteur","liste","file-double","ensemble","dictionnaire","conteneur-associatif","dictionnaire-√†-cl√©-multiples","ensemble-avec-doublons","pile-algorithmique-LIFO","conteneur-adaptateur","file-FIFO","file-de-priorit√©","programmation-orient√©e-objet"],"tags":[],"content":"\nNom anglais: STL containers / standard containers\n\n\nLes conteneurs std sont des structures fournies par la STL (Standard Template Library) en C++.\nIls permettent de stocker, organiser et manipuler des collections de donn√©es de mani√®re s√ªre, souple et efficace.\nChaque conteneur est optimis√© pour un usage particulier : acc√®s rapide, ajout en fin, insertion au milieu, recherche, etc.\n\n\nListe des conteneurs principaux\nLes vecteurs : std::vector ‚Äì Tableau dynamique\nLe vecteur std::vector est le conteneur le plus utilis√©. Il agit comme un tableau dynamique : il permet d‚Äôajouter, supprimer ou acc√©der aux √©l√©ments en temps constant (acc√®s par indice). Contrairement aux tableaux en C, un vector peut grandir ou r√©tr√©cir automatiquement selon les besoins. Il stocke ses √©l√©ments de mani√®re contigu√´ en m√©moire, ce qui le rend rapide pour les acc√®s successifs. Il convient parfaitement quand on conna√Æt approximativement la taille √† l‚Äôavance ou quand les √©l√©ments sont principalement ajout√©s √† la fin.\n‚Üí Voir la fiche d√©di√©e vecteur\nLes listes : std::list ‚Äì Liste doublement cha√Æn√©e\nLa liste std::list est une liste doublement cha√Æn√©e. Elle permet une insertion ou suppression rapide n‚Äôimporte o√π dans la liste (en O(1) si on a un pointeur). Contrairement √† vector, les √©l√©ments ne sont pas contigus en m√©moire. Cela la rend moins performante pour les acc√®s par position, mais id√©ale si on doit ins√©rer ou retirer souvent des √©l√©ments au milieu. Elle ne permet pas d‚Äôacc√®s par indice direct (list[i] est invalide). Elle est plus lourde en m√©moire, mais plus souple pour certaines op√©rations.\n‚Üí Voir la fiche d√©di√©e liste\nLes files : std::deque ‚Äì Double-ended queue\nLa file double std::deque (double-ended queue) est une structure interm√©diaire entre vector et list. Elle permet des ajouts et suppressions rapides aux deux extr√©mit√©s (d√©but et fin) tout en offrant un acc√®s par indice. Elle est utile pour manipuler des donn√©es dans un contexte de file d‚Äôattente ou de pile double. Contrairement √† vector, ses donn√©es ne sont pas garanties comme contigu√´s en m√©moire, mais elle reste tr√®s rapide dans les cas d‚Äôusage adapt√©s.\n‚Üí Voir la fiche d√©di√©e file double\nLes ensembles : std::set ‚Äì Ensemble ordonn√©\nL‚Äôensemble std::set stocke des valeurs uniques dans un ordre tri√© automatiquement. Il utilise en g√©n√©ral une arborescence √©quilibr√©e (comme un red-black tree) pour garantir des temps d‚Äôinsertion, de recherche et de suppression en O(log n). Il est parfait pour repr√©senter des ensembles math√©matiques, des listes sans doublons, ou faire des recherches rapides sans re-trier. Il ne permet pas de stocker plusieurs fois la m√™me valeur, ni de modifier directement les √©l√©ments (car cela briserait l‚Äôordre).\n‚Üí Voir la fiche d√©di√©e ensemble\nLes maps : std::map ‚Äì Dictionnaire cl√©-valeur ordonn√©\nLe dictionnaire std::map est un conteneur associatif qui relie une cl√© unique √† une valeur. Il agit comme un dictionnaire : tu peux y acc√©der avec map[&quot;cl√©&quot;]. Les cl√©s sont automatiquement tri√©es, et chaque insertion, recherche ou suppression est en O(log n). Il est parfait pour organiser des donn√©es index√©es de mani√®re claire (comme une table de symboles, des configs, etc). Il ne peut pas contenir deux fois la m√™me cl√©.\n‚Üí Voir la fiche d√©di√©e dictionnaire\nstd::unordered_map ‚Äì Dictionnaire non tri√© (hach√©)\nLe dictionnaire √† cl√© multiples std::unordered_map est similaire √† map, mais les cl√©s ne sont pas tri√©es. Il utilise une table de hachage pour stocker les paires cl√©/valeur, ce qui rend les op√©rations plus rapides (en moyenne O(1)) mais non ordonn√©es. C‚Äôest id√©al si l‚Äôordre des cl√©s n‚Äôa aucune importance, et que tu veux une performance maximale en recherche.\n‚Üí Voir la fiche d√©di√©e dictionnaire √† cl√© multiples\nstd::unordered_set ‚Äì Ensemble non tri√©\nComme unordered_map, l‚Äôensemble avec doublons est bas√© sur un hachage, mais ne stocke que des valeurs uniques (sans paires cl√©-valeur). Il est tr√®s utile pour tester rapidement l‚Äôappartenance √† un ensemble ou √©liminer les doublons sans tri.\n‚Üí Voir la fiche d√©di√©e ensemble avec doublons\nstd::stack ‚Äì Pile LIFO (Last In First Out)\nLa pile algorithmique LIFO std::stack est un conteneur adaptateur bas√© par d√©faut sur std::deque. Elle offre une interface simplifi√©e pour g√©rer une pile d‚Äô√©l√©ments : on ajoute avec push() et on retire avec pop(), toujours par le haut. On acc√®de au sommet avec top(). Elle est id√©ale pour mod√©liser des structures r√©cursives, des appels empil√©s, ou des algorithmes comme le parcours profond (DFS). Elle n‚Äôexpose pas d‚Äôit√©rateur, ni de parcours possible.\n‚Üí Voir la fiche d√©di√©e pile algorithmique LIFO\nstd::queue ‚Äì File FIFO (First In First Out)\nLa file FIFO std::queue est une file d‚Äôattente classique : les √©l√©ments sont ajout√©s √† la fin (push) et retir√©s au d√©but (pop). Elle est parfaite pour traiter des √©v√©nements ou des t√¢ches dans l‚Äôordre d‚Äôarriv√©e. Comme stack, elle repose g√©n√©ralement sur deque et n‚Äôexpose aucun it√©rateur. Elle permet de mod√©liser des pipelines, buffers ou boucles de traitement.\n‚Üí Voir la fiche d√©di√©e file FIFO\nstd::priority_queue ‚Äì File de priorit√© (tas binaire)\nLa file de priorit√© std::priority_queue est une file sp√©ciale o√π l‚Äô√©l√©ment ayant la plus haute priorit√© est toujours en t√™te. Par d√©faut, il s‚Äôagit d‚Äôun max-heap : l‚Äô√©l√©ment le plus grand (selon operator&lt;) est en haut. Elle s‚Äôappuie sur un std::vector et les algorithmes make_heap / push_heap. Elle est tr√®s utilis√©e dans les algorithmes gloutons (Dijkstra, A*, Huffman), les planificateurs ou syst√®mes √† priorit√© dynamique.\n‚Üí Voir la fiche d√©di√©e file de priorit√©\n\nR√©sum√©\n\nLes conteneurs std sont des outils puissants pour organiser et g√©rer des collections de donn√©es.\nLe choix du conteneur d√©pend de l‚Äôordre, de la recherche, de la fr√©quence d‚Äôajout/retrait, et des performances souhait√©es.\nC‚Äôest l‚Äôun des fondements de la STL et de la programmation orient√©e objet moderne en C++.\n"},"conteneur-s√©quentiel":{"slug":"conteneur-s√©quentiel","filePath":"conteneur s√©quentiel.md","title":"conteneur s√©quentiel","links":["conteneur-standard-de-la-STL","conteneur-associatif","vecteur","file-double","it√©rateur","liste"],"tags":[],"content":"\nNom anglais: sequential container\n\n\nUn conteneur s√©quentiel est un conteneur standard de la STL destin√© √† stocker des √©l√©ments dans un ordre lin√©aire, correspondant √† leur ordre d‚Äôinsertion ou de position logique.\nContrairement aux conteneur associatifs, l‚Äôacc√®s aux √©l√©ments se fait par position (index ou it√©rateur), et non par cl√©.\n\n\nFonctionnement\nLes conteneurs s√©quentiels offrent une organisation ordonn√©e des √©l√©ments.\nIls sont adapt√©s √† une gestion de s√©quences, √† des acc√®s par index, ou √† des traitements lin√©aires (parcours, filtres, tris manuels).\nLeur comportement varie selon leur structure interne : tableau contigu, tableau segment√©, ou liste cha√Æn√©e.\n\nCaract√©ristiques\n\nLes √©l√©ments sont ordonn√©s selon leur position dans la s√©quence\nIls sont accessibles via index (vecteur vector, file double deque) ou it√©rateurs`\nAucune structure de tri automatique\nLes performances d√©pendent fortement de la structure m√©moire (contigu√´ ou non)\n\n\nTypes principaux\nLes principaux conteneurs s√©quentiels sont :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConteneurDescriptionstd::vector (vecteur)Tableau dynamique √† m√©moire contigu√´ (acc√®s rapide)std::deque (file double)Tableau segment√© √† double extr√©mit√©std::list (liste)Liste doublement cha√Æn√©e\n‚Üí Voir les fiches d√©di√©es : vecteur, file double, liste\n\nComparaison avec les conteneurs associatifs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAspectS√©quentielAssociatif (map, set, ‚Ä¶)Acc√®s par index‚úÖ oui (vector, deque)‚ùå nonAcc√®s par cl√©‚ùå non‚úÖ ouiOrdre d‚Äôinsertion‚úÖ conserv√©‚ùå tri automatique par cl√©Parcours m√©moire‚úÖ tr√®s rapide (vector)‚ö†Ô∏è plus co√ªteux (arbre)Tri automatique‚ùå non‚úÖ oui (operator&lt;)\n\nUsage typique\n\nRepr√©sentation de s√©quences, tableaux dynamiques\nParcours ordonn√© et manipulation d‚Äô√©l√©ments\nStructures FIFO, piles, buffers\nStockage d‚Äôobjets dans l‚Äôordre logique du traitement\n"},"conteneur":{"slug":"conteneur","filePath":"conteneur.md","title":"conteneur","links":["C++","STL","objet","it√©rateur","algorithmes-STL","conteneur-standard-de-la-STL","conteneur-s√©quentiel","vecteur","file-double","liste","conteneur-associatif","ensemble","dictionnaire","ensemble-avec-doublons","dictionnaire-√†-cl√©-multiples","conteneur-adaptateur","pile-algorithmique-LIFO","file-FIFO","file-de-priorit√©"],"tags":[],"content":"\nNom anglais: container\n\n\nEn C++, un conteneur est une structure de donn√©es, g√©n√©ralement fournie par la STL (Standard Template Library), qui permet de stocker et g√©rer des collections d‚Äôobjets.\nChaque conteneur propose une interface standardis√©e avec des it√©rateurs, des op√©rations d‚Äôinsertion, de suppression, et d‚Äôacc√®s aux √©l√©ments.\n\n\nObjectif des conteneurs\n\nCentraliser la gestion de la m√©moire et des structures de donn√©es\nFournir une interface g√©n√©rique pour les algorithmes STL\nGarantir des performances adapt√©es selon l‚Äôusage : s√©quentiel, associatif, adaptatif\n\n\nCat√©gories principales\nLes conteneur standard de la STL se divisent en plusieurs cat√©gories selon leur structure et leur mode d‚Äôacc√®s :\nConteneurs s√©quentiels\nLes conteneur s√©quentiels stockent les √©l√©ments dans l‚Äôordre d‚Äôinsertion, accessibles par position :\n\nvecteur std::vector\nfile double std::deque\nliste std::list\n\nConteneurs associatifs\nLes conteneur associatifs stockent les √©l√©ments selon une cl√© unique ou non, et les trie automatiquement :\n\nensemble std::set\ndictionnaire std::map\nensemble avec doublons std::multiset\ndictionnaire √† cl√© multiplesstd::multimap\n\nConteneurs adaptateurs\nLes conteneur adaptateurs fournissent une interface restreinte sur un autre conteneur (souvent une file double deque) :\n\npile algorithmique LIFO std::stack\nfile FIFO std::queue\nfile de priorit√© std::priority_queue\n\n\nVoir aussi\n\nconteneur standard de la STL ‚Üí r√©capitulatif de tous les conteneurs STL C++98\nconteneur associatif ‚Üí fonctionnement, structure interne, usages\nconteneur s√©quentiel ‚Üí comparaison vector / deque / list\nconteneur associatif ‚Üí fonctionnement par paire cl√©/valeur\n"},"contr√¥les-d'acc√®s":{"slug":"contr√¥les-d'acc√®s","filePath":"contr√¥les d'acc√®s.md","title":"contr√¥les d'acc√®s","links":["C++","attribut","m√©thode","classe","publique","prot√©g√©","classe-d√©riv√©e","priv√©","encapsulation"],"tags":[],"content":"\nNom anglais: access control / access specifiers\n\n\nLes contr√¥les d‚Äôacc√®s en C++permettent de d√©finir qui peut acc√©der aux attributs et m√©thodes d‚Äôune classe. Ils assurent la protection et l‚Äôorganisation des donn√©es.\nComparaison C/C++ : En C, il n‚Äôy a pas de contr√¥le d‚Äôacc√®s dans les struct. En C++, les classes peuvent restreindre ou exposer ce qu‚Äôelles contiennent.\n\nLes trois niveaux d‚Äôacc√®s\n\npublique : accessible partout (par n‚Äôimporte qui).\nprot√©g√© : accessible dans la classe et ses classe d√©riv√©es (mais pas de l‚Äôext√©rieur).\npriv√© : accessible seulement √† l‚Äôint√©rieur de la classe.\n\nUtiliser les contr√¥les d‚Äôacc√®s\nOn les utilise dans la d√©claration d‚Äôune classe :\nclass Voiture\n{\nprivate:\n    int vitesse;\n \npublic:\n    void demarrer();\n};\n\n\nvitesse est priv√©e : on ne peut pas y acc√©der directement de l‚Äôext√©rieur.\n\n\ndemarrer() est publique : on peut l‚Äôappeler librement.\n\n\nR√©sum√©\nLes contr√¥les d‚Äôacc√®s permettent de :\n\n\nProt√©ger les donn√©es sensibles,\n\n\nEncadrer l‚Äôutilisation des objets,\n\n\nRespecter l‚Äôencapsulation.\n\n\n\nVeux-tu que je te pr√©pare aussi une mini-fiche d√©di√©e sur protected (partie prot√©g√©e) pour finir le trio public / protected / private proprement dans ton Obsidian‚ÄØ? üîíüìö"},"convention-de-nommage":{"slug":"convention-de-nommage","filePath":"convention de nommage.md","title":"convention de nommage","links":["classe","fonction","variable","attribut","espace-de-noms","C++","m√©thode","Classe","Struct","UpperCamelCase","Fonction","M√©thode","lowerCamelCase","Variable-locale","Attribut","priv√©","Constante","Macro","Fichier","Namespace"],"tags":[],"content":"\nNom anglais : Naming convention\n\n\nUne convention de nommage est un ensemble de r√®gles adopt√©es dans un projet ou une communaut√© pour nommer de mani√®re coh√©rente et lisible les diff√©rents √©l√©ments du code source : classe, fonction, variable, attribut, espace de noms, etc.\nComparaison C / C++ : En langage C, les conventions varient fortement selon les projets, et les noms utilisent souvent le style snake_case avec des majuscules pour les constantes. En C++, bien que plusieurs styles existent, une structuration claire du nommage est souvent adopt√©e pour distinguer visuellement les responsabilit√©s (types, m√©thodes, constantes, etc.). Cela permet d‚Äôam√©liorer la lisibilit√©, la maintenabilit√© et l‚Äôuniformit√© du code.\n\n\nObjectifs\nUne convention de nommage vise √† :\n\ndiff√©rencier clairement les types d‚Äô√©l√©ments (classe, fonction, etc.)\nam√©liorer la lisibilit√© du code\n√©viter les erreurs ou confusions\nfaciliter le travail collaboratif\nr√©duire le besoin de commentaires\n\n\nStyles courants\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n√âl√©mentStyle utilis√©ExempleClasse, StructUpperCamelCaseGestionnaireFichierFonction, M√©thodelowerCamelCaselireLigne()Variable localelowerCamelCasecompteurAttribut priv√©lowerCamelCaseposition_Constante, MacroSCREAMING_SNAKE_CASETAILLE_MAXFichiersnake_casemon_module.cppNamespacesnake_case ou minusculeutilitaires\n\nRemarques\n\nIl n‚Äôexiste pas de norme unique en C++, mais plusieurs conventions populaires (Google, LLVM, Qt, etc.).\nL‚Äôimportant est de choisir une convention coh√©rente et de s‚Äôy tenir dans tout le projet.\nLes noms doivent rester significatifs et explicites, m√™me si cela implique d‚Äô√™tre un peu plus longs.\n"},"cout":{"slug":"cout","filePath":"cout.md","title":"cout","links":["Nom-pleinement-qualifi√©","biblioth√®que-standard-C++","biblioth√®que-iostream","espace-de-noms","flux","C++","objet","op√©rateur","string","surcharg√©"],"tags":[],"content":"\nNom pleinement qualifi√©: std::cout\n\n\nstd::cout est un objet de la biblioth√®que standard C++ qui permet d‚Äôafficher des donn√©es sur la sortie standard (g√©n√©ralement l‚Äô√©cran). Il fait partie de la biblioth√®que iostreamet appartient √† l‚Äôespace de nomsstd.\nOn l‚Äôutilise avec l‚Äôop√©rateur &lt;&lt; (appel√© op√©rateur d‚Äôinsertion) pour envoyer une ou plusieurs valeurs dans le flux de sortie standard.\nComparaison C/C++ : En C, on utilise la fonction printf() pour afficher. En C++, on utilise std::cout, qui est un objet de type std::ostream, utilis√© avec l‚Äôop√©rateur &lt;&lt;.\n\nFonctionnement de base\nstd::cout &lt;&lt; &quot;Bonjour&quot;;\n\nCela affiche &quot;Bonjour&quot; sur la console.\nL‚Äôop√©rateur &lt;&lt; signifie ici ‚Äúenvoie dans le flux‚Äù.\n\nAfficher plusieurs √©l√©ments\nOn peut encha√Æner autant d‚Äô√©l√©ments que l‚Äôon souhaite, chacun s√©par√© par &lt;&lt; :\nstd::cout &lt;&lt; &quot;Nom : &quot; &lt;&lt; nom &lt;&lt; &quot;, √¢ge : &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot;;\nChaque morceau est envoy√© dans le flux l‚Äôun apr√®s l‚Äôautre, dans l‚Äôordre.\n\nIl ne s‚Äôagit pas d‚Äôune liste d‚Äôarguments, mais d‚Äôune suite d‚Äôop√©rations &lt;&lt; ex√©cut√©es successivement.\n\nTypes accept√©s\nstd::cout accepte automatiquement :\n\ndes valeurs textuelles : &quot;texte&quot;, &#039;c&#039;, des cha√Ænes de caract√®re de type string (les std::string)\ndes valeurs num√©riques : int, float, double\ndes bool√©ens, des pointeurs, etc.\n\nC‚Äôest possible car l‚Äôop√©rateur &lt;&lt; est surcharg√©  pour tous ces types.\n\nEn C++, une fonction ou un op√©rateur est surcharg√© lorsqu‚Äôil existe plusieurs versions d‚Äôun m√™me nom, qui se comportent diff√©remment selon les types des arguments qu‚Äôon lui donne (int, string, etc).\nComparaison C/C++: Cela signifie qu‚Äôen C++ on peut par exemple afficher un int via std::cout sans avoir besoin de faire appel √† une fonction comme itoa.\n\nExemple complet\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main()\n{\n    std::string nom = &quot;Alice&quot;;\n    int age = 30;\n \n    std::cout &lt;&lt; &quot;Nom : &quot; &lt;&lt; nom &lt;&lt; &quot;, √¢ge : &quot; &lt;&lt; age &lt;&lt; &quot; ans.&quot; &lt;&lt; std::endl;\n    return 0;\n}\nAffiche :\nNom : Alice, √¢ge : 30 ans. suivi d‚Äôun saut de ligne.\nR√©sum√©\n\nstd::cout permet d‚Äôafficher plusieurs valeurs, encha√Æn√©es avec l‚Äôop√©rateur &lt;&lt;.\nChaque &lt;&lt; ajoute une valeur dans le flux de sortie. C‚Äôest souple, lisible et puissant pour construire dynamiquement une ligne d‚Äôaffichage.\n"},"destructeur":{"slug":"destructeur","filePath":"destructeur.md","title":"destructeur","links":[],"tags":[],"content":""},"dictionnaire-√†-cl√©-multiples":{"slug":"dictionnaire-√†-cl√©-multiples","filePath":"dictionnaire √† cl√© multiples.md","title":"dictionnaire √† cl√© multiples","links":["conteneur-associatif","STL","C++","dictionnaire","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","It√©rateur","it√©rateur"],"tags":[],"content":"\nNom anglais: multimap\nNom pleinement qualifi√©: std::multimap\n\n\nUn multimap est un conteneur associatif fourni par la STL en C++. Il permet de stocker des paires cl√©/valeur, avec la particularit√© d‚Äôautoriser plusieurs valeurs pour une m√™me cl√©, tout en maintenant un ordre tri√© sur les cl√©s.\nComme le dictionnaire, multimap repose sur un arbre binaire de recherche √©quilibr√© (typiquement un red-black tree), ce qui garantit des op√©rations en temps logarithmique (O(log n)).\nComparaison C/C++ : Un multimap est un dictionnaire tri√© avec doublons autoris√©s sur les cl√©s, adapt√© aux cas o√π une relation 1‚ÜíN (1 cl√© ‚Üí plusieurs valeurs) est n√©cessaire.\n\n\nInclude\nPour utiliser std::multimap il faut l‚Äôinclusion suivante :\n#include &lt;map&gt;\n\nEspace de nom\nLes multimaps font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::multimap\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nstd::multimap&lt;Cl√©, Valeur&gt; maMultiMap;\n \n// exemple pour une multimap int ‚Üí string :\nstd::multimap&lt;int, std::string&gt; idToNames;\nInitialisation\n‚Üí En C++98\nstd::multimap&lt;int, std::string&gt; m;\nm.insert(std::pair&lt;int, std::string&gt;(1, &quot;un&quot;));\nm.insert(std::pair&lt;int, std::string&gt;(1, &quot;eins&quot;));\nm.insert(std::pair&lt;int, std::string&gt;(2, &quot;deux&quot;));\n‚Üí En C++11 et plus\nstd::multimap&lt;int, std::string&gt; m = {\n    {1, &quot;un&quot;}, {1, &quot;eins&quot;}, {2, &quot;deux&quot;}\n};\n\n‚ö†Ô∏è L‚Äôinitialisation avec {} n‚Äôest pas disponible en C++98 car elle utilise std::initializer_list.\n\n\nImpl√©mentation interne\nUne multimap&lt;K, V&gt; encapsule :\n\nun arbre rouge-noir\ndes n≈ìuds contenant des paires &lt;cl√©, valeur&gt;\nun tri automatique des cl√©s selon operator&lt;\n\n\nContrairement √† un dictionnaire, plusieurs n≈ìuds peuvent avoir la m√™me cl√© dans un dictionnaire √† cl√© multiples.\n\n\nMultimap et m√©moire\nComme les dictionnaires map, les multimap utilisent des n≈ìuds allou√©s dynamiquement. Chaque insertion entra√Æne une allocation m√©moire.\nLes paires sont tri√©es par cl√©, mais les doublons sont conserv√©s dans l‚Äôordre d‚Äôinsertion relative.\nCela rend les performances de recherche et d‚Äôinsertion tr√®s bonnes (O(log n)), mais les acc√®s par cl√© doivent g√©rer plusieurs r√©sultats.\n\nQuand et pourquoi utiliser une multimap\nUne multimap est id√©ale quand une m√™me cl√© peut correspondre √† plusieurs valeurs. Elle est utile pour :\n\nrepr√©senter une relation 1‚ÜíN\ng√©rer des groupements par cat√©gorie\nindexer des objets non-uniques (ex : un nom qui renvoie √† plusieurs personnes)\n\nElle conserve les √©l√©ments tri√©s par cl√© et permet d‚Äôen extraire toutes les occurrences avec equal_range() ou en it√©rant depuis lower_bound().\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionsize()Nombre total de paires stock√©esempty()V√©rifie si la multimap est videcount(cl√©)Nombre d‚Äôoccurrences de la cl√©find(cl√©)It√©rateur vers la premi√®re occurrence de la cl√©equal_range(cl√©)Renvoie une paire d‚Äôit√©rateurs (d√©but, fin) pour toutes les occurrences\n\nIl n‚Äôexiste pas de operator[] sur multimap, car il ne peut pas repr√©senter une unique valeur par cl√©.\n\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptioninsert(pair)Ajoute une paire cl√©/valeur m√™me si la cl√© existe d√©j√†erase(it)Supprime l‚Äô√©l√©ment point√© par l‚Äôit√©rateurerase(cl√©)Supprime toutes les paires ayant cette cl√©clear()Vide compl√®tement la multimap\nIt√©rateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionbegin() / end()It√©rateurs du d√©but √† la fin (par cl√© croissante)rbegin() / rend()It√©rateurs invers√©s\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionoperator=Affecte une autre multimapswap()√âchange deux multimaps\n\nRemarques importantes\n\nUn dictionnaire √† cl√© multiple std::multimap permet des cl√©s dupliqu√©es, contrairement √† un dictionnaire std::map\nIl est tri√©e automatiquement par cl√©\nPas d‚Äôoperator[] car la valeur associ√©e √† une cl√© n‚Äôest pas unique\nOn acc√®de aux multiples valeurs d‚Äôune cl√© via equal_range(), lower_bound() et upper_bound()\nLes performances sont proches du dictionnaire, mais les usages sont diff√©rents : relation 1‚ÜíN\n"},"dictionnaire":{"slug":"dictionnaire","filePath":"dictionnaire.md","title":"dictionnaire","links":["conteneur","STL","C++","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","cache","it√©rateur","It√©rateur","dictionnaire-√†-cl√©-multiples"],"tags":[],"content":"\nNom anglais: map\nNom pleinement qualifi√©: std::map\n\n\nUne map est un conteneur associatif fourni par la STL en C++. Elle permet de stocker des paires cl√©/valeur, o√π chaque cl√© est unique et automatiquement tri√©e.\nLes √©l√©ments sont organis√©s selon un arbre binaire de recherche √©quilibr√© (g√©n√©ralement un red-black tree), ce qui garantit un acc√®s, une insertion et une suppression en temps logarithmique (O(log n)).\nComparaison C/C++ : Une map est l‚Äô√©quivalent C++ d‚Äôun dictionnaire, d‚Äôune table de hachage ordonn√©e, ou d‚Äôune structure associant des cl√©s √† des valeurs, avec gestion automatique du tri et des collisions.\n\n\nInclude\nPour utiliser std::map il faut l‚Äôinclusion suivante :\n#include &lt;map&gt;\n\nEspace de nom\nLes maps font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::map\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nPour d√©clarer une map il faut utiliser la syntaxe suivante :\nstd::map&lt;Cl√©, Valeur&gt; maMap;\n \n// exemple pour une map int ‚Üí string :\nstd::map&lt;int, std::string&gt; idToName;\n \n// exemple pour une map string ‚Üí float :\nstd::map&lt;std::string, float&gt; produitPrix;\n \n// exemple avec type complexe :\nstd::map&lt;std::string, std::vector&lt;int&gt; &gt; index;\nInitialisation\n‚Üí En C++98\nstd::map&lt;int, std::string&gt; m;\nm[1] = &quot;un&quot;;\nm[2] = &quot;deux&quot;;\nm.insert(std::pair&lt;int, std::string&gt;(3, &quot;trois&quot;));\n‚Üí En C++11 et plus\nstd::map&lt;int, std::string&gt; m = {\n    {1, &quot;un&quot;},\n    {2, &quot;deux&quot;},\n    {3, &quot;trois&quot;}\n};\n\n‚ö†Ô∏è L‚Äôinitialisation avec des accolades ({}) n‚Äôest pas disponible en C++98, car elle repose sur std::initializer_list.\n\n\nImpl√©mentation interne\nUne map&lt;K, V&gt; encapsule :\n\nun arbre binaire √©quilibr√© (typiquement un red-black tree)\ndes n≈ìuds contenant des paires &lt;cl√©, valeur&gt;\nun m√©canisme de tri automatique des cl√©s selon l‚Äôop√©rateur &lt;\n\n\nL‚Äôordre d‚Äôinsertion n‚Äôest pas conserv√© : les √©l√©ments sont toujours stock√©s dans l‚Äôordre croissant des cl√©s.\n\n\nMap et m√©moire\nLes std::map utilisent une structure en n≈ìuds dynamiques reli√©s par pointeurs, ce qui implique :\n\nles √©l√©ments sont dispers√©s en m√©moire\nchaque insertion/suppression implique une allocation/d√©sallocation\nles performances sont moins bonnes en parcours s√©quentiel, car le cache est peu utilis√©\n\nCependant, les op√©rations de recherche, insertion et suppression sont efficaces (O(log n)) gr√¢ce √† la structure de l‚Äôarbre.\n\nQuand et pourquoi utiliser une map\nUne map (std::map) est id√©ale lorsqu‚Äôil faut associer des cl√©s √† des valeurs tout en conservant les √©l√©ments tri√©s automatiquement selon l‚Äôordre des cl√©s. Elle garantit des op√©rations de recherche, insertion et suppression en O(log n), gr√¢ce √† son impl√©mentation en arbre rouge-noir. On l‚Äôutilise d√®s que l‚Äôacc√®s rapide aux donn√©es via une cl√© unique est n√©cessaire, comme par exemple pour :\n\ndes tables de configuration\ndes index\ndes caches\ndes comptages par cat√©gorie.\n\nElle offre √©galement un parcours ordonn√© naturel via ses it√©rateurs.\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionsize()Retourne le nombre d‚Äô√©l√©mentsempty()V√©rifie si la map est videoperator[](cl√©)Acc√®s ou insertion (valeur par d√©faut si absente)at(cl√©)Acc√®s s√©curis√© (C++11 uniquement)count(cl√©)Renvoie 1 si la cl√© existe, 0 sinonfind(cl√©)Renvoie un it√©rateur vers la cl√© si trouv√©e\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptioninsert(pair)Ajoute une paire cl√©/valeur (si la cl√© n‚Äôexiste pas d√©j√†)erase(it)Supprime l‚Äô√©l√©ment point√© par l‚Äôit√©rateurerase(cl√©)Supprime l‚Äô√©l√©ment avec la cl√© donn√©eclear()Supprime tous les √©l√©ments\nIt√©rateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionbegin() / end()It√©rateurs du d√©but √† la fin de la map (par cl√© croissante)rbegin() / rend()It√©rateurs invers√©s\n\nLes it√©rateurs permettent un parcours tri√© selon les cl√©s, utile pour des affichages ou comparaisons ordonn√©es.\n\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionoperator=Affecte une autre mapswap()√âchange deux maps\n\nRemarques importantes\n\nstd::map tri automatiquement les cl√©s √† l‚Äôaide de operator&lt;\nIl n‚Äôy a qu‚Äôune seule valeur par cl√© : insertion avec une cl√© existante ne modifie pas la valeur\noperator[] ins√®re une nouvelle paire avec une valeur par d√©faut si la cl√© n‚Äôexiste pas\nLes performances sont bonnes pour les acc√®s par cl√©, mais moins bonnes pour les scans s√©quentiels\nLes √©l√©ments ne sont pas stock√©s contigu√´s ‚Üí std::map n‚Äôest pas cache-friendly\n\n\nVariante : `std::multimap\nLa dictionnaire √† cl√© multiples est une variante de map qui permet de stocker plusieurs paires ayant la m√™me cl√©.\nElle partage la m√™me structure (arbre rouge-noir) et les m√™mes performances (O(log n)), mais :\n\nelle accepte les doublons de cl√©\nelle ne fournit pas operator[], car il n‚Äôy a pas de valeur unique par cl√©\n\nOn l‚Äôutilise dans les cas o√π une cl√© peut √™tre associ√©e √† plusieurs valeurs distinctes, comme pour repr√©senter une relation 1‚ÜíN.\n‚Üí Voir la fiche d√©di√©e dictionnaire √† cl√© multiples"},"directive-de-pr√©processeur":{"slug":"directive-de-pr√©processeur","filePath":"directive de pr√©processeur.md","title":"directive de pr√©processeur","links":["compilation","C++","inclusion-de-fichiers"],"tags":[],"content":"Qu‚Äôest-ce qu‚Äôune directive de pr√©processeur?\n\nUne directive de pr√©processeur est une instruction sp√©ciale qui est trait√©e avant la compilation du code C++.\nCes directives disent au pr√©processeur (un outil qui passe avant le compilateur) de modifier, inclure ou conditionner des parties du code avant que la compilation proprement dite commence.\n\nEn r√©sum√©\n\nElles commencent toujours par # (exemple : #include, #define).\nElles ne sont pas du code C++√† proprement parler.\nElles pr√©parent le code pour la compilation.\nElles sont invisibles dans le programme final : elles servent √† le construire correctement avant de le compiler.\n\nLes diff√©rents types de directives\n\ninclusion de fichiers\nd√©finition et suppression de macros\ndirective conditionnelle\ngestion des erreurs et avertissements\n\n2. D√©finition et suppression de macros\n‚Üí But : cr√©er ou supprimer des constantes/mots-cl√©s automatiques\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirectiveSyntaxeQue fait-elle ?#define#define NOM valeurD√©finit une macro ou une constante symbolique. Remplace NOM par valeur dans tout le code.#undef#undef NOMSupprime une macro d√©finie auparavant.\n\nüîÄ 3. Directives conditionnelles\n‚Üí But : inclure ou exclure du code selon certaines conditions\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirectiveSyntaxeQue fait-elle ?#ifdef#ifdef NOMCompile le bloc suivant seulement si NOM a √©t√© d√©fini par #define.#ifndef#ifndef NOMCompile le bloc suivant seulement si NOM n‚Äôa pas √©t√© d√©fini.#if#if conditionCompile le bloc suivant si la condition est vraie (exemple : #if VERSION &gt;= 2).#elif#elif condition‚ÄùElse if‚Äù : ajoute une condition suppl√©mentaire apr√®s un #if.#else#elseBloc alternatif si aucune condition pr√©c√©dente n‚Äôest remplie.#endif#endifMarque la fin d‚Äôun bloc conditionnel (#if, #ifdef, etc.).\n\nüö® 4. Gestion des erreurs et avertissements\n‚Üí But : g√©n√©rer des erreurs pendant le pr√©traitement\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirectiveSyntaxeQue fait-elle ?#error#error &quot;Message d&#039;erreur&quot;Force l‚Äôarr√™t de la compilation avec un message.#warning (pas standard, d√©pend du compilateur)#warning &quot;Message d&#039;avertissement&quot;Affiche un avertissement sans bloquer la compilation (support√© par gcc, clang).\n\n‚öôÔ∏è 5. Directives sp√©ciales au compilateur\n‚Üí But : donner des instructions sp√©cifiques au compilateur\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDirectiveSyntaxeQue fait-elle ?#pragma#pragma optionPasse une commande sp√©cifique au compilateur (exemple : #pragma once pour √©viter les doubles inclusions).\n\nüß† √Ä retenir globalement :\n\n\n#include ‚Üí pour ajouter du code externe.\n\n\n#define, #undef ‚Üí pour d√©finir ou supprimer des macros/constantes.\n\n\n#if, #ifdef, #ifndef‚Ä¶ ‚Üí pour faire du code conditionnel.\n\n\n#pragma ‚Üí pour donner des ordres sp√©ciaux au compilateur.\n\n\n#error, #warning ‚Üí pour contr√¥ler le comportement en cas de probl√®me.\n\n\n\nüìã Petit r√©sum√© ultra rapide par familles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFamilleExemplesInclusion#includeMacro#define, #undefConditions#if, #ifdef, #ifndef, #elif, #else, #endifErreurs#error, #warningSp√©cial compilateur#pragma\n\nVeux-tu aussi que je te pr√©pare un tableau final ‚Äúcomplet pr√™t √† copier‚Äù que tu pourrais int√©grer directement dans ton vault Obsidian‚ÄØ? üöÄ\n(Je peux aussi te proposer un exemple typique d‚Äôutilisation combin√©e de plusieurs directives si tu veux !)\n√Ä retenir\n\nLe pr√©processeur lit le fichier, ex√©cute toutes les directives #..., puis produit un nouveau fichier pr√™t pour la compilation.\nC‚Äôest comme pr√©parer une recette avant de commencer √† cuisiner : rassembler les ingr√©dients (#include), ajuster la recette (#define), conditionner certaines √©tapes (#ifdef‚Ä¶).\n"},"dur√©e-de-vie-des-objets":{"slug":"dur√©e-de-vie-des-objets","filePath":"dur√©e de vie des objets.md","title":"dur√©e de vie des objets","links":["C++","objet","constructeur","destructeur","allocation-dynamique-de-la-m√©moire","compilateur","pile","tas","bloc","fonction","/","membre-statique","C++11"],"tags":[],"content":"\nNom anglais: object lifetime\n\n\nLa dur√©e de vie d‚Äôun objet en C++ d√©signe la p√©riode pendant laquelle cet objet existe en m√©moire et peut √™tre utilis√©.\nElle commence √† sa cr√©ation (appel du constructeur) et se termine √† sa destruction (appel du destructeur).\nComparaison C/C++ : En C, la gestion m√©moire est manuelle. En C++, la dur√©e de vie peut √™tre automatique (g√©r√©e par le langage) ou dynamique lors d‚Äôune allocation dynamique de la m√©moire (g√©r√©e par le programmeur via new / delete).\n\n\nDur√©e de vie automatique\nEn C++, lorsqu‚Äôon ne fait pas d‚Äôallocation dynamique de la m√©moire avec new, les objets sont g√©n√©ralement :\nAutomatiques\n\nCela signifie qu‚Äôils sont cr√©√©s automatiquement par le compilateur au moment o√π ils entrent en port√©e, sans avoir besoin d‚Äôallocation manuelle.\nLeur dur√©e de vie est g√©r√©e par le langage, sans new ni delete.\n\nD√©clar√©s sur la pile (stack)\n\nCes objets sont stock√©s dans la m√©moire de la pile (stack), une zone rapide et locale √† chaque fonction.\nContrairement au tas (heap), la pile est lib√©r√©e automatiquement √† la fin du bloc.\n\nD√©truits automatiquement √† la fin du bloc\n\nD√®s que le bloc {} dans lequel l‚Äôobjet a √©t√© cr√©√© se termine, le destructeur est automatiquement appel√©, et la m√©moire est lib√©r√©e.\nC‚Äôest ce qu‚Äôon appelle la dur√©e de vie automatique.\n\nExemple concret\nvoid fonction() {\n    MaClasse obj;  // constructeur appel√© ici\n} // ‚Üê destructeur appel√© ici automatiquement\nDans cet exemple le destructeur sera appel√© automatiquement √† la fin de la fonction. L‚Äôobjetobj ne pourra donc pas √™tre utilis√© au-del√† de la fonction dans laquelle il a √©t√© d√©clar√©.\nvoid fonction() {\n    MaClasse obj;  // constructeur appel√© ici\n} // destructeur appel√© ici automatiquement\n\nDur√©e de vie dynamique\nA l‚Äôinverse, lorsqu‚Äôun objet est cr√©√© par allocation dynamique de la m√©moire avec l‚Äôop√©rateur new, il est dit :\nDynamique\n\nCela signifie que sa m√©moire est r√©serv√©e manuellement sur le tas (heap) √† l‚Äôex√©cution, via new.\nIl n‚Äôest pas lib√©r√© automatiquement √† la fin d‚Äôun bloc : c‚Äôest au programmeur d‚Äôappeler delete.\n\nAllou√© sur le tas (heap)\n\nCes objets sont stock√©s sur le tas, une zone m√©moire con√ßue pour les allocations manuelles.\nContrairement √† la pile (stack), la m√©moire du tas persiste apr√®s la fin du bloc.\n\nPersistant jusqu‚Äô√† destruction manuelle\n\nL‚Äôobjet cr√©√© avec new continue d‚Äôexister jusqu‚Äô√† ce que le programme appelle explicitement delete (ou delete[] pour les tableaux).\nSi on oublie de lib√©rer la m√©moire, on provoque une fuite m√©moire.\n\nExemple concret\nvoid fonction() {\n    MaClasse* ptr = new MaClasse();  // constructeur appel√© ici\n    // ...\n    delete ptr;                      // destructeur appel√© ici manuellement\n}\nDans cet exemple, l‚Äôobjet est valide au-del√† de la fonction, tant que ptr est conserv√©. Mais si delete est oubli√©, la m√©moire ne sera jamais lib√©r√©e.\n\nCas particulier : objet statique\n\nUn objet d√©clar√© avec le mot-cl√© static (dans une fonction ou un bloc) ne sera construit qu‚Äôune seule fois et d√©truit √† la fin du programme.\nCela vaut aussi pour les variables globales ou les membres static.\n\nvoid f() {\n    static Compteur c; // construit √† la premi√®re ex√©cution\n} // d√©truit √† la fin du programme\n‚Üí Voir aussi : membre statique\n\nR√©sum√© comparatif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType de dur√©e de vieCr√©ationDestructionStockageExempleAutomatiqueentr√©e dans le blocfin du blocpileMaClasse obj;Dynamiquenewdeletetasnew MaClasse;Statiqueau premier usage√† la fin du programmestatiquestatic MaClasse obj;\n\nBonnes pratiques\n\nPrivil√©gier la dur√©e automatique quand c‚Äôest possible (plus s√ªre, g√©r√©e par le langage)\nNe pas oublier de lib√©rer les objets dynamiques (delete) pour √©viter les fuites m√©moire.\n√Ä partir de C++11, pr√©f√©rer l‚Äôusage de smart pointers (std::unique_ptr, std::shared_ptr) pour g√©rer automatiquement la dur√©e de vie dynamique\n\n\nVoir aussi\n‚Üí objet, constructeur, destructeur\n‚Üí pile, tas, bloc\n‚Üímembre statique"},"d√©bogage":{"slug":"d√©bogage","filePath":"d√©bogage.md","title":"d√©bogage","links":[],"tags":[],"content":"\nQu‚Äôest-ce que?"},"d√©claration-anticip√©e":{"slug":"d√©claration-anticip√©e","filePath":"d√©claration anticip√©e.md","title":"d√©claration anticip√©e","links":["classe","compilation","C++"],"tags":[],"content":"\nNom anglais: forward declaration\n\n\nUne d√©claration anticip√©e (forward declaration) permet d‚Äôannoncer l‚Äôexistence d‚Äôune classe, d‚Äôune struct, ou d‚Äôune fonction avant sa d√©finition compl√®te. Cela aide √† r√©duire les d√©pendances et √† acc√©l√©rer la compilation.\nComparaison C/C++ : Le C utilise d√©j√† les d√©clarations anticip√©es pour les fonctions. En C++, elles sont aussi tr√®s utilis√©es pour les classes.\n\nPourquoi utiliser une d√©claration anticip√©e?\nLes forward declarations permettent :\n\nd‚Äôannoncer un type sans inclure son d√©tail,\nde r√©duire le couplage entre fichiers,\nd‚Äôacc√©l√©rer la compilation en limitant les inclusions inutiles.\n\nD√©finir une d√©claration anticip√©e\nExemple pour une classe :\nclass Moteur; // d√©claration anticip√©e\n \nclass Voiture\n{\nprivate:\n    Moteur* moteur; // pointeur vers Moteur\n};\nIci, on annonce Moteur sans avoir besoin de sa d√©finition compl√®te.\nAttention : on ne peut utiliser qu‚Äôun pointeur ou une r√©f√©rence tant qu‚Äôon n‚Äôa pas la d√©finition compl√®te.\nR√©sum√©\nLa forward declaration sert √† pr√©parer le compilateur √† rencontrer un type sans le charger imm√©diatement."},"encapsulation":{"slug":"encapsulation","filePath":"encapsulation.md","title":"encapsulation","links":["programmation-orient√©e-objet","objet","attribut","m√©thode","accesseur","mutateur","classe","priv√©","publique"],"tags":[],"content":"\nNom anglais: encapsulation\n\n\nL‚Äôencapsulation est un principe fondamental de la programmation orient√©e objetqui consiste √† prot√©ger les donn√©es internes d‚Äôun objet en limitant l‚Äôacc√®s direct √† ses attributs. Elle impose de passer par des m√©thodes (accesseurs et mutateurs) pour interagir avec l‚Äôobjet.\nComparaison avec le C: En C, les membres des structures sont accessibles librement. En C++, gr√¢ce √† l‚Äôencapsulation, on peut cacher l‚Äôimpl√©mentation interne et contr√¥ler l‚Äôacc√®s.\n\nPourquoi utiliser l‚Äôencapsulation\nL‚Äôencapsulation permet :\n\nde prot√©ger les attributs contre les acc√®s ou modifications non d√©sir√©s,\nde forcer un contr√¥le via des m√©thodes (accesseurs, mutateurs),\nde simplifier l‚Äôusage d‚Äôun objet en cachant sa complexit√© interne,\nde rendre possible l‚Äô√©volution de la classe sans casser son utilisation par les autres parties du programme.\n\nEncapsulation et sections d‚Äôacc√®s\nOn r√©alise l‚Äôencapsulation en utilisant les sections d‚Äôacc√®s :\n\npartie priv√©e (private) pour cacher les donn√©es sensibles,\npartie publique (public) pour exposer uniquement ce qui est n√©cessaire.\n\nExemple :\nclass Voiture\n{\nprivate:\n    int vitesse; // cach√©\n \npublic:\n    int getVitesse() const; // expos√© de fa√ßon contr√¥l√©e\n    void setVitesse(int v); // modifiable sous conditions\n};\nR√©sum√©\nL‚Äôencapsulation repose sur deux id√©es simples :\n\nCacher les d√©tails d‚Äôimpl√©mentation.\nExposer une interface simple et s√©curis√©e pour utiliser l‚Äôobjet.\n"},"endl":{"slug":"endl","filePath":"endl.md","title":"endl","links":["Nom-pleinement-qualifi√©","manipulateur-de-flux","cout","tampon-de-sortie","flush","C++"],"tags":[],"content":"\nNom pleinement qualifi√©: std::endl\n\n\nstd::endl est un manipulateur de fluxutilis√© avec std::cout (voir cout) pour ins√©rer un saut de ligne (\\n) et forcer l‚Äôaffichage imm√©diat en vidant le tampon de sortie (flush).\nComparaison C/C++ : En C, on √©crit \\n dans une cha√Æne. En C++, std::endl a un effet suppl√©mentaire : il vide le tampon de sortie, ce qui peut √™tre utile pour garantir l‚Äôaffichage imm√©diat.\n\nSaut de ligne et affichage\nQuand on √©crit :\nstd::cout &lt;&lt; &quot;Bonjour&quot; &lt;&lt; std::endl;\ncela fait deux choses :\n\nAjoute un retour √† la ligne (comme \\n)\nVide le tampon de sortie (flush)\n\nComparaison avec \\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n√âcritureComportement\\nAjoute un saut de ligne, ne flush pas le tamponstd::endlSaut de ligne et flush (affichage imm√©diat)\nR√©sum√©\n\nstd::endl est un manipulateur de flux qui :\n\najoute un saut de ligne\nvide le tampon de sortie (= flush)\nIl garantit que l‚Äôaffichage a bien lieu tout de suite.\n\n"},"ensemble-avec-doublons":{"slug":"ensemble-avec-doublons","filePath":"ensemble avec doublons.md","title":"ensemble avec doublons","links":["conteneur-associatif","conteneur-standard-de-la-STL","STL","C++","ensemble","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","vecteur","it√©rateur","It√©rateur"],"tags":[],"content":"\nNom anglais: multiset\nNom pleinement qualifi√©: std::multiset\n\n\nUn ensemble avec doublons multiset est un conteneur associatif faisant partie des conteneur standard de la STL fourni par la STL en C++. Il permet de stocker une collection de valeurs tri√©es, tout en autorisant les doublons.\nComme l‚Äôensemble set, les √©l√©ments sont organis√©s dans un arbre binaire de recherche √©quilibr√© (typiquement un arbre rouge-noir), ce qui permet des op√©rations de recherche, insertion et suppression en O(log n).\nComparaison C/C++ : Un multiset est un ensemble tri√© o√π les doublons sont accept√©s. C‚Äôest l‚Äô√©quivalent d‚Äôun ensemble set non strictement injectif.\n\n\nInclude\nPour utiliser std::multiset il faut l‚Äôinclusion suivante :\n#include &lt;set&gt;\n\nEspace de nom\nLes ensembles avec doublons multiset font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::multiset\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nstd::multiset&lt;Type&gt; monMultiSet;\n \n// exemple :\nstd::multiset&lt;int&gt; ensembleValeurs;\nstd::multiset&lt;std::string&gt; motsAvecDoublons;\nInitialisation\n‚Üí En C++98\nstd::multiset&lt;int&gt; s;\ns.insert(3);\ns.insert(1);\ns.insert(3); // accept√©\ns.insert(2);\n‚Üí En C++11 et plus\nstd::multiset&lt;int&gt; s = {3, 1, 3, 2};\n\n‚ö†Ô∏è L‚Äôinitialisation avec {} n‚Äôest pas disponible en C++98, car elle repose sur std::initializer_list.\n\n\nImpl√©mentation interne\nUn ensemble avec doublons multiset&lt;T&gt; encapsule :\n\nun arbre rouge-noir\ndes n≈ìuds contenant uniquement des valeurs\nun tri automatique par operator&lt;, m√™me en cas de valeurs dupliqu√©es\n\n\nContrairement √† l‚Äôensembleset, les doublons sont conserv√©s et peuvent coexister dans l‚Äôarbre.\n\n\nEnsembles avec doublons et m√©moire\nChaque √©l√©ment, m√™me dupliqu√©, est stock√© dans un n≈ìud distinct, allou√© dynamiquement.\nLes valeurs sont tri√©es mais pas modifiables, car cela compromettrait l‚Äôordre interne.\nLa m√©moire est donc plus fragment√©e que dans un vecteur vector, mais l‚Äôacc√®s tri√© est plus rapide.\n\nQuand et pourquoi utiliser un ensemble avec doublons\nLe multiset est utile lorsque :\n\nles doublons sont significatifs (ex : histogrammes, logs, relev√©s)\non souhaite compter ou classer des √©l√©ments automatiquement\non a besoin de conserver les √©l√©ments dans un ordre tri√©, m√™me s‚Äôils sont r√©p√©t√©s\n\nIl s‚Äôadapte √† de nombreuses situations d‚Äôanalyse, de tri partiel ou de regroupement.\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionsize()Nombre total d‚Äô√©l√©ments (y compris les doublons)empty()V√©rifie si le multiset est videcount(val)Nombre d‚Äôoccurrences de valfind(val)Renvoie un it√©rateur vers la premi√®re occurrence de val\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptioninsert(val)Ajoute val, m√™me si elle est d√©j√† pr√©senteerase(val)Supprime toutes les occurrences de valerase(it)Supprime un seul √©l√©ment point√© par l‚Äôit√©rateurclear()Vide compl√®tement le multiset\nIt√©rateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionbegin() / end()It√©rateurs de d√©but √† fin (ordre tri√©)rbegin() / rend()It√©rateurs invers√©s\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionoperator=Affecte un autre multisetswap()√âchange deux multisets\n\nRemarques importantes\n\nContrairement √† l‚Äôensemble set, le multiset autorise plusieurs occurrences de la m√™me valeur\nLes √©l√©ments sont tri√©s automatiquement\nIl n‚Äôy a pas de suppression automatique des doublons\nOn peut parcourir les occurrences avec equal_range(), lower_bound() et upper_bound()\nLes performances sont √©quivalentes √† celles de set, avec plus de flexibilit√© sur les doublons\n"},"ensemble":{"slug":"ensemble","filePath":"ensemble.md","title":"ensemble","links":["conteneur-associatif","conteneur-standard-de-la-STL","C++","STL","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","dictionnaire","cache","vecteur","it√©rateur","It√©rateur","set","ensemble-avec-doublons"],"tags":[],"content":"\nNom anglais: set\nNom pleinement qualifi√©: std::set\n\n\nUn set est un conteneur associatif qui fait parti des conteneur standard de la STL en C++. Il permet de stocker une collection de valeurs uniques, automatiquement tri√©es selon l‚Äôordre d√©fini par operator&lt;.\nLes √©l√©ments sont organis√©s dans un arbre binaire de recherche √©quilibr√© (typiquement un arbre rouge-noir), ce qui garantit des op√©rations de recherche, insertion et suppression en O(log n).\nComparaison C/C++ : Un set correspond √† un ensemble math√©matique : valeurs sans doublons, ordre d√©fini, et recherche rapide.\n\n\nInclude\nPour utiliser std::set il faut l‚Äôinclusion suivante :\n#include &lt;set&gt;\n\nEspace de nom\nLes ensembes set font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::set\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nstd::set&lt;Type&gt; monSet;\n \n// exemple :\nstd::set&lt;int&gt; ensembleEntiers;\nstd::set&lt;std::string&gt; ensembleMots;\nInitialisation\n‚Üí En C++98\nstd::set&lt;int&gt; s;\ns.insert(3);\ns.insert(1);\ns.insert(2);\ns.insert(3); // ignor√© (doublon)\n‚Üí En C++11 et plus\nstd::set&lt;int&gt; s = {3, 1, 2, 3}; // doublon ignor√© automatiquement\n\n‚ö†Ô∏è L‚Äôinitialisation avec {} n‚Äôest pas disponible en C++98, car elle n√©cessite std::initializer_list.\n\n\nImpl√©mentation interne\nUn set&lt;T&gt; encapsule :\n\nun arbre rouge-noir triant automatiquement les √©l√©ments\nune valeur unique par n≈ìud\nune logique d‚Äôordre strict (operator&lt;) entre √©l√©ments\n\n\nL‚Äôensemble set est un dictionnaire map sans valeur associ√©e : chaque √©l√©ment est √† la fois la cl√© et la valeur.\n\n\nEnsemble et m√©moire\nChaque √©l√©ment est stock√© dans un n≈ìud allou√© dynamiquement, avec pointeurs vers ses voisins dans l‚Äôarbre.\nL‚Äôordre est garanti, mais les √©l√©ments ne sont pas contigus en m√©moire, donc les performances cache sont moindres.\nL‚Äôallocation est plus co√ªteuse que dans un vecteur vector, mais permet des op√©rations efficaces sur les √©l√©ments tri√©s et sans doublon.\n\nQuand et pourquoi utiliser un ensemble\nUn ensemble set est id√©al pour stocker des √©l√©ments uniques tri√©s automatiquement.\nIl convient parfaitement pour :\n\n√©liminer les doublons\nfaire des tests d‚Äôappartenance rapides\nparcourir des donn√©es dans l‚Äôordre\nimpl√©menter des ensembles math√©matiques ou des index tri√©s\n\nSa performance en O(log n) le rend utile m√™me pour de grands volumes de donn√©es.\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionsize()Nombre d‚Äô√©l√©ments pr√©sentsempty()V√©rifie si l‚Äôensemble est videcount(val)Retourne 1 si la valeur est pr√©sente, 0 sinonfind(val)Renvoie un it√©rateur vers la valeur si trouv√©e\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptioninsert(val)Ajoute val si elle n‚Äôest pas d√©j√† pr√©senteerase(val)Supprime val si elle est pr√©senteerase(it)Supprime l‚Äô√©l√©ment point√© par l‚Äôit√©rateurclear()Vide compl√®tement l‚Äôensemble\nIt√©rateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionbegin() / end()It√©rateurs de d√©but √† fin (ordre tri√©)rbegin() / rend()It√©rateurs invers√©s\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionoperator=Affecte un autre setswap()√âchange deux ensembles\n\nRemarques importantes\n\nLes √©l√©ments sont uniques et tri√©s automatiquement\nL‚Äôinsertion d‚Äôun √©l√©ment d√©j√† pr√©sent n‚Äôa aucun effet\nLes √©l√©ments ne sont pas modifiables en place (car cela compromettrait le tri)\nset est efficace pour les tests d‚Äôappartenance et les op√©rations d‚Äôensemble (intersection, union‚Ä¶)\n\n\nVariante : std::multiset\nLa std::multiset est une variante de set qui permet de stocker plusieurs occurrences identiques d‚Äôun m√™me √©l√©ment tout en conservant un ordre tri√©.\nElle repose sur la m√™me structure (arbre rouge-noir), avec les m√™mes performances (O(log n)), mais :\n\nelle autorise les doublons\nelle compte toutes les occurrences d‚Äôune m√™me valeur\nelle est utile pour repr√©senter un ensemble non strict, comme une collection tri√©e avec r√©p√©titions\n\nLes fonctions count(), equal_range() et les it√©rateurs permettent de naviguer efficacement parmi les doublons.\n‚Üí Voir la fiche d√©di√©e: ensemble avec doublons"},"espace-de-noms":{"slug":"espace-de-noms","filePath":"espace de noms.md","title":"espace de noms","links":["C++","classe","fonction","biblioth√®que","biblioth√®que-standard-C++","compilation"],"tags":[],"content":"\nNom anglais: namespace\n\n\nUn espace de noms (ou namespace) permet en C++ de regrouper des noms (de fonctions, variables, classes, etc.) sous une m√™me ‚Äú√©tiquette‚Äù pour √©viter les conflits entre diff√©rents morceaux de code.\nEn clair, les namespaces permettent d‚Äôutiliser des fonctions, classes ou types (provenant de biblioth√®ques diff√©rentes) mais ayant le m√™me nom sans cr√©er de conflit.\nComparaison C/C++ : En C, tous les noms sont globaux. En C++, les espaces de noms permettent de mieux organiser le code et de g√©rer les collisions de noms.\n\nPourquoi utiliser un namespace\nLes namespace sont utiles pour :\n\n√©viter les conflits de noms entre biblioth√®ques,\norganiser le code (par module, par fonctionnalit√©),\ncr√©er des √©l√©ments qui portent le m√™me nom, mais dans des contextes diff√©rents.\n\nD√©clarer un namespace\nExemple pour cr√©er l‚Äôespace de nom monEspace :\nnamespace monEspace\n{\n    void afficher();\n    class Voiture;\n    int compteur;\n}\nOn peut ensuite acc√©der aux √©l√©ments avec le pr√©fixe monEspace:: :\nmonEspace::afficher();\nLe namespace std\nTous les √©l√©ments de la biblioth√®que standard C++ (comme cout, cin, string, vector, etc.) se trouvent dans le namespace std.\nC‚Äôest pourquoi on √©crit :\nstd::cout &lt;&lt; &quot;Bonjour&quot;;\nLa directive using namespace\nPour √©viter d‚Äô√©crire std:: partout, on peut utiliser la directive :\nusing namespace std;\n\nCette directive se place g√©n√©ralement :\n\njuste apr√®s les #include\nou avant le main() ou dans une fonction sp√©cifique, selon ton besoin\nMais surtout pas dans les headers, les biblioth√®ques ou les fichiers partag√©s √† grande √©chelle.\n\n\nCela permet d‚Äôacc√©der directement aux √©l√©ments sans pr√©fixe :\ncout &lt;&lt; &quot;Bonjour&quot;; // fonctionne sans std::\n\n‚ö†Ô∏è Cette directive est pratique pour les petits programmes ou pour apprendre, mais d√©conseill√©e dans les projets s√©rieux (risques de conflit entre noms identiques dans diff√©rents namespace).\n\nExemple concret\nContexte du probl√®me (sans namespace)\nImaginons deux biblioth√®ques diff√©rentes, LibMath et LibPhysique, qui contiennent toutes les deux une fonction calcul() :\n// Dans LibMath\nvoid calcul()\n{\n    std::cout &lt;&lt; &quot;Calcul math√©matique&quot; &lt;&lt; std::endl;\n}\n \n// Dans LibPhysique\nvoid calcul()\n{\n    std::cout &lt;&lt; &quot;Calcul physique&quot; &lt;&lt; std::endl;\n}\nSi on inclut ces deux biblioth√®ques sans namespace, on obtient une erreur de compilation :\n\n‚ùå ‚Äúla fonction calcul est d√©finie deux fois‚Äù.\n\nSolution avec des namespace\nnamespace LibMath\n{\n    void calcul()\n    {\n        std::cout &lt;&lt; &quot;Calcul math√©matique&quot; &lt;&lt; std::endl;\n    }\n}\n \nnamespace LibPhysique\n{\n    void calcul()\n    {\n        std::cout &lt;&lt; &quot;Calcul physique&quot; &lt;&lt; std::endl;\n    }\n}\nDans le code principal, on peut maintenant faire la distinction :\nLibMath::calcul();     // Affiche &quot;Calcul math√©matique&quot;\nLibPhysique::calcul(); // Affiche &quot;Calcul physique&quot;\nPlus de conflit, car les fonctions sont maintenant dans des espaces de noms s√©par√©s.\n\nEn r√©sum√© : si deux biblioth√®ques d√©finissent une fonction calcul(), un conflit appara√Æt.\nEn les pla√ßant dans namespace LibMath et namespace LibPhysique, on peut appeler LibMath::calcul() et LibPhysique::calcul() sans collision.\n"},"ex00":{"slug":"ex00","filePath":"ex00.md","title":"ex00","links":["objet","C++","allocation-dynamique-de-la-m√©moire","classe","pile","tas"],"tags":[],"content":"\nCe premier exercice a pour objectif de nous faire comprendre la notion de port√©e d‚Äôun objet en C++ ‚Äî c‚Äôest-√†-dire o√π et combien de temps un objet existe dans le programme ‚Äî, ainsi que de nous faire manipuler l‚Äôallocation dynamique de la m√©moire, une technique essentielle pour cr√©er des objets qui survivent au-del√† d‚Äôun bloc ou d‚Äôune fonction.\n\nLa pile (stack) et le tas (heap)\nCet exercice nous am√®ne √† cr√©er une classe, puis deux fonctions qui retourneront un objet de cette classe :\n\nl‚Äôune en d√©clarant l‚Äôobjet sur la pile\nl‚Äôautre en allouant l‚Äôobjet sur le tas\n\n‚Üí Pour impl√©menter cette seconde version, il faudra nous familiariser avec l‚Äôallocation dynamique de la m√©moire en C++ (new, delete, etc).\nPort√©e d‚Äôun objet en C++\nPar d√©faut, un objet d√©clar√© sans new poss√®de une dur√©e de vie limit√©e au bloc ({}) dans lequel il a √©t√© cr√©√©.\nIl est automatiquement d√©truit √† la fin de ce bloc, ce qui implique que l‚Äôobjet retourn√© par une fonction ne sera plus valide une fois la fonction termin√©e.\nVous pourrez le constater en ajoutant un message dans le destructeur : celui-ci s‚Äôex√©cutera imm√©diatement √† la fin de la fonction, et non √† la fin du programme.\n‚Üí Pour utiliser un objet au-del√† du bloc dans lequel il a √©t√© cr√©√©, on doit recourir √† l‚Äôallocation dynamique de la m√©moire.\nL‚Äôobjet cr√©√© dans la deuxi√®me fonction (celle qui utilise new) continuera d‚Äôexister en dehors de la fonction et ne sera d√©truit qu‚Äô√† la fin du programme (ou lorsqu‚Äôon appelle explicitement delete).\n‚Üí N‚Äôoubliez pas d‚Äôutiliser explicitement delete sur l‚Äôobjet qui a √©t√© allou√© dynamiquement avant de quitter le programme pour √©viter les fuites de m√©moire."},"ex01":{"slug":"ex01","filePath":"ex01.md","title":"ex01","links":["C++","allocation-dynamique-de-la-m√©moire"],"tags":[],"content":"\nCet exercice rapide vise √† nous faire d√©couvrir l‚Äôutilisation de new[] et delete[].\n\nAllocation et lib√©ration de tableaux\nEn C++, il est possible d‚Äôeffectuer une allocation dynamique de la m√©moire sur un tableau entier en une seule ligne, en utilisant l‚Äôop√©rateur new[] :\nint* tableau = new int[10];\nPour lib√©rer correctement la m√©moire ainsi allou√©e, il faut utiliser delete[] :\ndelete[] tableau;\n‚Üí Ne jamais utiliser delete seul pour un tableau allou√© avec new[] ‚Äî cela entra√Ænerait un comportement ind√©fini."},"ex02":{"slug":"ex02","filePath":"ex02.md","title":"ex02","links":["r√©f√©rence","C++","pointeur"],"tags":[],"content":"\nCet exercice a pour but de nous faire d√©couvrir les r√©f√©rences en C++ et de comprendre la diff√©rence entre :\n\nle passage par valeur\nle passage par pointeur\nle passage par r√©f√©rence\n\n\nPassage par valeur\n\nLa fonction re√ßoit une copie de la variable: Toute modification s‚Äôapplique √† la copie, pas √† l‚Äôoriginal.\n\nvoid increment(int n) {\n\tn = n + 1;  // on modifie une copie\n}\n \nint main() {\n\tint nbr = 2;\n\tincrement(nbr);\n\tstd::cout &lt;&lt; nbr &lt;&lt; std::endl; // affiche 2\n}\n‚Üí Ici, nbr reste √† 2, car la fonction a travaill√© sur une copie temporaire.\nPassage par pointeur\n\nAvec le pointeur, la fonction re√ßoit l‚Äôadresse de la variable.\nEn d√©r√©f√©ren√ßant le pointeur (*), elle peut modifier directement la valeur d‚Äôorigine.\n\nvoid increment(int* n) {\n\t*n = *n + 1;  // on modifie la valeur point√©e\n}\n \nint main() {\n\tint nbr = 2;\n\tincrement(&amp;nbr);\n\tstd::cout &lt;&lt; nbr &lt;&lt; std::endl; // affiche 3\n}\n‚Üí Il faut appeler la fonction avec &amp;nbr pour passer l‚Äôadresse de la variable.\nPassage par r√©f√©rence\n\nLa fonction re√ßoit une r√©f√©rence (un alias) de la variable: Elle peut la modifier comme si elle travaillait sur l‚Äôoriginal, sans syntaxe de pointeur.\n\nvoid increment(int&amp; n) {\n\tn = n + 1;\n}\n \nint main() {\n\tint nbr = 2;\n\tincrement(nbr);\n\tstd::cout &lt;&lt; nbr &lt;&lt; std::endl; // affiche 3\n}\n‚Üí Pas besoin de &amp; ou * √† l‚Äôusage, la syntaxe reste simple et naturelle.\nR√©sum√© comparatif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFormeModifie la variable d‚Äôorigine ?Syntaxe simplePeut passer nullptr ?Par valeur‚ùå Non‚úÖ Oui‚úÖ Sans int√©r√™tPar pointeur‚úÖ Oui (avec *)‚ùå Non‚úÖ OuiPar r√©f√©rence‚úÖ Oui‚úÖ Oui‚ùå Non"},"ex03":{"slug":"ex03","filePath":"ex03.md","title":"ex03","links":["r√©f√©rence","pointeur","toute","objet"],"tags":[],"content":"\nCet exercice a pour but de nous faire manipuler les r√©f√©rences (vues √† l‚Äôexercice pr√©c√©dent), de comprendre leurs diff√©rences par rapport aux pointeurs, et de savoir quand et pourquoi utiliser l‚Äôun ou l‚Äôautre.\n\nVous avez d√©j√† √† ce stade toutes les notions n√©cessaires pour r√©aliser l‚Äôexercice.\nGardez en t√™te que :\nPassage par r√©f√©rence\n\nSi je d√©clare une variable, puis que je la passe par r√©f√©rence √† un objet, toute modification de cette variable se refl√®tera imm√©diatement dans l‚Äôobjet, car ils partagent la m√™me donn√©e.\nInversement, si je modifie la variable depuis l‚Äôobjet qui d√©tient une r√©f√©rence sur elle, alors la variable d‚Äôorigine sera √©galement modifi√©e.\n\nPassage par pointeur\nLe comportement est tr√®s similaire √† une r√©f√©rence :\nSi je passe un pointeur vers une variable, et que l‚Äôobjet stocke ce pointeur, alors :\n\nmodifier la variable √† travers le pointeur la modifie bien √† l‚Äôext√©rieur\net modifier la variable d‚Äôorigine (hors de l‚Äôobjet) sera visible dans l‚Äôobjet\n\nMais attention :\n\nIl faut d√©r√©f√©rencer (*) le pointeur pour acc√©der √† la valeur\nIl est possible de changer le pointeur pour qu‚Äôil pointe ailleurs\nIl est possible d‚Äôavoir un pointeur nul, ce qui n‚Äôest pas possible avec une r√©f√©rence\n"},"ex04":{"slug":"ex04","filePath":"ex04.md","title":"ex04","links":["manipulation-de-fichier","string","biblioth√®que-standard-C++","C++98","stat","C++","flux","ifstream","ofstream"],"tags":[],"content":"\nCet exercice a pour but de nous faire d√©couvrir les bases de la manipulation de fichier en C++.\n\nContr√¥les d‚Äôusage\nIl nous faut en premier lieu effectuer les contr√¥les d‚Äôusage dans notre programme:\nV√©rifier le nombre d‚Äôarguments\n\nIl faut d‚Äôabord v√©rifier que le nombre d‚Äôarguments saisis au lancement du programme correspond au nombre attendu.\n\nV√©rifier que la chaine de caract√®re √† remplacer soit non nulle\n\nIl faut ensuite v√©rifier que la cha√Æne de caract√®re √† remplacer ne soit pas nulle (sous peine d‚Äôentrer dans une boucle infinie).\n\nL‚Äôobjet de type string de la biblioth√®que standard C++ dispose d‚Äôune m√©thode parfaite pour cela:\n‚Üí empty() renvoie un bool√©en  (true si la chaine est vide)\nPour utiliser cette m√©thode, il suffit de cr√©er un string √† partir de l‚Äôargument pass√© en entr√©e (car cette argument est un type char *) puis de tester:\nstd::string argument2(argv[2]);\nif (argument2.empty())\n   // retourner une erreur\nV√©rifier que le fichier √† ouvrir ne soit pas un r√©pertoire\n\nIl faut v√©rifier que le fichier pass√© en argument ne soit pas un r√©pertoire. En effet, si ouvre un r√©pertoire √† la place d‚Äôun fichier, tester si l‚Äôouverture a r√©ussi ne sera pas suffisant (car l‚Äôouverture r√©ussira).\n\nEn C++98, nous ne pouvons pas utiliser std::filesystem. Il nous faut donc utiliser une fonction de la biblioth√®que  :\n‚Üí stat de la biblioth√®que sys/stat.h\nManipuler les fichiers\nLa manipulation des fichiers en C++passe par l‚Äôutilisation de flux:\n\nPour lire un fichier on utilise ifstream\nPour √©crire dans un fichier on utilise ofstream\n"},"fichier-binaire":{"slug":"fichier-binaire","filePath":"fichier binaire.md","title":"fichier binaire","links":["/","syst√®me-d‚Äôexploitation","compilateur","code-source"],"tags":[],"content":"\nnom anglais: binary file\n\n\nUn fichier binaire (ou ex√©cutable) est un fichier contenant des donn√©es cod√©es directement en langage machine (des 0 et des 1), que l‚Äôordinateur peut lire et ex√©cuter sans avoir besoin de comprendre le code source.\n\nDans le contexte de la compilation, c‚Äôest le r√©sultat final du travail du compilateur: un fichier pr√™t √† √™tre lanc√© par le syst√®me d‚Äôexploitation.\nEn r√©sum√© :\n\nC‚Äôest ce que produit un compilateur √† partir du code source.\nIl est compos√© d‚Äôinstructions machines que le processeur comprend directement.\nIllisible pour un humain sans outils sp√©ciaux.\n\nExemples de fichiers binaires\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlateformeExemple de binaireWindowsprogramme.exeLinux/Mac./programme (sans extension)\nPourquoi un fichier binaire?\n\nPour ex√©cuter rapidement un programme sans besoin du code source.\nPour prot√©ger le code source(l‚Äôutilisateur n‚Äôa acc√®s qu‚Äô√† la version machine).\nPour optimiser la vitesse d‚Äôex√©cution (car tout est d√©j√† ‚Äúpr√©-dig√©r√©‚Äù pour la machine).\n"},"file-FIFO":{"slug":"file-FIFO","filePath":"file FIFO.md","title":"file FIFO","links":["conteneur-adaptateur","conteneur-standard-de-la-STL","C++","conteneur-s√©quentiel","it√©rateur","STL","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","adaptateur-de-conteneur","file-double","liste","conteneur"],"tags":[],"content":"\nNom anglais: queue\nNom pleinement qualifi√©: std::queue\n\n\nUne queue est un conteneur adaptateur faisant partie des conteneur standard de la STLen C++. Elle impl√©mente une file FIFO (First In, First Out) : les √©l√©ments sont ins√©r√©s en fin de file et retir√©s par l‚Äôavant.\nContrairement aux conteneur s√©quentiels classiques, elle expose une interface restreinte (pas d‚Äôit√©rateur, pas d‚Äôacc√®s al√©atoire), et s‚Äôutilise dans les cas o√π l‚Äôon veut respecter strictement l‚Äôordre d‚Äôarriv√©e des √©l√©ments.\n\n\nInclude\nPour utiliser std::queue il faut l‚Äôinclusion suivante :\n#include &lt;queue&gt;\n\nEspace de nom\nLes file FIFO queue font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::queue\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nstd::queue&lt;Type&gt; maFile;\n \n// exemple :\nstd::queue&lt;int&gt; fileEntiers;\nstd::queue&lt;std::string&gt; fileMots;\nSp√©cification du conteneur sous-jacent\nstd::queue&lt;int, std::deque&lt;int&gt; &gt; q1; // par d√©faut\nstd::queue&lt;int, std::list&lt;int&gt; &gt;  q2; // alternatif\n\n‚ö†Ô∏è std::vector n‚Äôest pas autoris√© car il ne permet pas de retirer efficacement en t√™te.\n\n\nImpl√©mentation interne\nUne queue&lt;T&gt; est un adaptateur de conteneur encapsulant :\n\nun conteneur s√©quentiel (deque par d√©faut, list possible)\nune interface strictement FIFO :\n\npush() ‚Üí ins√®re √† l‚Äôarri√®re\npop() ‚Üí retire √† l‚Äôavant\nfront() / back() ‚Üí acc√®de √† l‚Äôextr√©mit√© concern√©e\n\n\n\n\nAucun it√©rateur n‚Äôest expos√© : la file est une bo√Æte noire FIFO.\n\n\nFile FIFO et m√©moire\nLa gestion m√©moire est d√©l√©gu√©e au conteneur sous-jacent (file double deque ou liste list).\nChaque push() ajoute un √©l√©ment √† l‚Äôarri√®re ; chaque pop() lib√®re le premier √©l√©ment.\nCela garantit une gestion efficace dans les cas de flux de donn√©es, syst√®mes √©v√©nementiels, ou ordonnancement.\n\nQuand et pourquoi utiliser file FIFO\nUne queue est id√©ale lorsqu‚Äôon veut traiter les √©l√©ments dans l‚Äôordre exact o√π ils sont arriv√©s.\nElle s‚Äôutilise naturellement pour :\n\ndes syst√®mes de messagerie\ndes files d‚Äôattente de t√¢ches\ndes processus asynchrones ou s√©quentiels\ntout algorithme o√π l‚Äôordre d‚Äôinsertion doit √™tre strictement respect√©\n\nC‚Äôest un mod√®le tr√®s courant dans les syst√®mes temps r√©el, les moteurs de r√®gles ou les simulateurs.\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionfront()Acc√®s √† l‚Äô√©l√©ment en t√™te (le plus ancien)back()Acc√®s √† l‚Äô√©l√©ment en queue (le plus r√©cent)size()Nombre d‚Äô√©l√©ments pr√©sents dans la fileempty()V√©rifie si la file est vide\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionpush(val)Ajoute val √† la fin de la filepop()Supprime l‚Äô√©l√©ment en t√™te de file\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionoperator=Affecte une autre fileswap()√âchange deux queue entre elles\n\nRemarques importantes\n\nstd::queue ne donne aucun acc√®s √† ses √©l√©ments internes sauf front() et back()\nPas d‚Äôit√©rateur ‚Üí pas de begin(), pas de [], pas de parcours\nSon comportement d√©pend du conteneur sous-jacent, mais son interface est fixe\nC‚Äôest une abstraction simple mais puissante pour g√©rer des flux ordonn√©s\n"},"file-de-priorit√©":{"slug":"file-de-priorit√©","filePath":"file de priorit√©.md","title":"file de priorit√©","links":["conteneur-adaptateur","conteneur-standard-de-la-STL","C++","STL","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","foncteur","vecteur","it√©rateur"],"tags":[],"content":"\nNom anglais: priority queue\nNom pleinement qualifi√©: std::priority_queue\n\n\nUne priority_queue est un conteneur adaptateur faisant partie des conteneur standard de la STLen C++. Elle impl√©mente une file de priorit√© : les √©l√©ments sont toujours tri√©s de mani√®re √† ce que le plus prioritaire soit accessible en premier.\nPar d√©faut, les √©l√©ments sont organis√©s en max-heap (le plus grand en t√™te), selon l‚Äôordre d√©fini par operator&lt;.\n\n\nInclude\nPour utiliser std::priority_queue il faut l‚Äôinclusion suivante :\n#include &lt;queue&gt;\n\nEspace de nom\nLes files de priorit√©  priority_queue font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::priority_queue\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nstd::priority_queue&lt;Type&gt; filePrio;\n \n// exemple :\nstd::priority_queue&lt;int&gt; scores;\nstd::priority_queue&lt;std::string&gt; mots;\nPersonnalisation du comparateur\nstd::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; minHeap;\n\nstd::greater&lt;T&gt; ‚Üí transforme la file en min-heap\nOn peut aussi passer un foncteur personnalis√©\n\n\nImpl√©mentation interne\nUne priority_queue&lt;T&gt; encapsule :\n\nun vecteur std::vector&lt;T&gt; par d√©faut\nun algorithme make_heap, push_heap, pop_heap\nune organisation en tas binaire (max-heap par d√©faut)\n\n\nElle ne fournit pas d‚Äôit√©rateur ni d‚Äôacc√®s al√©atoire.\n\n\nPriority queue et m√©moire\nLes √©l√©ments sont stock√©s dans un vecteur vector, r√©organis√© √† chaque insertion ou suppression pour maintenir la propri√©t√© de tas.\nCela garantit :\n\nun acc√®s rapide au maximum (top() en O(1))\ndes insertions et suppressions en O(log n)\n\n\nQuand et pourquoi utiliser une file de priorit√©\nUne file de priorit√©  priority_queue est id√©ale lorsqu‚Äôon doit toujours traiter l‚Äô√©l√©ment ayant la plus haute priorit√© en premier, ind√©pendamment de son ordre d‚Äôinsertion.\nElle est utilis√©e pour :\n\ndes ordonnancements de t√¢ches\ndes algorithmes gloutons (Dijkstra, A*, Huffman)\ndes syst√®mes de gestion d‚Äô√©v√©nements par priorit√©\n\nSon comportement automatique permet de remplacer des tris manuels co√ªteux dans de nombreuses applications.\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptiontop()Acc√®s √† l‚Äô√©l√©ment prioritaire (le plus haut)size()Nombre d‚Äô√©l√©ments dans la fileempty()V√©rifie si la file est vide\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionpush(val)Ajoute val et r√©organise la filepop()Retire l‚Äô√©l√©ment le plus prioritaire\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionoperator=Affecte une autre file de priorit√©swap()√âchange deux priority_queue\n\nRemarques importantes\n\nPar d√©faut, c‚Äôest une max-heap (top() donne le plus grand)\nPour cr√©er une min-heap, il faut passer std::greater&lt;T&gt; en troisi√®me template param√®tre\nAucun it√©rateur n‚Äôest fourni\nL‚Äôordre d‚Äôinsertion n‚Äôest pas conserv√© : seuls les niveaux de priorit√© comptent\nC‚Äôest un outil puissant pour g√©rer des flux o√π l‚Äôordre n‚Äôest pas chronologique, mais strat√©gique\n"},"file-double":{"slug":"file-double","filePath":"file double.md","title":"file double","links":["conteneur-s√©quentiel","conteneur-standard-de-la-STL","C++","vecteur","STL","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","cache","liste","It√©rateur","it√©rateur","conteneur-adaptateur","pile-algorithmique-LIFO","file-FIFO"],"tags":[],"content":"\nNom anglais: deque\nNom pleinement qualifi√©: std::deque\n\n\nUne file double deque (double-ended queue) est un conteneur s√©quentiel faisant partie des conteneur standard de la STL en C++. Elle permet une insertion et une suppression rapides en t√™te comme en queue, contrairement √† un vecteur std::vector qui est optimis√© uniquement pour l‚Äôarri√®re.\nElle combine certains avantages du vecteur vector (acc√®s rapide par index) et de list (insertion rapide en d√©but), au prix d‚Äôune structure interne plus complexe.\nLe nom deque est l‚Äôabr√©viation de double-ended queue, ce qui signifie en fran√ßais : file √† double extr√©mit√©\nComparaison C/C++ : Une deque est l‚Äô√©quivalent d‚Äôun tableau dynamique √† deux extr√©mit√©s, qui permet de cro√Ætre ou d√©cro√Ætre efficacement aux deux bouts.\n\n\nInclude\nPour utiliser std::deque il faut l‚Äôinclusion suivante :\n#include &lt;deque&gt;\n\nEspace de nom\nLes files double dequefont partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::deque\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nPour d√©clarer une deque il faut utiliser la syntaxe suivante :\nstd::deque&lt;type&gt; myDeque;\n \n// exemple pour une deque d&#039;int :\nstd::deque&lt;int&gt; myIntDeque;\n \n// exemple pour une deque de std::string :\nstd::deque&lt;std::string&gt; myStringDeque;\n \n// exemple avec initialisation (C++98) :\nint arr[] = {1, 2, 3};\nstd::deque&lt;int&gt; myDeque(arr, arr + 3); // copie depuis un tableau\nInitialisation\n‚Üí En C++98\nstd::deque&lt;int&gt; d1;                    // deque vide\nstd::deque&lt;int&gt; d2(5);                 // 5 √©l√©ments valant 0\nstd::deque&lt;int&gt; d3(5, 42);             // 5 √©l√©ments valant 42\nint arr[] = {1, 2, 3};\nstd::deque&lt;int&gt; d4(arr, arr + 3);      // depuis un tableau C\nstd::deque&lt;std::string&gt; d5(3, &quot;ok&quot;);   // 3 √©l√©ments &quot;ok&quot;\n‚Üí En C++11 et plus\nstd::deque&lt;int&gt; d6 = {1, 2, 3};        // initialisation par liste\nstd::deque&lt;std::string&gt; d7{&quot;a&quot;, &quot;b&quot;};  // initialisation par accolades\nstd::deque&lt;int&gt; d8{10};               // un seul √©l√©ment valant 10\nstd::deque&lt;int&gt; d9{10, 5};            // deux √©l√©ments : 10 et 5\n\n‚ö†Ô∏è L‚Äôinitialisation par {} n‚Äôest pas disponible en C++98\n\n\nImpl√©mentation interne\nUne deque&lt;T&gt; encapsule :\n\nun tableau segment√© (tableaux discontinus appel√©s blocs ou buffers)\nun syst√®me d‚Äôindexation pour acc√©der rapidement √† chaque bloc\nune m√©moire non contigu√´, mais un acc√®s logique en s√©quence\n\n\nContrairement √† un vecteur vector, les √©l√©ments d‚Äôune file double deque ne sont pas tous en m√©moire contigu√´, mais l‚Äôacc√®s par index reste O(1) gr√¢ce √† une structure d‚Äôindex interm√©diaire.\n\n\nDeque et m√©moire\nLa std::deque est con√ßue pour permettre des insertions et suppressions rapides aux deux extr√©mit√©s. Pour cela, elle alloue la m√©moire sous forme de blocs discontinus.\n\nAcc√®s par index : rapide (O(1)) mais l√©g√®rement plus lent que vector\nInsertion/suppression en t√™te ou queue : tr√®s efficace (O(1) amorti)\nInsertion au milieu : co√ªteuse (O(n))\n\nContrairement √† std::vector (un vecteur alloue toute sa m√©moire d‚Äôun seul tenant), une file std::deque fonctionne comme un tableau de pointeurs vers des blocs de donn√©es, o√π :\n\nchaque bloc contient plusieurs √©l√©ments (souvent 512 ou 1024 octets selon l‚Äôimpl√©mentation)\nles blocs ne sont pas n√©cessairement adjacents en m√©moire\non peut ajouter un nouveau bloc √† gauche ou √† droite rapidement\n\nLes performances en cache sont moindres par rapport √† un vecteur mais meilleures qu‚Äôune liste.\n\nQuand et pourquoi utiliser une file double\nUne file (ou queue) est une structure adapt√©e aux situations o√π les donn√©es doivent √™tre trait√©es dans l‚Äôordre d‚Äôarriv√©e (FIFO ‚Äì First In, First Out). Elle est particuli√®rement utile lorsqu‚Äôon doit g√©rer des t√¢ches, des requ√™tes ou des √©v√©nements dans l‚Äôordre chronologique.\nPar exemple :\n\nune file d‚Äôattente de traitements\nune file de messages r√©seau\nou une file de jobs dans un syst√®me multit√¢che.\n\nLa file garantit que le premier √©l√©ment ins√©r√© sera aussi le premier trait√©, ce qui correspond √† de nombreux mod√®les de communication ou de programmation orient√©e √©v√©nements.\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionsize()Retourne le nombre d‚Äô√©l√©mentsempty()V√©rifie si la deque est videoperator[]Acc√®s direct sans v√©rificationat(index)Acc√®s s√©curis√© (avec v√©rification)front() / back()Acc√®s au premier / dernier √©l√©mentmax_size()Nombre maximal th√©orique d‚Äô√©l√©ments\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionpush_back(val)Ajoute val √† la finpush_front(val)Ajoute val au d√©butpop_back()Supprime le dernier √©l√©mentpop_front()Supprime le premier √©l√©mentinsert(pos, val)Ins√®re val √† la position poserase(pos)Supprime l‚Äô√©l√©ment √† la position posclear()Vide compl√®tement la deque\nIt√©rateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionbegin() / end()It√©rateurs sur le d√©but / fin de la dequerbegin() / rend()It√©rateurs invers√©s\n\nLes it√©rateurs permettent un parcours s√©quentiel standard avec for, std::find, etc.\n\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionassign(n, val)Remplit la deque avec n copies de valoperator=Affecte une autre deque\n\nRemarques importantes\n\nstd::deque est id√©ale pour des acc√®s par index combin√©s √† des ajouts en t√™te\nElle remplace avantageusement une liste ou un vecteur (list ou vector) dans des cas sp√©cifiques\nLes insertions au milieu sont co√ªteuses (O(n)), comme pour vector\nLes √©l√©ments ne sont pas contigus, donc la deque n‚Äôest pas cache-friendly\n\n\nUtilisation comme base d‚Äôautres conteneurs\nLe std::deque est non seulement un conteneur s√©quentiel √† part enti√®re, mais il sert aussi de conteneur sous-jacent par d√©faut pour plusieurs conteneur adaptateurs de la STL :\n\nstd::stack : pour une pile algorithmique LIFO\nstd::queue : pour une file FIFO\n\nCela s‚Äôexplique par sa capacit√© unique √† ins√©rer et retirer efficacement aux deux extr√©mit√©s, ce que ne permet pas un vecteur vector.\nGr√¢ce √† cette flexibilit√©, deque est souvent pr√©f√©r√© comme structure de support pour les structures d‚Äôacc√®s restreint.\n\nIl est √©galement possible de substituer deque par d‚Äôautres conteneurs compatibles (comme vector ou list), mais deque reste le choix par d√©faut recommand√©.\n"},"flush":{"slug":"flush","filePath":"flush.md","title":"flush","links":["tampon-de-sortie","cout","cin","endl"],"tags":[],"content":"\nNom anglais: flush\n\n\nLe flush est l‚Äôop√©ration qui consiste √† vider le tampon de sortie, c‚Äôest-√†-dire √† envoyer imm√©diatement les donn√©es stock√©es vers leur destination (√©cran, fichier, etc.).\nComparaison C/C++ : En C, on utilise fflush(stdout). En C++, on peut utiliser std::flush ou std::endl (qui fait aussi un flush).\n\nPourquoi flusher ?\nPar d√©faut, cout utilise un tampon pour optimiser les performances.\nMais il peut arriver qu‚Äôon veuille forcer l‚Äôaffichage imm√©diat, par exemple :\n\njuste avant une lecture avec std::cin (voir cin)\npour voir un message de d√©bogage avant un crash\npour synchroniser la sortie avec une autre op√©ration\n\nComment flusher en C++\nAvec std::endl (voir endl):\nstd::cout &lt;&lt; &quot;Message&quot; &lt;&lt; std::endl; // saut de ligne + flush\nAvec std::flush (sans saut de ligne) :\nstd::cout &lt;&lt; &quot;Attente utilisateur...&quot; &lt;&lt; std::flush;\nExemple\nstd::cout &lt;&lt; &quot;Chargement...&quot; &lt;&lt; std::flush;\n// attente, traitement, etc.\nSans flush, il est possible que &quot;Chargement...&quot; ne s‚Äôaffiche pas tout de suite.\nR√©sum√©\n\nFlusher, c‚Äôest forcer l‚Äôenvoi imm√©diat des donn√©es du tampon de sortie vers la destination finale.\nEn C++, on utilise std::flush ou implicitement via std::endl.\n"},"flux-de-la-biblioth√®que-standard":{"slug":"flux-de-la-biblioth√®que-standard","filePath":"flux de la biblioth√®que standard.md","title":"flux de la biblioth√®que standard","links":["C++","objet","flux","programmation-orient√©e-objet","classe","STL","biblioth√®que","biblioth√®que-iostream","biblioth√®que-fstream","biblioth√®que-sstream","tampon","manipulateur-de-flux","it√©rateur"],"tags":[],"content":"\nNom anglais: standard streams\n\n\nLes flux de la biblioth√®que standard C++ sont des objets de flux qui permettent de g√©rer l‚Äôentr√©e et la sortie de donn√©es de mani√®re uniforme en programmation orient√©e objet  .\nIls reposent sur une hi√©rarchie de classes de la STL, et peuvent manipuler aussi bien l‚Äôentr√©e/sortie standard (√©cran, clavier) que les fichiers ou des cha√Ænes de caract√®res.\n\n\nEspace de nom\nLes flux standards font partie de la biblioth√®que standard C++, et sont donc d√©finis dans l‚Äôespace de nom std.\nIls doivent √™tre utilis√©s de cette fa√ßon‚ÄØ:\n‚Üí std::cout,  std::cin, etc\n\nPour √©viter de pr√©fixer chaque flux avec std::, on peut inclure :\n\n‚Üí using namespace std\n‚ö†Ô∏è Cette pratique peut √™tre acceptable dans de petits fichiers ou des exemples simples, mais elle est d√©conseill√©e dans les projets de grande taille (risque de conflits de noms avec d‚Äôautres biblioth√®ques).\n\nPrincipaux flux disponibles\nFlux standard (console)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFluxTypeDescriptionstd::cinistreamLecture depuis l‚Äôentr√©e standard (clavier)std::coutostream√âcriture vers la sortie standard (√©cran)std::cerrostream√âcriture vers la sortie d‚Äôerreur imm√©diatestd::clogostream√âcriture vers la sortie d‚Äôerreur tamponn√©e\n‚Üí Voir la fiche d√©di√©e biblioth√®que iostream\nFlux de fichiers\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFluxTypeDescriptionstd::ifstreamistreamLecture depuis un fichierstd::ofstreamostream√âcriture vers un fichierstd::fstreamiostreamLecture et √©criture dans un fichier\n‚Üí Voir la fiche d√©di√©e biblioth√®que fstream\nFlux de cha√Ænes de caract√®res\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFluxTypeDescriptionstd::istringstreamistreamLecture depuis une cha√Ænestd::ostringstreamostream√âcriture dans une cha√Ænestd::stringstreamiostreamLecture et √©criture dans une cha√Æne\n‚Üí Voir la fiche d√©di√©e biblioth√®que sstream\n\n√âtats des flux\nChaque flux poss√®de des m√©thodes pour v√©rifier son √©tat :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeSignificationgood()Tout va bien (aucune erreur)eof()Fin de fichier atteintefail()Une erreur non fatale est survenue (ex: type incorrect)bad()Erreur grave sur le flux (ex: mat√©riel)clear()R√©initialise l‚Äô√©tat du flux\n\nExemple\n#include &lt;iostream&gt;\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::ifstream fichier(&quot;donnees.txt&quot;);\n    std::string ligne;\n \n    if (!fichier) {\n        std::cerr &lt;&lt; &quot;Erreur d&#039;ouverture !&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n \n    while (std::getline(fichier, ligne)) {\n        std::cout &lt;&lt; ligne &lt;&lt; std::endl;\n    }\n}\n\nRemarques\n\nTous les flux utilisent des tampons pour am√©liorer les performances.\nIls peuvent √™tre manipul√©s avec des manipulateur de flux comme std::endl, std::hex, std::setw, etc.\nIls reposent tous sur le concept d‚Äôit√©rateur implicite, permettant un usage fluide avec les types de donn√©es.\n"},"flux":{"slug":"flux","filePath":"flux.md","title":"flux","links":["C++","cout","cin","ofstream","biblioth√®que-standard-C++","objet","flux-de-la-biblioth√®que-standard"],"tags":[],"content":"\nNom anglais: stream\n\n\nUn flux est une abstraction en C++ qui repr√©sente une source ou une destination de donn√©es. Il permet de lire ou √©crire des donn√©es de mani√®re s√©quentielle, comme si elles coulaient dans un ‚Äútuyau‚Äù.\nComparaison C/C++ : En C, on utilise printf/scanf et les FILE*. En C++, on utilise des objets flux comme std::cout, std::cin, ou std::ifstream.\n\n\nTypes de flux en C++\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypeDescriptionExempleFlux de sortiePour afficher des donn√©esstd::coutFlux d‚Äôentr√©ePour lire des donn√©esstd::cinFlux de fichierPour lire ou √©crire dans un fichierstd::ifstream, std::ofstream\n\nFonctionnement\nUn flux agit comme un tuyau entre le programme et une destination/source :\n\navec cout: std::cout envoie les donn√©es vers l‚Äô√©cran\navec cin: std::cin r√©cup√®re des donn√©es depuis le clavier\navec ofstream: std::ofstream envoie les donn√©es dans un fichier\n\nExemple\n#include &lt;iostream&gt;\n \nstd::cout &lt;&lt; &quot;Nom : &quot;;\nstd::string nom;\nstd::cin &gt;&gt; nom;\nIci :\n\nstd::cout √©crit dans le flux de sortie\nstd::cin lit depuis le flux d‚Äôentr√©e\n\n\nPrincipaux flux de la biblioth√®que standard\nLa biblioth√®que standard C++fournit plusieurs objets de flux pr√©d√©finis, regroup√©s dans diff√©rents types selon leur usage :\nFlux standard (console)\n\nstd::cin : flux d‚Äôentr√©e standard (lecture depuis le clavier)\nstd::cout : flux de sortie standard (affichage √† l‚Äô√©cran)\nstd::cerr : flux de sortie d‚Äôerreur non tamponn√©e (affichage imm√©diat des erreurs)\nstd::clog : flux de sortie d‚Äôerreur tamponn√©e (log ou messages d‚Äô√©tat)\n\nFlux de fichiers\n\nstd::ifstream : flux d‚Äôentr√©e depuis un fichier\nstd::ofstream : flux de sortie vers un fichier\nstd::fstream : flux bidirectionnel (lecture/√©criture dans un fichier)\n\nCes objets sont d√©clar√©s dans l‚Äôen-t√™te #include &lt;iostream&gt; (pour les flux standard) et #include &lt;fstream&gt; (pour les fichiers).\n\nTous ces flux reposent sur les classes de base std::istream, std::ostream, std::iostream, et std::fstream.\n\n‚Üí Voir la fiche d√©di√©e flux de la biblioth√®que standard\n\nR√©sum√©\n\nUn flux est un objet qui transporte des donn√©es entre le programme et une source ou une destination (√©cran, clavier, fichier, etc.).\nIl existe des flux d‚Äôentr√©e, de sortie, et de fichiers.\n"},"foncteur":{"slug":"foncteur","filePath":"foncteur.md","title":"foncteur","links":["C++","fonction","classe","surcharge","op√©rateur","STL","biblioth√®que-algorithm"],"tags":[],"content":"\nNom anglais: functor\nNom complet: objet fonctionnel\n\n\nEn C++, un foncteur (ou objet fonctionnel) est un objet qui se comporte comme une fonction.\nIl s‚Äôagit d‚Äôune classe ou structure qui surcharge l‚Äôop√©rateur operator(), ce qui permet d‚Äôappeler une instance comme une fonction.\n\n\nExemple simple\nstruct EstPair {\n\tbool operator()(int n) const {\n\t\treturn n % 2 == 0;\n\t}\n};\n \nEstPair estPair;\nbool res = estPair(4); // true\n\nUtilisation typique\nLes foncteurs sont utilis√©s dans la STL avec les algorithmes de la biblioth√®que algorithm comme sort, find_if, count_if, etc., pour fournir un comportement personnalisable.\nstd::sort(v.begin(), v.end(), EstPair()); // Utilise le foncteur comme crit√®re de tri\n\nAvantages\n\nUn foncteur peut contenir un √©tat (contrairement √† une fonction simple).\nIl peut √™tre r√©utilisable et configurable via ses attributs.\nIl peut √™tre pass√© comme param√®tre l√† o√π une fonction est attendue.\n\n\nComparaison avec d‚Äôautres approches\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypePeut contenir un √©tatPeut √™tre pass√© comme param√®treSyntaxe conciseFonction‚ùå Non‚úÖ Oui‚úÖ OuiLambda‚úÖ (via capture)‚úÖ Oui‚úÖ Tr√®s conciseFoncteur‚úÖ Oui‚úÖ Oui‚ùå Plus verbeuse\n\nRemarques\n\nUn foncteur peut √™tre mutable ou const, selon la d√©finition de operator().\n√Ä partir de C++11, les lambdas sont souvent pr√©f√©r√©es pour leur concision, mais les foncteurs restent utiles pour des traitements complexes et r√©utilisables.\n"},"fonction-statique":{"slug":"fonction-statique","filePath":"fonction statique.md","title":"fonction statique","links":["membre-statique"],"tags":[],"content":"‚Üí Voir la fiche : membre statique"},"fonction":{"slug":"fonction","filePath":"fonction.md","title":"fonction","links":["classe","m√©thode","C++"],"tags":[],"content":"\nNom anglais: function\n\n\nUne fonction est un bloc de code r√©utilisable qui accomplit une t√¢che pr√©cise. Elle peut prendre des param√®tres en entr√©e, effectuer des op√©rations, et retourner une valeur.\nComparaison C/C++ : Les fonctions existent en C et en C++, mais en C++ elles peuvent aussi √™tre membres d‚Äôune classe (on les appelle alors m√©thodes).\n\nD√©finir une fonction\nExemple :\nint addition(int a, int b)\n{\n    return a + b;\n}\n\nint : type de retour\naddition : nom de la fonction\nint a, int b : param√®tres\nreturn : valeur retourn√©e\n\nAppeler une fonction\nExemple d‚Äôutilisation :\nint resultat = addition(2, 3); // r√©sultat = 5\nFonctions sans retour\nElle sera de type void:\nvoid afficherMessage()\n{\n    std::cout &lt;&lt; &quot;Bonjour !&quot; &lt;&lt; std::endl;\n}\nR√©sum√©\n\nüìå Une fonction permet de nommer une action, de la r√©utiliser facilement, et de structurer ton programme.\nEn C++, les fonctions peuvent √™tre libres ou membres d‚Äôune classe (dans ce cas, ce sont des m√©thodes).\n"},"forme-canonique-de-Coplien":{"slug":"forme-canonique-de-Coplien","filePath":"forme canonique de Coplien.md","title":"forme canonique de Coplien","links":["C++","m√©thode","classe","objet","constructeur-par-d√©faut","compilateur","constructeur-par-copie","op√©rateur-d'affectation","destructeur","C++11","rule-of-three","membre"],"tags":[],"content":"\nNom anglais : canonical form\n\n\nLa forme canonique (canonical form) en C++ est une convention de conception qui recommande d‚Äôimpl√©menter syst√©matiquement quatre m√©thodes fondamentales dans une classe.\nCes m√©thodes contr√¥lent la construction, la copie, l‚Äôaffectation, et la destruction des objets, pour garantir un comportement s√ªr et pr√©visible.\n\n\n√Ä 42, cette forme est explicitement exig√©e dans la majorit√© des projets C++.\n\n\nObjectif de la forme canonique\n\n\nPr√©venir les effets ind√©sirables lors des copies, affectations, ou destructions.\n\n\nContr√¥ler finement ce qu‚Äôil se passe quand un objet est copi√©, assign√©, ou d√©truit.\n\n\nFaciliter le debug, la maintenance, et la gestion des ressources (notamment lors de l‚Äôutilisation de pointeurs ou de m√©moire dynamique).\n\n\n\nLes 4 m√©thodes de la forme canonique\n\n‚úÖ Constructeur par d√©faut\nD√©finit comment un objet est cr√©√© sans argument.\nIl est indispensable pour instancier un objet simple, ou pour cr√©er un tableau d‚Äôobjets.\nMaClasse(); // pas de param√®tres\n‚Üí Voir la fiche d√©di√©e : constructeur par d√©faut\n\n‚úÖ Constructeur par copie\nD√©finit comment un objet est copi√© √† partir d‚Äôun autre (passage par valeur, retour de fonction, etc.).\nMaClasse(const MaClasse&amp; other);\nSans ce constructeur, le compilateur en g√©n√®re un par d√©faut ‚Äî mais il fait une copie membre par membre, ce qui peut √™tre dangereux avec des pointeurs.\n‚Üí Voir la fiche d√©di√©e : constructeur par copie\n\n‚úÖ Op√©rateur d‚Äôaffectation par copie\nD√©finit comment un objet d√©j√† existant re√ßoit une copie d‚Äôun autre.\nMaClasse&amp; operator=(const MaClasse&amp; other);\nCe n‚Äôest pas la m√™me chose que le constructeur par copie : ici, l‚Äôobjet existe d√©j√†.\nIl faut toujours v√©rifier l‚Äôauto-affectation (if (this != &amp;other)).\n‚Üí Voir la fiche d√©di√©e : op√©rateur d‚Äôaffectation\n\n‚úÖ Destructeur\nD√©finit ce qu‚Äôil se passe quand un objet sort de port√©e ou est d√©truit.\nPermet de lib√©rer les ressources (m√©moire dynamique, fichiers, sockets, etc.).\n~MaClasse();\nM√™me si le compilateur en g√©n√®re un par d√©faut, il est indispensable de le red√©finir d√®s qu‚Äôil y a de l‚Äôallocation manuelle.\n‚Üí Voir la fiche d√©di√©e : destructeur\n\nBonnes pratiques\n\n\nImpl√©mente toutes les m√©thodes canoniques m√™me si certaines semblent inutiles au d√©but.\n\n\nAppelle les m√©thodes dans l‚Äôordre logique : constructeur ‚Üí op√©rateur ‚Üí destructeur.\n\n\nUtilise la liste d‚Äôinitialisation dans les constructeurs.\n\n\nDans l‚Äôop√©rateur d‚Äôaffectation, teste l‚Äôauto-affectation et retourne *this.\n\n\n\n√Ä ne pas confondre avec‚Ä¶\nLa Rule of Three, qui est une g√©n√©ralisation de la forme canonique.\nEt en C++11 et au-del√†, on parle aussi de la Rule of Five (ajout du move constructor et de l‚Äôop√©rateur de move).\n\nVoir aussi\n‚Üí constructeur par d√©faut, constructeur par copie, op√©rateur d‚Äôaffectation, destructeur, classe, objet, rule of three, membre.\nSouhaites-tu que je pr√©pare maintenant les fiches correspondantes pour les 4 m√©thodes (si elles ne sont pas encore cr√©√©es) ?"},"forme-canonique":{"slug":"forme-canonique","filePath":"forme canonique.md","title":"forme canonique","links":["C++","m√©thode","classe","objet","constructeur-par-d√©faut","compilateur","attribut","constructeur-par-copie","membre","op√©rateur-d‚Äôaffectation-par-copie","op√©rateur-d'affectation-par-copie","bloc","destructeur","liste-d‚Äôinitialisation","constructeur","this","C++11"],"tags":[],"content":"\nNom anglais : canonical form\n\n\nLa forme canonique (ou forme canonique de Coplien) en C++ est une convention de conception qui recommande d‚Äôimpl√©menter syst√©matiquement quatre m√©thodes fondamentales dans une classe.\nCes m√©thodes contr√¥lent la construction, la copie, l‚Äôaffectation, et la destruction des objets, pour garantir un comportement s√ªr et pr√©visible.\n√Ä 42, cette forme est explicitement exig√©e dans la majorit√© des projets C++.\n\n\nObjectif de la forme canonique\n\nPr√©venir les effets ind√©sirables lors des copies, affectations, ou destructions.\nContr√¥ler finement ce qu‚Äôil se passe quand un objet est copi√©, assign√©, ou d√©truit.\nFaciliter le debug, la maintenance, et la gestion des ressources (notamment lors de l‚Äôutilisation de pointeurs ou de m√©moire dynamique).\n\n\nLes 4 m√©thodes de la forme canonique\nAfin de respecter la forme canonique, une classe doit impl√©menter 4 m√©thodes :\n1. Constructeur par d√©faut\nD√©finit comment un objet est cr√©√© sans argument. Il est indispensable pour instancier un objet simple, ou pour cr√©er un tableau d‚Äôobjets.\nMaClasse(); // pas de param√®tres\n\nSi on n‚Äôimpl√©mente pas de constructeur par d√©faut, le compilateur en g√©n√®re un automatiquement, mais uniquement s‚Äôil le peut, et il ne r√©alise aucune initialisation explicite des attributs.\nLes attributs non initialis√©s auront donc des valeurs ind√©termin√©es, sauf s‚Äôils sont eux-m√™mes des objets d‚Äôune classe : dans ce cas, leur propre constructeur par d√©faut sera appel√©, et ils recevront les valeurs pr√©vues par ce constructeur.\n\n‚Üí Voir la fiche d√©di√©e : constructeur par d√©faut\n2. Constructeur par copie\nD√©finit comment un objet est cr√©√© en √©tant copi√© √† partir d‚Äôun autre (passage par valeur, retour de fonction, etc.).\nMaClasse(const MaClasse&amp; other);\n\nSi on n‚Äôimpl√©mente pas de constructeur par copie, le compilateur en g√©n√®rera un par d√©faut qui fera une copie membre par membre, ce qui fonctionne correctement pour les types simples, mais peut √™tre dangereux pour les types complexes (pointeurs, ressources dynamiques, etc).\n\n‚Üí Voir la fiche d√©di√©e : constructeur par copie\n3. Op√©rateur d‚Äôaffectation par copie\nD√©finit comment un objet d√©j√† existant re√ßoit une copie d‚Äôun autre.\nMaClasse&amp; operator=(const MaClasse&amp; other);\nCe n‚Äôest pas la m√™me chose que le constructeur par copie : ici, l‚Äôobjet existe d√©j√†, mais on va le modifier en lui affectant les valeurs d‚Äôun autre objet de m√™me type.\n\nComme pour le constructeur par copie, si on n‚Äôimpl√©mente pas l‚Äôop√©rateur d‚Äôaffectation par copie, le compilateur en g√©n√®rera un par d√©faut qui fera une copie membre par membre, ce qui fonctionne correctement pour les types simples, mais peut √™tre dangereux pour les types complexes (pointeurs, ressources dynamiques, etc).\n\n‚Üí Voir la fiche d√©di√©e : op√©rateur d‚Äôaffectation par copie\n4. Destructeur\nD√©finit ce qu‚Äôil se passe quand un objet sort de port√©e (c‚Äôest √† dire lorsque le bloc ({}) dans lequel il a √©t√© d√©clar√© se termine) ou est d√©truit.  Le destructeur permet de lib√©rer les ressources (m√©moire dynamique, fichiers, sockets, etc.).\n~MaClasse();\nSi le destructeur n‚Äôest pas impl√©ment√©, le compilateur en g√©n√®rera un par d√©faut, mais il est indispensable de le red√©finir d√®s qu‚Äôil y a de l‚Äôallocation manuelle de m√©moire.\n‚Üí Voir la fiche d√©di√©e : destructeur\n\nBonnes pratiques\n\nImpl√©menter toutes les m√©thodes canoniques m√™me si certaines semblent inutiles au d√©but.\nAppeller les m√©thodes dans l‚Äôordre logique : constructeur ‚Üí op√©rateur ‚Üí destructeur.\nUtiliser la liste d‚Äôinitialisationdans les constructeurs.\nDans l‚Äôop√©rateur d‚Äôaffectation par copie, tester l‚Äôauto-affectation et retourner *this (voir this).\n\n\nNe pas confondre avec la Rule of Three (r√®gle des trois)\nLa Rule of Three est une g√©n√©ralisation de la forme canonique.  C‚Äôest une r√®gle de conception C++ qui dit :\n\nSi on a besoin de d√©finir l‚Äôun de ces trois √©l√©ments dans une classe, alors on doit probablement d√©finir les deux autres :\n\nle destructeur\nle constructeur par copie\nl‚Äôop√©rateur d‚Äôaffectation par copie\n\n\nParce que ces trois m√©thodes sont toutes li√©es √† la gestion des ressources internes (pointeurs, fichiers, m√©moire, etc.).  Si on en modifie une, les deux autres doivent g√©rer les m√™mes ressources correctement, sous peine de :\n\nfuites m√©moire\ndouble delete\naliasing ind√©sirable\ncomportements ind√©finis\n\nEt en C++11 et au-del√†, on parle aussi de la Rule of Five (ajout du move constructor et de l‚Äôop√©rateur de move).\n\nVoir aussi\n‚Üí Voir les fiches d√©di√©es : constructeur par d√©faut, constructeur par copie, op√©rateur d‚Äôaffectation par copie, destructeur, classe, objet, membre."},"getline":{"slug":"getline","filePath":"getline.md","title":"getline","links":["Nom-pleinement-qualifi√©","fonction","biblioth√®que-standard-C++","flux","string","C++"],"tags":[],"content":"\nNom pleinement qualifi√©: std::getline\n\n\nstd::getline est une fonction de la biblioth√®que standard C++ qui permet de lire une ligne compl√®te de texte depuis un flux (comme std::cin) et de la stocker dans une string.\nContrairement √† std::cin &gt;&gt;, elle ne s‚Äôarr√™te pas aux espaces mais lit jusqu‚Äôau caract√®re de fin de ligne (\\n).\nComparaison C/C++ : En C, on utilise fgets() pour lire une ligne enti√®re. En C++, std::getline est plus s√ªre, plus flexible, et int√©gr√©e √† std::string.\n\nSyntaxe\nstd::getline(source, destination);\n\nsource : un flux (souvent std::cin)\ndestination : une string dans laquelle stocker la ligne\n\nExemple simple\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::string nomComplet;\n    std::cout &lt;&lt; &quot;Entrez votre nom complet : &quot;;\n    std::getline(std::cin, nomComplet);\n    std::cout &lt;&lt; &quot;Bonjour &quot; &lt;&lt; nomComplet &lt;&lt; std::endl;\n    return 0;\n}\n\nCe code lit toute la ligne, m√™me si elle contient des espaces.\n\nPourquoi utiliser std::getline ?\n\nPour lire des phrases compl√®tes\nPour √©viter que std::cin &gt;&gt; tronque la lecture apr√®s un espace\nPour mieux g√©rer les entr√©es utilisateur dans les programmes interactifs\n\nPi√®ge du EOF\nLorsque l‚Äôutilisateur tape Ctrl+D sous Linux, cela g√©n√®re un **EOF (End Of File), qui indique la fin de l‚Äôentr√©e standard.\nSi on appelle std::getline apr√®s l‚ÄôEOF, la lecture √©choue silencieusement : la cha√Æne n‚Äôest pas remplie, et le programme peut continuer avec une valeur vide.\nPour √©viter les erreurs logiques (comme par exemple une boucle infinie), il est conseill√© de tester l‚Äô√©tat du flux avant d‚Äôutiliser la cha√Æne lue :\nstd::string ligne;\nif (std::getline(std::cin, ligne)) {\n    // OK : on peut utiliser `ligne`\n} else {\n    // Erreur ou fin de fichier\n}\n\nLe test if (std::getline(...)) est une mani√®re s√ªre de d√©tecter √† la fois EOF et les erreurs de lecture.\n\nPi√®ges du \\n\nSi on utilise std::cin &gt;&gt; juste avant std::getline, le caract√®re \\n laiss√© dans le flux par std::cin peut faire que std::getline lit une ligne vide.\nExemple du pi√®ge :\nint age;\nstd::cin &gt;&gt; age;         // saisie : 42\nstd::getline(std::cin, nom); // capte seulement le &#039;\\n&#039;\nSolution :\nAjouter une ligne pour vider le \\n :\nstd::cin.ignore();\nstd::getline(std::cin, nom);\nR√©sum√©\n\nstd::getline permet de lire une ligne enti√®re de texte dans une string, y compris les espaces.\nElle est indispensable d√®s qu‚Äôon attend une saisie textuelle libre, comme un nom complet, une phrase ou un message.\n"},"gmtime":{"slug":"gmtime","filePath":"gmtime.md","title":"gmtime","links":["biblioth√®que-standard-C++"],"tags":[],"content":"\nNom pleinement qualifi√© : std::gmtime\n\n\nLa fonction gmtime de la biblioth√®que standard C++ convertit un time_t (nombre de secondes) en une structure tm repr√©sentant la date UTC (temps universel).\n\nInclude\n#include &lt;ctime&gt;\nExemple\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::time_t now = std::time(0);\n    std::tm* utc = std::gmtime(&amp;now);\n \n    std::cout &lt;&lt; &quot;Ann√©e : &quot; &lt;&lt; 1900 + utc-&gt;tm_year &lt;&lt; std::endl;\n}\n\nRetourne un pointeur vers une structure tm remplie avec l‚Äôheure en temps universel (UTC).\n\nUsage concret\n\nR√©cup√©rer les composants de la date : ann√©e, mois, jour, heure, etc.\nUtiliser avec strftime pour formater la date\n"},"h√©ritage":{"slug":"h√©ritage","filePath":"h√©ritage.md","title":"h√©ritage","links":["programmation-orient√©e-objet","classe","objet","classe-de-base","classe-d√©riv√©e"],"tags":[],"content":"\nNom anglais: inheritance\n\n\nL‚Äôh√©ritage est un principe fondamental de la programmation orient√©e objet qui permet de cr√©er une nouvelle classe en r√©utilisant les √©l√©ments d‚Äôune classe existante. Cela permet de construire des hi√©rarchies d‚Äôobjets partageant des caract√©ristiques communes.\nComparaison avec le C: Le langage C n‚Äôa pas de m√©canisme d‚Äôh√©ritage natif. En C++, l‚Äôh√©ritage permet de structurer et de r√©utiliser du code de mani√®re plus propre et plus naturelle.\n\nPourquoi utiliser l‚Äôh√©ritage\nL‚Äôh√©ritage permet :\n\nde r√©utiliser le code existant,\nde organiser les classes en familles logiques,\nde sp√©cialiser ou compl√©ter des comportements existants.\n\nOn parle souvent de classe de base (ou de base) et de classe d√©riv√©e (ou d√©riv√©e).\nD√©finir un h√©ritage\nOn utilise le symbole : suivi du mot-cl√© d‚Äôacc√®s (public, private, ou protected) :\nclass Vehicule\n{\npublic:\n    void demarrer();\n};\n \nclass Voiture : public Vehicule\n{\npublic:\n    void ouvrirCoffre();\n};\nIci, Voiture h√©rite de Vehicule.\nVoiture poss√®de donc la m√©thode demarrer() en plus de ses propres m√©thodes.\nTypes d‚Äôh√©ritage\n\npublic : les √©l√©ments publics restent publics pour l‚Äôenfant.\nprotected : les √©l√©ments publics deviennent prot√©g√©s pour l‚Äôenfant.\nprivate : les √©l√©ments h√©rit√©s deviennent priv√©s pour l‚Äôenfant.\n\nLe plus courant est l‚Äôh√©ritage public.\nExemple\nVoiture v;\nv.demarrer();     // h√©rit√© de Vehicule\nv.ouvrirCoffre(); // d√©fini dans Voiture\nL‚Äôobjet v peut utiliser √† la fois ce qu‚Äôil a h√©rit√© et ce qui a √©t√© ajout√©."},"ifstream":{"slug":"ifstream","filePath":"ifstream.md","title":"ifstream","links":["classe","biblioth√®que-standard-C++","flux","C++","getline","M√©thode"],"tags":[],"content":"\nNom pleinement qualifi√© : std::ifstream\n\n\nstd::ifstream (input file stream) est une classe de la biblioth√®que standard C++ qui permet de lire des fichiers texte ou binaires.\nC‚Äôest un flux en lecture, analogue √† std::cin, mais connect√© √† un fichier.\nComparaison C / C++: En langage C, on utilise les fonctions comme fopen(), fgets(), fscanf() ou fclose() pour manipuler des fichiers. Ces fonctions n√©cessitent de g√©rer manuellement les pointeurs, les buffers de lecture (char[]) et les erreurs, ce qui les rend plus verbeuses et moins s√ªres. En C++, std::ifstream offre une interface orient√©e objet, qui fonctionne naturellement avec les types de la biblioth√®que standard C++ (comme std::string), et qui permet une lecture plus lisible, plus s√ªre, et mieux int√©gr√©e au langage. La gestion des fichiers repose sur le principe du RAII : le fichier est automatiquement ferm√© quand l‚Äôobjet std::ifstream sort de sa port√©e.\n\nInclude\nstd::ifstream appartient √† la biblioth√®que standard C++. Il faut mettre l‚Äôinclude:\n#include &lt;ifstream&gt;\nD√©claration et ouverture du fichier\nstd::ifstream fichier(&quot;nom.txt&quot;); // ouverture √† la d√©claration\nOu bien en deux √©tapes :\nstd::ifstream fichier;\nfichier.open(&quot;nom.txt&quot;);\nV√©rification d‚Äôouverture\nToujours tester l‚Äô√©tat du fichier :\nif (!fichier) {\n    std::cerr &lt;&lt; &quot;Erreur : impossible d‚Äôouvrir le fichier.&quot; &lt;&lt; std::endl;\n}\nLecture de contenu\nLire ligne par ligne avec getline:\nstd::string ligne;\nwhile (std::getline(fichier, ligne)) {\n    std::cout &lt;&lt; ligne &lt;&lt; std::endl;\n}\nLire mot par mot :\nstd::string mot;\nwhile (fichier &gt;&gt; mot) {\n    std::cout &lt;&lt; mot &lt;&lt; std::endl;\n}\nLire caract√®re par caract√®re :\nchar c;\nwhile (fichier.get(c)) {\n    std::cout &lt;&lt; c;\n}\nM√©thodes utiles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeR√¥leopen(&quot;nom&quot;)Ouvre un fichieris_open()V√©rifie si le fichier est ouvertclose()Ferme le fichiergetline(ifs, str)Lit une ligne enti√®reeof()Teste si fin de fichier atteintefail()Teste si une erreur est survenuegood()Teste si le flux est encore utilisable\nExemple complet\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::ifstream fichier(&quot;donnees.txt&quot;);\n    if (!fichier) {\n        std::cerr &lt;&lt; &quot;Erreur : impossible d‚Äôouvrir le fichier.&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n \n    std::string ligne;\n    while (std::getline(fichier, ligne)) {\n        std::cout &lt;&lt; ligne &lt;&lt; std::endl;\n    }\n \n    fichier.close(); // facultatif\n    return 0;\n}"},"inclusion-de-fichiers":{"slug":"inclusion-de-fichiers","filePath":"inclusion de fichiers.md","title":"inclusion de fichiers","links":["biblioth√®que-standard","syst√®me-d‚Äôexploitation"],"tags":[],"content":"Qu‚Äôest-ce que l‚Äôinclusion de fichier en C++?\n\nEn C++, l‚Äôinclusion permet d‚Äôajouter du contenu externe (d√©finitions de fonctions, classes, constantes‚Ä¶) dans ton fichier source.\n\nCela se fait avec la directive :\n#include\nSyntaxes possibles\nIl existe deux formes d‚Äôinclusion :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyntaxeUtilisationExemple#include &lt;fichier&gt;Inclure un fichier standard du syst√®me (biblioth√®que standard)#include &lt;iostream&gt;#include &quot;fichier&quot;Inclure un fichier personnel (header)#include &quot;mon_header.hpp&quot;\nDiff√©rences entre &lt;...&gt; et &quot;...&quot;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFormeD√©tail&lt;fichier&gt;Le compilateur cherche dans les r√©pertoires syst√®me uniquement pour utiliser une biblioth√®que standard.&quot;fichier&quot;Le compilateur cherche d‚Äôabord dans le r√©pertoire du projet (un header), puis dans les r√©pertoires syst√®me si non trouv√©.\nExemples :\n\n&lt;iostream&gt; ‚ûî trouv√© dans /usr/include ou /Library/Developer/CommandLineTools/usr/include/ (d√©pend du syst√®me d‚Äôexploitation).\n&quot;fonctions.hpp&quot; ‚ûî trouv√© dans un dossier personnel (ex: /projet/include/).\n\nPourquoi inclure des fichiers ?\n\nUtiliser des biblioth√®ques standards (iostream, vector, string, etc.).\nOrganiser ton projet en plusieurs fichiers (fonctions.hpp, fonctions.cpp, etc.).\nR√©utiliser du code sans tout r√©√©crire.\n\nExemple concret\nFichier fonctions.hpp :\n#ifndef FONCTIONS_HPP\n#define FONCTIONS_HPP\n \nint addition(int a, int b);\n \n#endif\nFichier fonctions.cpp :\n#include &quot;fonctions.hpp&quot;\n \nint addition(int a, int b) {\n    return a + b;\n}\nFichier main.cpp :\n#include &lt;iostream&gt;\n#include &quot;fonctions.hpp&quot;\n \nint main() {\n    std::cout &lt;&lt; addition(2, 3) &lt;&lt; std::endl;\n    return 0;\n}\nAttention : √©viter les inclusions multiples\nSi un fichier est inclus plusieurs fois, cela peut provoquer des erreurs.\n‚ûî Solution : prot√©ger avec un include guard ou utiliser #pragma once.\nM√©thode classique (include guards) :\n#ifndef MON_FICHIER_HPP\n#define MON_FICHIER_HPP\n \n// Contenu du header\n \n#endif\nM√©thode moderne :\n#pragma once\n(√âquivalent √† l‚Äôinclude guard mais plus simple.)\n\nüî• R√©sum√© ultra rapide\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPoint cl√©R√©sum√©ButR√©utiliser du code sans le r√©√©crire&lt;...&gt;Cherche dans les biblioth√®ques syst√®me&quot;...&quot;Cherche d‚Äôabord dans ton projetProt√©gerUtiliser #ifndef/#define/#endif ou #pragma once\n\nVeux-tu aussi que je te pr√©pare un exemple r√©el d‚Äôarchitecture de projet C++ montrant plusieurs fichiers et inclusions (include/, src/, etc.) ? üöÄ\n(√áa te donnerait une base propre √† recopier pour n‚Äôimporte quel futur projet !)"},"index":{"slug":"index","filePath":"index.md","title":"index","links":["C++","langage-compil√©","C++11","Module_00","Module_01","Module_02"],"tags":[],"content":"Cette collection d‚Äôarticles constitue une initiation au langage C++ tel que je l‚Äôai appris durant le tronc commun de l‚Äô√©cole42.\nA qui s‚Äôadressent ces articles?\nPrincipalement aux √©tudiants de 42 qui sont dans le quatri√®me cercle du tronc commun et qui commencent leur apprentissage du C++.\nMais ces articles peuvent int√©resser toute personne d√©sireuse d‚Äôapprendre le C++ √† condition de respecter le pr√©-requis suivants:\n\n‚Üí Disposer de connaissances minimales en langage C.\n\nSi vous ne disposez pas des notions de base en C, vous trouverez quelques notions expliqu√©es √† partir de l‚Äôarticle sur ce qu‚Äôest un langage compil√©, mais cette documentation reste pour l‚Äôheure tr√®s parcellaire.\nCe que ne sont pas ces articles\nCes articles pr√©sentent les concepts √† conna√Ætre pour r√©aliser les diff√©rents module C++ de 42. Ils ne donnent pas directement les solutions aux exercices.\nVous ne trouverez donc ni code complet, ni les fichiers que j‚Äôai moi-m√™me √©crits lors de mon cursus.\nComment sont organis√©s les articles?\nLes articles sont organis√©s par modules et par exercices; c‚Äôest √† dire qu‚Äôils pr√©sentent et expliquent les notions √† conna√Ætre afin de r√©aliser chaque exercice de chaque module C++ du cursus 42.\nIls sont donc class√©s de mani√®re progressive afin de ‚Äúcoller‚Äù √† la p√©dagogie par projet de l‚Äô√©cole 42.\nVersions du C++\nL‚Äôutilisation du C++11est interdit pour les premiers modules de d√©couverte du C++ √† l‚Äô√©cole 42. Seul les outils offerts par le C++98 seront abord√©s pour r√©pondre aux besoins de ces exercices.\nSommaire\n\nModule_00\nModule_01\nModule_02\n"},"interface-graphique":{"slug":"interface-graphique","filePath":"interface graphique.md","title":"interface graphique","links":[],"tags":[],"content":"Qu‚Äôest-ce que?"},"interpr√©teur-de-commande":{"slug":"interpr√©teur-de-commande","filePath":"interpr√©teur de commande.md","title":"interpr√©teur de commande","links":["terminal","syst√®me-d‚Äôexploitation","scripts","syntaxe"],"tags":[],"content":"Qu‚Äôest-ce qu‚Äôun interpr√©teur de commmande?\n\nUn interpr√©teur de commandes est un programme qui re√ßoit les instructions que l‚Äôutilisateur tape dans un terminal, les interpr√®te et les ex√©cute.\nC‚Äôest lui qui comprend des commandes comme ls, cd, mkdir, et qui demande au syst√®me d‚Äôexploitationde faire les actions correspondantes.\n\nEn r√©sum√©\n\nL‚Äôutilisateur √©crit une commande ‚ûî l‚Äôinterpr√©teur la traduit ‚ûî l‚Äôordinateur l‚Äôex√©cute.\nC‚Äôest l‚Äôinterface entre l‚Äôutilisateur et le syst√®me, via du texte.\nIl peut aussi ex√©cuter des scripts (s√©ries de commandes automatis√©es).\n\nExemples d‚Äôinterpr√©teurs de commandes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterpr√©teurCaract√©ristiquebashLe plus courant sur Linux et macOSzshPlus moderne, utilis√© par d√©faut sur macOS r√©centfishTr√®s convivial et intelligentcmd.exeAncien interpr√©teur de WindowsPowerShellInterpr√©teur avanc√© de Windows, plus moderne\n√Ä retenir\n\nLe terminal affiche ‚ûî l‚Äôinterpr√©teur comprend et agit.\nbash par exemple (ou zsh, ou fish) est un interpr√©teur de commande, pas un terminal.\nChaque interpr√©teur a ses petites diff√©rences de syntaxe et ses scripts propres.\n"},"interpr√©teur":{"slug":"interpr√©teur","filePath":"interpr√©teur.md","title":"interpr√©teur","links":["code-source","fichier-binaire","compilation","d√©bogage"],"tags":[],"content":"Qu‚Äôest-ce qu‚Äôun interpr√©teur?\n\nUn interpr√©teur est un programme qui lit le code source d‚Äôun autre programme ligne par ligne, le traduit imm√©diatement et l‚Äôex√©cute directement sans cr√©er d‚Äôex√©cutable (pas de fichier binaire).\nCela permet de tester rapidement du code sans passer par une √©tape de compilation.\n\nEn r√©sum√©\n\nLit et ex√©cute le code en temps r√©el.\nPas d‚Äôex√©cutable interm√©diaire (pas de fichier binaire) contrairement √† la compilation.\nUtile pour le d√©veloppement rapide et le d√©bogage.\n\nExemples d‚Äôinterpr√©teurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nInterpr√©teurLangagepythonPythonnodeJavaScript (c√¥t√© serveur)rubyRuby\n√Ä retenir\n\nAvec un interpr√©teur, le code source est ex√©cut√© directement.\nCela rend l‚Äôex√©cution plus flexible, mais souvent moins rapide qu‚Äôun programme compil√©.\n\nExemple\npython mon_script.py\n    ```"},"it√©rateur":{"slug":"it√©rateur","filePath":"it√©rateur.md","title":"it√©rateur","links":["conteneur","algorithmes-STL","STL"],"tags":[],"content":"\nNom anglais: iterator\n\n\nUn it√©rateur est un objet sp√©cial qui permet de parcourir les √©l√©ments d‚Äôun conteneur (comme un std::vector, std::list, etc.).\nC‚Äôest l‚Äô√©quivalent en C++ de ‚Äúpointeurs intelligents‚Äù qui permettent d‚Äôacc√©der aux √©l√©ments sans conna√Ætre leur structure interne.\nComparaison C/C++ : en C, on utilise des pointeurs pour parcourir un tableau. En C++, on utilise des it√©rateurs pour parcourir un conteneur.\n\n√Ä quoi √ßa sert ?\nUn it√©rateur sert √† :\n\nParcourir un conteneur du d√©but √† la fin (ou dans l‚Äôautre sens)\nLire ou modifier les valeurs contenues\nUtiliser les algorithmes STL (std::sort, std::find, etc.)\nNe pas d√©pendre du type ou de la structure du conteneur\n\nSyntaxe de base\nImaginons un std::vector v que l‚Äôon veut parcourir avec une boucle foren utilisant unn it√©rateur :\nstd::vector&lt;int&gt; v = {10, 20, 30};\n \nfor (std::vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); ++it) {\n\tstd::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\n\nv.begin() ‚Üí it√©rateur vers le premier √©l√©ment\nv.end() ‚Üí it√©rateur vers la fin (non valide) du conteneur\n*it ‚Üí acc√®de √† l‚Äô√©l√©ment point√©\n++it ‚Üí avance vers l‚Äô√©l√©ment suivant\n\nüìö Types d‚Äôit√©rateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTypeDescriptioniteratorLecture + √©critureconst_iteratorLecture seulereverse_iteratorParcours en sens inverseconst_reverse_iteratorParcours inverse en lecture seuleauto (depuis C++11)D√©duit automatiquement le type de l‚Äôit√©rateur\nExemples d‚Äôutilisation\nLecture avec auto\nfor (auto it = v.begin(); it != v.end(); ++it) {\n\tstd::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\nLecture seule (const)\nfor (std::vector&lt;int&gt;::const_iterator it = v.cbegin(); it != v.cend(); ++it) {\n\tstd::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\nParcours inverse\nfor (auto rit = v.rbegin(); rit != v.rend(); ++rit) {\n\tstd::cout &lt;&lt; *rit &lt;&lt; std::endl;\n}\n‚ö†Ô∏è Attention\n\nv.end() ne pointe pas vers le dernier √©l√©ment, mais un cran apr√®s\nNe pas faire *v.end() ‚ûù comportement ind√©fini\nModifier un conteneur pendant qu‚Äôon le parcourt invalide les it√©rateurs\n\nR√©sum√©\n\nLes it√©rateurs sont essentiels en C++ pour parcourir proprement les conteneurs de la STL.\nIls agissent comme des pointeurs g√©n√©riques et s√ªrs, et sont compatibles avec les algorithmes STL.\n"},"langage-compil√©":{"slug":"langage-compil√©","filePath":"langage compil√©.md","title":"langage compil√©","links":["code-source","fichier-binaire","/","compilation","langage-interpr√©t√©"],"tags":[],"content":"Qu‚Äôest ce qu‚Äôun langage compil√©\n\nUn langage compil√© est un langage de programmation dont le code source doit √™tre traduit en un fichier ex√©cutable (fichier binaire) par un compilateur (processus de compilation) avant de pouvoir √™tre lanc√© par l‚Äôordinateur.\n\nDiff√©rences avec un langage interpr√©t√©\nContrairement √† un langage interpr√©t√© (comme Python ou JavaScript), qui est lu et ex√©cut√© ligne par ligne par un interpr√©teur, un langage compil√© transforme tout le programme d‚Äôun coup en un fichier machine optimis√©, ce qui rend son ex√©cution plus rapide.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLangage compil√©Langage interpr√©t√©Code transform√© avant l‚Äôex√©cutionCode ex√©cut√© directementBesoin d‚Äôun compilateur (g++, clang++)Besoin d‚Äôun interpr√©teur (Python, Node.js)Ex√©cution rapideEx√©cution plus lenteExemples : C, C++, RustExemples : Python, JavaScript"},"langage-interpr√©t√©":{"slug":"langage-interpr√©t√©","filePath":"langage interpr√©t√©.md","title":"langage interpr√©t√©","links":["code-source","interpr√©teur","compilation"],"tags":[],"content":"Qu‚Äôest-ce qu‚Äôun langage interpr√©t√©?\n\nUn langage interpr√©t√© est un langage o√π le code sourceest lu et ex√©cut√© directement, ligne par ligne, par un interpr√©teur sans passer par une phase de compilation compl√®te.\n\nCela rend le d√©veloppement souvent plus rapide (pas besoin de compiler), mais l‚Äôex√©cution du programme est g√©n√©ralement plus lente qu‚Äôavec un langage compil√©, car chaque instruction est traduite √† la vol√©e pendant que le programme tourne.\nExemples de langages interpr√©t√©s\n\nPython\nJavaScript\nRuby\nPHP\n"},"lecture-et-√©criture-de-fichiers-en-C++":{"slug":"lecture-et-√©criture-de-fichiers-en-C++","filePath":"lecture et √©criture de fichiers en C++.md","title":"lecture et √©criture de fichiers en C++","links":["C++98","manipulation-de-position-dans-les-fichiers"],"tags":[],"content":"\nNom pleinement qualifi√©: fstream (lecture et √©criture de fichiers en C++)\n\n\nEn C++98, la gestion des fichiers se fait gr√¢ce aux classes de la biblioth√®que &lt;fstream&gt;.\nOn peut ouvrir, lire, √©crire et fermer des fichiers avec des objets de type ifstream, ofstream ou fstream.\nComparaison C/C++ : contrairement √† fopen() en C, le C++ propose une interface orient√©e objet, plus s√ªre et intuitive, pour manipuler les fichiers.\n\nInclude\nPour lire ou √©crire un fichier, il faut inclure :\n#include &lt;fstream&gt;\nClasses principales\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClasseR√¥lestd::ifstreamLecture uniquement (input file stream)std::ofstream√âcriture uniquement (output file stream)std::fstreamLecture et √©criture\nOuvrir un fichier\nstd::ifstream in(&quot;monfichier.txt&quot;);   // ouverture en lecture\nstd::ofstream out(&quot;resultat.txt&quot;);    // ouverture en √©criture\nstd::fstream file(&quot;donnees.txt&quot;, std::ios::in | std::ios::out); // lecture/√©criture\n‚ö†Ô∏è Tu peux aussi ouvrir le fichier plus tard avec .open() :\nstd::ifstream fichier;\nfichier.open(&quot;exemple.txt&quot;);\nLecture simple ligne par ligne\nstd::ifstream in(&quot;texte.txt&quot;);\nstd::string ligne;\n \nwhile (std::getline(in, ligne)) {\n\tstd::cout &lt;&lt; ligne &lt;&lt; std::endl;\n}\nin.close();\n√âcriture dans un fichier\nstd::ofstream out(&quot;log.txt&quot;);\n \nout &lt;&lt; &quot;Ceci est une ligne.&quot; &lt;&lt; std::endl;\nout &lt;&lt; &quot;Encore une autre.&quot; &lt;&lt; std::endl;\n \nout.close();\nV√©rification d‚Äôouverture\nToujours v√©rifier si un fichier est bien ouvert :\nstd::ifstream in(&quot;config.txt&quot;);\nif (!in) {\n\tstd::cerr &lt;&lt; &quot;Erreur : impossible d&#039;ouvrir le fichier.&quot; &lt;&lt; std::endl;\n}\nModes d‚Äôouverture (std::ios)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeSignificationstd::ios::inLecturestd::ios::out√âcriture (efface le fichier existant)std::ios::appAjout √† la fin (append)std::ios::truncTronque le fichier existant (d√©faut en out)std::ios::binaryMode binaire (par d√©faut = texte)\n‚ö†Ô∏è Attention\n\nNe pas oublier de fermer le fichier (.close())\nToujours v√©rifier l‚Äôouverture avec if (!fichier)\nL‚Äôouverture en std::ios::out efface le fichier existant par d√©faut\n\nManipulation de position\nPour les manipulations de position du curseur de lecture dans un fichier :\n‚Üí voir l‚Äôarticle manipulation de position dans les fichiers.\nR√©sum√©\n\nEn C++98, la lecture/√©criture de fichiers passe par ifstream, ofstream et fstream.\nIl faut inclure &lt;fstream&gt;, utiliser les bons modes (ios::in, ios::out, etc.),\net toujours v√©rifier que le fichier est bien ouvert.\n"},"liste-d'initialisation":{"slug":"liste-d'initialisation","filePath":"liste d'initialisation.md","title":"liste d'initialisation","links":["C++","constructeur","attribut","objet","fonction","r√©f√©rence","constructeur-par-d√©faut","structure","classe"],"tags":[],"content":"\nNom anglais : member initializer list\n\n\nUne liste d‚Äôinitialisation en C++ est une syntaxe sp√©ciale utilis√©e dans les constructeurs pour initialiser directement les attributs d‚Äôun objet, avant m√™me l‚Äôex√©cution du corps de la fonction.\nElle permet de garantir une initialisation efficace, s√ªre et d√©terministe, notamment pour les attributs constants (const), les r√©f√©rences, ou les objets sans constructeur par d√©faut.\nComparaison C/C++ : En C, les champs d‚Äôune structure sont souvent initialis√©s par affectation (=) apr√®s d√©claration. En C++, on pr√©f√®re les initialiser d√®s la construction √† l‚Äôaide d‚Äôune liste d‚Äôinitialisation, ce qui √©vite des appels inutiles √† des constructeur par d√©faut ou des copies.\n\n\nSyntaxe d‚Äôune liste d‚Äôinitialisation\nUne liste d‚Äôinitialisation suit la signature du constructeur et pr√©c√®de le corps de la fonction ({}) :\nNomDeLaClasse::NomDeLaClasse(type1 arg1, type2 arg2)\n    : attribut1(valeur1), attribut2(valeur2)\n{\n    // corps du constructeur (souvent vide si tout est initialis√© avant)\n}\n\nR√®gles de syntaxe\n\nChaque attribut est suivi de parenth√®ses contenant la valeur √† lui attribuer : attribut(valeur).\nLes initialisations sont s√©par√©es par des virgules.\nLa liste d‚Äôinitialisation commence par un : apr√®s la signature du constructeur.\nLe corps du constructeur est plac√© ensuite entre accolades {}, m√™me s‚Äôil est vide.\n\n\nExemple\nclass Voiture {\nprivate:\n    std::string _marque;\n    int _vitesse;\n    const int _id;\n \npublic:\n    Voiture(std::string marque, int vitesse, int id)\n        : _marque(marque), _vitesse(vitesse), _id(id) {}\n};\n\nPourquoi utiliser une liste d‚Äôinitialisation ?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRaisonExplicationEfficacit√©√âvite une double op√©ration (construction par d√©faut + affectation)Obligatoire pour certains membresLes const, les reference, et les membres sans constructeur par d√©faut doivent √™tre initialis√©s ainsiAppelle directement le bon constructeurUtile pour les objets membres d‚Äôautres classesCoh√©rence et lisibilit√©Centralise la logique d‚Äôinitialisation en un seul endroit\n\nMauvais exemple (affectation dans le corps)\nVoiture::Voiture(std::string marque, int vitesse, int id)\n{\n    _marque = marque;\n    _vitesse = vitesse;\n    _id = id; // ‚ùå Erreur : _id est const et ne peut √™tre affect√©\n}\n‚ö†Ô∏è Ici :\n\n_marque et _vitesse sont d‚Äôabord construits par d√©faut, puis r√©assign√©s.\n_id cause une erreur car on ne peut pas affecter une const apr√®s construction.\n\n\nBonnes pratiques\n\nToujours pr√©f√©rer la liste d‚Äôinitialisation pour les types complexes, les const, les reference, les classes personnalis√©es.\nR√©server l‚Äôaffectation dans le corps uniquement √† la logique m√©tier (c‚Äôest √† dire si √ßa fait partie de la raison d‚Äô√™tre du programme) ou aux cas exceptionnels.\n\n\nVoir aussi\n‚Üí constructeur, attribut,  r√©f√©rence, objet"},"liste":{"slug":"liste","filePath":"liste.md","title":"liste","links":["conteneur","STL","C++","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","it√©rateur","cache","allocateur"],"tags":[],"content":"\nNom anglais: list\nNom pleinement qualifi√©: std::list\n\n\nUne list est un conteneur s√©quentiel fourni par la STL en C++. Elle permet de stocker des √©l√©ments dans une liste doublement cha√Æn√©e, o√π chaque √©l√©ment conna√Æt son pr√©c√©dent et son suivant.\nElle offre des performances optimales pour les insertions et suppressions n‚Äôimporte o√π dans la s√©quence, mais au prix d‚Äôun acc√®s plus lent aux √©l√©ments par position.\nComparaison C/C++ : Une list est une version s√©curis√©e et g√©n√©ralis√©e d‚Äôune liste cha√Æn√©e en C. Elle g√®re :\n\nla m√©moire dynamiquement\nles liens entre les √©l√©ments\nles cas limites (d√©but/fin) automatiquement\n\n\n\nInclude\nPour utiliser std::list il faut l‚Äôinclusion suivante :\n#include &lt;list&gt;\n\nEspace de nom\nLes listes font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::list\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nPour d√©clarer une list il faut utiliser la syntaxe suivante :\nstd::list&lt;type&gt; myList;\n \n// exemple pour une liste d&#039;int :\nstd::list&lt;int&gt; myIntList;\n \n// exemple pour une liste de std::string :\nstd::list&lt;std::string&gt; myStringList;\n \n// exemple avec initialisation (C++98) :\nint arr[] = {1, 2, 3};\nstd::list&lt;int&gt; myList(arr, arr + 3); // copie depuis un tableau\nInitialisation\n‚Üí En C++98\nstd::list&lt;int&gt; l1;                     // liste vide\nstd::list&lt;int&gt; l2(5);                  // 5 √©l√©ments initialis√©s √† 0\nstd::list&lt;int&gt; l3(5, 42);              // 5 √©l√©ments valant 42\nint arr[] = {1, 2, 3};\nstd::list&lt;int&gt; l4(arr, arr + 3);       // copie depuis un tableau C\nstd::list&lt;std::string&gt; l5(3, &quot;ok&quot;);    // 3 √©l√©ments contenant &quot;ok&quot;\n‚Üí En C++11 et plus\nstd::list&lt;int&gt; l6 = {1, 2, 3};         // initialisation par liste\nstd::list&lt;std::string&gt; l7{&quot;a&quot;, &quot;b&quot;};   // initialisation par accolades\nstd::list&lt;int&gt; l8{10};                // une seule valeur : 10\nstd::list&lt;int&gt; l9{10, 5};             // deux valeurs : 10 et 5\n\n‚ö†Ô∏è Attention : contrairement √† std::vector, il n‚Äôy a aucune ambigu√Øt√© sur {10, 5} pour std::list (m√™me en C++11), car la syntaxe liste n‚Äôest pas surcharg√©e pour compter des √©l√©ments.\n\n\nImpl√©mentation interne\nUne list&lt;T&gt; encapsule :\n\nune liste doublement cha√Æn√©e\ndes n≈ìuds allou√©s dynamiquement, chaque n≈ìud contenant :\n\nun pointeur vers l‚Äô√©l√©ment pr√©c√©dent\nun pointeur vers l‚Äô√©l√©ment suivant\nla valeur elle-m√™me\n\n\nun pointeur vers le d√©but et la fin de la liste\n\n\nContrairement √† un vector, une list ne stocke pas les √©l√©ments en m√©moire contigu√´.\n\n\nListe et m√©moire\nLa std::list utilise une structure en n≈ìuds reli√©s dynamiquement, ce qui signifie :\n\nles √©l√©ments ne sont pas adjacents en m√©moire\nles acc√®s par index sont lents (O(n))\nmais les insertions et suppressions en n‚Äôimporte quelle position sont rapides (O(1) avec un it√©rateur)\n\nCela la rend peu efficace vis-√†-vis du cache, mais tr√®s souple pour des op√©rations complexes sur des s√©quences.\nLa m√©moire est allou√©e n≈ìud par n≈ìud, et chaque insertion implique un appel √† new (ou √† l‚Äôallocateur).\n\nQuand et pourquoi utiliser une liste\nUne liste (std::list) est particuli√®rement adapt√©e aux situations o√π l‚Äôon effectue de nombreuses insertions ou suppressions en milieu de s√©quence, ou lorsque la position des √©l√©ments est g√©r√©e via des it√©rateurs plut√¥t que des indices. Gr√¢ce √† sa structure en liste doublement cha√Æn√©e, elle permet ces op√©rations en temps constant (O(1)) d√®s lors qu‚Äôon dispose de l‚Äôit√©rateur correspondant. Elle est utile lorsque la performance d‚Äôacc√®s par index n‚Äôest pas cruciale, mais que la flexibilit√© de modification de la structure est primordiale (par exemple, dans les √©diteurs de texte, moteurs de r√®gles, ou gestion dynamique d‚Äô√©l√©ments).\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionsize()Retourne le nombre d‚Äô√©l√©mentsempty()V√©rifie si la liste est videfront() / back()Acc√®s au premier / dernier √©l√©mentmax_size()Nombre maximal th√©orique d‚Äô√©l√©ments (impl√©mentation d√©pendante)\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionpush_back(val)Ajoute un √©l√©ment √† la finpush_front(val)Ajoute un √©l√©ment au d√©butpop_back()Supprime le dernier √©l√©mentpop_front()Supprime le premier √©l√©mentinsert(pos, val)Ins√®re val √† la position poserase(pos)Supprime l‚Äô√©l√©ment √† la position posclear()Supprime tous les √©l√©mentsremove(val)Supprime toutes les occurrences de valremove_if(pred)Supprime tous les √©l√©ments pour lesquels pred est vrai\nIt√©rateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionbegin() / end()It√©rateurs sur le d√©but / fin de la listerbegin() / rend()It√©rateurs invers√©s\n\nLes it√©rateurs permettent un parcours standard avec for, std::find, etc.\n\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionassign(n, val)Remplit la liste avec n copies de valoperator=Affecte une autre liste\nOp√©rations sp√©cifiques aux listes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionsort()Trie la listemerge(other)Fusionne avec une autre liste tri√©ereverse()Inverse l‚Äôordre des √©l√©mentsunique()Supprime les doublons cons√©cutifssplice(pos, other)D√©place les √©l√©ments d‚Äôune autre liste\n\nRemarques importantes\n\nstd::list est id√©ale si le programme requiert de nombreuses insertions et suppressions au milieu\nLes acc√®s par index sont tr√®s lents (O(n)) car il n‚Äôy a pas d‚Äôacc√®s direct\nLes it√©rateurs sont stables : ils restent valides tant que l‚Äô√©l√©ment n‚Äôest pas supprim√©\nContrairement √† vector, list n‚Äôest pas cache-friendly car les √©l√©ments sont dispers√©s en m√©moire\n"},"lowerCamelCase":{"slug":"lowerCamelCase","filePath":"lowerCamelCase.md","title":"lowerCamelCase","links":["convention-de-nommage","fonction","m√©thode","variable","attribut","variable-locale","priv√©","prot√©g√©","C++"],"tags":[],"content":"\nNom anglais: lowerCamelCase\n\n\nLe lowerCamelCase est une convention de nommage utilis√©e pour nommer les fonctions, m√©thodes, variables ou attributs.\nLe premier mot commence par une minuscule, puis chaque mot suivant commence par une majuscule, et les mots sont coll√©s sans s√©parateurs.\n\n\nExemples\nint compteurTotal;\nvoid afficherResultat();\nstd::string nomFichier;\n\nUsage en C++\nLa convention de nommage lowerCamelCase est g√©n√©ralement utilis√©e pour :\n\nfonction void\nm√©thode de classe\nvariable locale\nattribut priv√© ou prot√©g√© (parfois avec suffixe _)\n\n\nComparaison avec d‚Äôautres styles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStyleExempleUsage typiqueUpperCamelCaseMaClasseClasses, typeslowerCamelCasemaVariableFonctions, variables, m√©thodessnake_casema_variableVariables (C), fichiersSCREAMING_SNAKE_CASETAILLE_MAXConstantes, macros\n\nR√©sum√©\n\nLe lowerCamelCase est un style d‚Äô√©criture en C++ o√π le premier mot est en minuscule, et les suivants commencent par une majuscule.\nIl permet de diff√©rencier visuellement les fonctions et variables des types (class, struct, etc.) tout en gardant une √©criture compacte et lisible.\n"},"macro":{"slug":"macro","filePath":"macro.md","title":"macro","links":["compilation","fonction","bloc","compilateur","C++","surcharge"],"tags":[],"content":"\nNom anglais : macro\n\n\nUne macro est une instruction du pr√©processeur (et non du compilateur) qui permet de substituer du texte avant la compilation.\nLes macros sont d√©finies avec la directive #define et peuvent servir √† d√©finir des constantes, des fonctions simples ou des blocs conditionnels.\nComparaison C/C++: les macros existent dans les deux langages.\n\nSyntaxe\n#define NOM valeur\n#define CARRE(x) ((x) * (x))\n\nNOM sera remplac√© partout dans le code source par valeur\nCARRE(x) sera remplac√© par ((x) * (x))\n\nExemples\n#define PI 3.14159\n#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))\n \nint rayon = 5;\nfloat surface = PI * rayon * rayon;\n√Ä savoir\n\nContrairement aux fonctions normales en C/C++, les macros sont des substitutions textuelles*, r√©alis√©es par le pr√©processeur, avant la compilation. Elles ne sont pas v√©rifi√©es par le compilateur comme des fonctions typ√©es.\n\n\nLes macros sont trait√©es avant la compilation (phase de pr√©processeur)\nElles ne respectent pas le typage : attention aux erreurs inattendues\nEn C++, on pr√©f√®re souvent utiliser const ou inline √† la place des macros\n\nCons√©quences\n\nPas de v√©rification de type :\nLe compilateur n‚Äôexige pas que les arguments aient un type pr√©cis, car pour lui ce ne sont que des morceaux de texte.\nPas de surcharge :\nOn ne peut pas faire de macro ‚Äúdiff√©rente‚Äù pour int, float, etc.\nComportements inattendus si mal prot√©g√©e :\nSi on oublie des parenth√®ses, le r√©sultat peut changer selon les priorit√©s d‚Äôop√©rateurs.\n\nExemple probl√©matique\n#define CARRE(x) x * x\n \nint a = 3 + 1;\nint res = CARRE(a);  // devient : 3 + 1 * 3 + 1 = 3 + 3 + 1 = 7 \n‚Üí Le r√©sultat devrait √™tre 16, mais on obtient 7 √† cause de l‚Äôordre des op√©rations.\nBonne pratique :\n#define CARRE(x) ((x) * (x))  // encapsuler chaque argument\nComparaison avec inline\ninline int carre(int x) { return x * x; }\n\nv√©rifie que x est bien un int\n√©vite les erreurs d‚Äôordre de priorit√©\nrespecte les r√®gles de type et de port√©e\n\nR√©sum√©\n\nLes macros sont des outils puissants mais bas niveau pour remplacer du code automatiquement avant la compilation.\nElles sont utiles pour les valeurs constantes, les tests conditionnels (#ifdef, #ifndef), ou les fonctions simples sans surcharge.\n"},"manipulateur-de-flux":{"slug":"manipulateur-de-flux","filePath":"manipulateur de flux.md","title":"manipulateur de flux","links":["biblioth√®que-standard-C++","flux","cout","C++","objet","fonction","flush","Flush"],"tags":[],"content":"\nNom anglais: stream manipulator\n\n\nUn manipulateur de flux est une fonction sp√©ciale fournie par la biblioth√®que standard C++ que l‚Äôon peut ins√©rer dans un flux (comme std::cout - voir cout) pour modifier son comportement ou formater l‚Äôaffichage, sans √©crire de fonction personnalis√©e.\nIl s‚Äôutilise comme une valeur, mais il agit sur le flux.\nComparaison C/C++: En C, il n‚Äôexiste pas de manipulateurs de flux ‚Äî l‚Äôaffichage se fait uniquement via des fonctions comme printf() qui utilisent des modificateurs de format (comme %d, %f, \\n, etc.) dans la cha√Æne de caract√®res. En C++ les manipulateurs de flux (comme std::endl, std::setw, std::hex‚Ä¶) sont des objets/fonctions sp√©cialis√©s ins√©r√©s dans un flux (std::cout) pour modifier son comportement ou formater l‚Äôaffichage.\n\nExemples courants\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nManipulateurEffet principalstd::endlSaut de ligne + flushstd::flushFlush (sans saut de ligne)std::setw(n)Fixe la largeur du champstd::setprecision(n)Fixe le nombre de chiffres affich√©sstd::hex, std::dec, std::octChange la base d‚Äôaffichage des entiers\nUtilisation\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt; // pour setw, setprecision, etc.\n \nstd::cout &lt;&lt; std::setw(10) &lt;&lt; 42;      // affiche &quot;        42&quot;\nstd::cout &lt;&lt; std::setprecision(3) &lt;&lt; 3.14159; // affiche &quot;3.14&quot;\nstd::cout &lt;&lt; std::hex &lt;&lt; 255;         // affiche &quot;ff&quot;\nIls sont ins√©r√©s directement dans la cha√Æne d‚Äôaffichage, comme des instructions discr√®tes.\nR√©sum√©\n\nUn manipulateur de flux est une fonction standard utilis√©e dans un flux pour contr√¥ler l‚Äôaffichage, formater les donn√©es ou d√©clencher des actions (comme  flush).\nIls rendent le code plus lisible et puissant.\n"},"manipulation-de-position-dans-les-fichiers":{"slug":"manipulation-de-position-dans-les-fichiers","filePath":"manipulation de position dans les fichiers.md","title":"manipulation de position dans les fichiers","links":["C++98"],"tags":[],"content":"\nNom pleinement qualifi√©: manipulation de position dans les fichiers (seekg, seekp, tellg, tellp)\n\n\nEn C++98, les flux de fichiers permettent de manipuler la position du curseur de lecture (get) ou d‚Äô√©criture (put).\nCela permet par exemple de sauter des parties d‚Äôun fichier, d‚Äôaller √† la fin, ou de revenir au d√©but.\n\nInclude\n#include &lt;fstream&gt;\nFonctions principales\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionseekg(pos)D√©place le curseur de lecture (get position)seekp(pos)D√©place le curseur d‚Äô√©criture (put position)tellg()Renvoie la position actuelle du curseur de lecturetellp()Renvoie la position actuelle du curseur d‚Äô√©criture\nüì• Lecture : seekg et tellg\nstd::ifstream in(&quot;texte.txt&quot;);\n \nin.seekg(0); // retourne au d√©but\nstd::streampos pos = in.tellg(); // position actuelle (0)\n \nin.seekg(10); // va au 10e octet\nchar c;\nin &gt;&gt; c;\nstd::cout &lt;&lt; &quot;Caract√®re √† la position 10 : &quot; &lt;&lt; c &lt;&lt; std::endl;\n \nin.close();\nüìù √âcriture : seekp et tellp\nstd::ofstream out(&quot;donnees.txt&quot;);\n \nout.seekp(5); // √©crit √† partir du 6e octet\nout &lt;&lt; &quot;X&quot;;\n \nstd::streampos p = out.tellp();\nstd::cout &lt;&lt; &quot;Position actuelle : &quot; &lt;&lt; p &lt;&lt; std::endl;\n \nout.close();\nüéØ Avec offset (second argument facultatif)\nLes fonctions seekg et seekp acceptent un d√©calage (offset) et un point de d√©part :\nin.seekg(0, std::ios::beg); // d√©but\nin.seekg(-2, std::ios::end); // 2 octets avant la fin\nin.seekg(5, std::ios::cur); // 5 octets apr√®s la position actuelle\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConstanteSignificationstd::ios::begDepuis le d√©but du fichierstd::ios::curDepuis la position actuellestd::ios::endDepuis la fin du fichier\n‚ö†Ô∏è Attention\n\nCes fonctions manipulent des positions en octets, pas en caract√®res.\nSur les fichiers texte, certains comportements peuvent d√©pendre du syst√®me (ex: \\r\\n).\nElles ne fonctionnent pas toujours de mani√®re fiable en mode texte ‚Üí pr√©f√©rer mode binaire (std::ios::binary) pour un positionnement pr√©cis.\n\nR√©sum√©\n\nüìå En C++98, tu peux manipuler la position dans un fichier avec seekg, seekp, tellg, tellp.\nCela te donne un contr√¥le pr√©cis du curseur de lecture ou d‚Äô√©criture, utile pour naviguer dans un fichier sans tout lire/sauter.\n"},"membre-statique":{"slug":"membre-statique","filePath":"membre statique.md","title":"membre statique","links":["attribut","m√©thode","classe","membre","objet","C++98","publique","op√©rateur","fonction","this","priv√©","prot√©g√©"],"tags":[],"content":"\nNom anglais: static member\n\n\nUn membre statique (ou membre de classe) est un attribut ou une m√©thode d√©clar√© avec le mot-cl√© static √† l‚Äôint√©rieur d‚Äôune classe.\nContrairement aux membres ordinaires, un membre statique n‚Äôappartient pas √† une instance (pas √† un objet) mais √† la classe elle-m√™me.\nIl est partag√© par toutes les instances de cette classe.\n\n\nAttribut statique\nUn attribut statique est une variable commune √† toutes les instances. Il n‚Äôexiste qu‚Äôen une seule copie, peu importe le nombre d‚Äôobjets cr√©√©s.\n\nContrairement √† un attribut classique, un attribut statique n‚Äôexiste qu‚Äôen un seul exemplaire, partag√© par tous les objets de la classe.\nAinsi, si sa valeur est modifi√©e ‚Äî que ce soit depuis un objet ou directement depuis la classe ‚Äî cette modification affecte tous les objets, car ils acc√®dent tous √† la m√™me variable partag√©e.\n\nD√©claration\nIl est d√©clar√© avec le mot cl√© static\nclass Compteur {\npublic:\n    static int totalObjets;\n};\nInitialisation\nIl faut ensuite l‚Äôinitialiser en dehors de la classe (obligatoire en C++98). Lors de l‚Äôinitialisation, on ne r√©p√®te pas le mot cl√© static :\nint Compteur::totalObjets = 0;\nAcc√®s\nIl peut √™tre lu ou modifi√© sans cr√©er d‚Äôobjet √† condition d‚Äô√™tre d√©clar√© dans la partie publique de la classe. On y acc√®de avec la syntaxe suivante :\nNomDeLaClasse::nomDeLAttributStatique\n \n// exemple :\nstd::cout &lt;&lt; Compteur::totalObjets &lt;&lt; std::endl;\n\nL‚Äôacc√®s √† un attribut statique via un objet suivi de l‚Äôop√©rateur . est autoris√©, mais d√©conseill√© :  on pr√©f√®re toujours passer par NomDeLaClasse::attribut.\n\n\nM√©thode statique\nUne m√©thode statique est une fonction associ√©e √† la classe, et non √† un objet particulier.\n\nUne m√©thode statique ne peut pas acc√©der aux attributs non statiques (car elle ne re√ßoit aucun this).\n\nD√©claration\nLe prototype de fonction est d√©clar√© dans la classe pr√©c√©d√©e du mot cl√© static :\nclass Util {\npublic:\n    static void direBonjour();\n};\nD√©finition\nLa fonction est ensuite d√©finie comme d‚Äôhabitude, sans le mot cl√© static :\nvoid Util::direBonjour() {\n    std::cout &lt;&lt; &quot;Bonjour !&quot; &lt;&lt; std::endl;\n}\nUne m√©thode statique peut √©galement √™tre d√©finie directement √† l‚Äôint√©rieur de la classe (si le corps est court). Elle est alors consid√©r√©e comme inline :\nclass Util {\npublic:\n\tstatic void direBonjour() {std::cout &lt;&lt; &quot;Bonjour !&quot; &lt;&lt; std::endl;}\n};\nAcc√®s\nSi la m√©thode est d√©clar√©e dans la partie publique de la classe, elle peut √™tre appel√©e directement via le nom de la classe suivi de ::, sans cr√©er d‚Äôobjet :\nUtil::direBonjour(); // accessible uniquement si la m√©thode est publique\n\nSi la m√©thode est priv√©e ou prot√©g√©e, elle reste accessible sans objet, mais uniquement depuis l‚Äôint√©rieur de la classe (ou de ses classes d√©riv√©es pour protected).\n\n\nUsages courants\n\nSuivre un compteur global d‚Äôinstances cr√©√©es\nFournir une fonction utilitaire li√©e √† la classe\nPartager des param√®tres ou ressources communs\nCr√©er des ‚Äúsingletons‚Äù ou des objets uniques\n\n\nR√©capitulatif\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n√âl√©mentStatique ?Accessible via objet ?Accessible via classe ?Attributouioui (mais d√©conseill√©)ouiM√©thodeouinonouiAttributnonouinonM√©thodenonouinon\n\nRemarques\n\nUn membre statique est souvent accompagn√© d‚Äôune initialisation hors de la classe, sauf s‚Äôil est const de type primitif.\nL‚Äôacc√®s √† un membre statique via un objet est autoris√© mais pas recommand√© (pr√©f√©rer MaClasse::membre).\n\n\nNe pas confondre : membre statique vs variable ou fonction statique\nAttention: Le mot-cl√© static peut d√©signer des notions tr√®s diff√©rentes selon le contexte. Il est donc essentiel de ne pas confondre ces notions qui sont compl√®tement diff√©rentes de la notion de membre statique, bien qu‚Äôelles utilisent le m√™me mot-cl√© static :\n\nvariable statique\nfonction statique\n\n1. Variable statique locale (dans une fonction)\n\nUne variable static d√©clar√©e √† l‚Äôint√©rieur d‚Äôune fonction conserve sa valeur entre les appels, mais reste invisible √† l‚Äôext√©rieur.\n\nvoid compteur() {\n    static int appel = 0;  // persiste entre les appels\n    appel++;\n}\n2. Fonction statique libre (fichier .cpp)\n\nUne fonction d√©clar√©e static en dehors d‚Äôune classe, dans un fichier .cpp, a une liaison interne (internal linkage) :\nelle est limit√©e au fichier et ne peut pas √™tre appel√©e d‚Äôun autre fichier.\n\nstatic void helper() {\n    // fonction visible uniquement dans ce fichier .cpp\n}\n\nVoir aussi\n‚Üí classe, attribut, m√©thode, objet"},"membre":{"slug":"membre","filePath":"membre.md","title":"membre","links":["classe","attribut","m√©thode","C++","objet","type-interne","classe-imbriqu√©e","contr√¥les-d'acc√®s","priv√©","publique","membre"],"tags":[],"content":"\nNom anglais: member\n\n\nUn membre est un √©l√©ment qui appartient √† une classe ou √† une structure (struct). En C++, un membre peut √™tre un attribut, une m√©thode, ou m√™me un type interne.\nComparaison C/C++ : En C, les membres d‚Äôune struct sont uniquement des variables. En C++, les membres peuvent √™tre des donn√©es ou des fonctions.\n\nTypes de membres en C++\n\nattribut : un membre qui repr√©sente une variable de l‚Äôobjet.\nm√©thode : un membre qui est une fonction li√©e √† l‚Äôobjet.\ntype interne : comme une classe imbriqu√©e).\n\nExemple\nclass Voiture\n{\nprivate:\n    int vitesse;        // membre (attribut)\npublic:\n    void demarrer();    // membre (m√©thode)\n};\nDans Voiture, vitesse et demarrer() sont des membres.\nR√©sum√©\nUn membre est tout ce qui est contenu dans une classe ou une struct.\nLes contr√¥les d‚Äôacc√®s(priv√© ou publique) d√©finissent qui peut voir ou utiliser les membres."},"mutateur":{"slug":"mutateur","filePath":"mutateur.md","title":"mutateur","links":["m√©thode","classe","attribut","priv√©"],"tags":[],"content":"\nNom anglais: setter / mutator\n\n\nUn mutateur (setter) est une m√©thode sp√©ciale d‚Äôune classe qui permet de modifier la valeur d‚Äôun attribut priv√© de mani√®re contr√¥l√©e.\nComparaison avec le C: En C, on modifie directement les membres d‚Äôune structure. En C++, on utilise des mutateurs pour encadrer et s√©curiser la modification des donn√©es.\n\nPourquoi utiliser un mutateur\nLes attributs sont g√©n√©ralement prot√©g√©s en priv√©. Un mutateur fournit un moyen encadr√© pour modifier ces valeurs, en permettant par exemple d‚Äôajouter des v√©rifications avant l‚Äôaffectation.\nD√©finir un mutateur\nUn mutateur est une m√©thode publique qui prend une valeur en param√®tre et l‚Äôassigne √† un attribut priv√© :\nclass Voiture\n{\nprivate:\n    int vitesse;\n \npublic:\n    void setVitesse(int nouvelleVitesse)\n    {\n        vitesse = nouvelleVitesse;\n    }\n};\nLe mutateur setVitesse permet de modifier la vitesse de l‚Äôobjet.\nUtiliser un mutateur\nPour utiliser un mutateur :\nVoiture v;\nv.setVitesse(120);\nCela modifie la valeur de vitesse de l‚Äôobjet v de mani√®re s√©curis√©e.\nExemple\nUn mutateur classique suit la convention de nommage setNomDeLAttribut :\n\nsetCouleur(string c)\nsetMarque(string m)\nsetVitesse(int v)\n\nChacun permet de modifier l‚Äôattribut correspondant."},"m√©thode-virtuelle":{"slug":"m√©thode-virtuelle","filePath":"m√©thode virtuelle.md","title":"m√©thode virtuelle","links":[],"tags":[],"content":""},"m√©thode":{"slug":"m√©thode","filePath":"m√©thode.md","title":"m√©thode","links":["fonction","membre","classe","objet","structure","C++","attribut","this","publique","priv√©","prot√©g√©","organisation-des-fichiers-d'une-classe","m√©thode","membre-statique","constructeur","liste-d'initialisation","surcharge","destructeur","encapsulation","accesseur","mutateur","compilateur","surcharge-de-fonction","classe-d√©riv√©e","polymorphisme","m√©thode-virtuelle","m√©thode-statique","m√©thode-const","programmation-orient√©e-objet","Accesseur"],"tags":[],"content":"\nNom anglais : method / member function\n\n\nUne m√©thode est une fonction membre d‚Äôune classe. Elle permet de d√©finir un comportement que chaque objet issu de cette classe pourra ex√©cuter.\nComparaison C/C++ : En C, les fonctions sont s√©par√©es des structures. En C++, une m√©thode est li√©e √† une classe et peut acc√©der aux attributs de l‚Äôobjet gr√¢ce au pointeur this.\n\n\nM√©thodes et classes\nLes m√©thodes sont d√©clar√©es dans la classe et permettent aux objets d‚Äôeffectuer des actions, de manipuler leurs attributs ou d‚Äôinteragir avec d‚Äôautres objets.\nclass Voiture {\nprivate:\n    int _vitesse;\n \npublic:\n    void accelerer();       // d√©claration de m√©thode\n    void freiner();         // autre m√©thode\n};\n\nD√©claration et d√©finition d‚Äôune m√©thode\nUne m√©thode est g√©n√©ralement d√©clar√©e (via son prototype) √† l‚Äôint√©rieur de la classe, dans la section publique, priv√©e ou prot√©g√©e selon le niveau d‚Äôacc√®s souhait√©.\nElle peut ensuite √™tre d√©finie (c‚Äôest-√†-dire impl√©ment√©e) de deux fa√ßons :\n\ndirectement dans la classe (d√©finition inline), ce qui est possible mais souvent d√©conseill√© pour les m√©thodes non triviales\nen dehors de la classe, g√©n√©ralement dans le fichier .cpp, en la pr√©c√©dant du nom de la classe suivi de ::\n\n// D√©finition de la m√©thode accelerer dans le fichier .cpp\nvoid Voiture::accelerer() {\n    _vitesse += 10;\n}\n\nCela permet de s√©parer clairement l‚Äôinterface (dans le .hpp) et l‚Äôimpl√©mentation (dans le .cpp), ce qui est une bonne pratique (et une exigence √† 42).\n\n‚Üí Voir la fiche d√©di√©e : organisation des fichiers d‚Äôune classe\n\nAppel d‚Äôune m√©thode\nOn appelle une m√©thode via un objet en utilisant l‚Äôop√©rateur .\nVoiture v;\nv.accelerer(); // appel de la m√©thode accelerer sur l‚Äôobjet v\n\nM√©thodes et acc√®s aux attributs\nUne m√©thode peut acc√©der :\n\naux attributs priv√©s ou prot√©g√©s de sa propre classe\n√† d‚Äôautres m√©thodes ou attributs via le pointeur implicite this\n\n\nM√©thodes constantes\nUne m√©thode constante est une m√©thode qui ne modifie pas l‚Äô√©tat de l‚Äôobjet sur lequel elle est appel√©e. On la d√©clare en ajoutant le mot-cl√© const apr√®s la parenth√®se de la signature.\nSi une m√©thode ne modifie pas l‚Äô√©tat de l‚Äôobjet, elle peut (et doit) √™tre marqu√©e const. Cela signifie que la m√©thode ne peut pas modifier les attributs de l‚Äôobjet, ni appeler d‚Äôautres m√©thodes non const.\nLes m√©thodes constantes peuvent √™tre appel√©es sur des objets const, ce qui est impossible pour une m√©thode non marqu√©e const.\nint getVitesse() const; // garantit de ne pas modifier l&#039;objet *this\n\nM√©thodes statiques\nUne m√©thode statique appartient √† la classe elle-m√™me, et non √† un objet particulier.\nElle ne peut pas acc√©der aux attributs non statiques, car elle ne re√ßoit pas de pointeur this.\nclass Outils {\npublic:\n    static void aide(); // m√©thode statique\n};\n \nOutils::aide(); // appel sans objet\n‚Üí Voir la fiche d√©di√©e : membre statique\n\nConstructeurs\nUn constructeur est une m√©thode sp√©ciale appel√©e automatiquement √† la cr√©ation d‚Äôun objet.\nIl initialise les attributs et peut utiliser une liste d‚Äôinitialisation.\nVoiture::Voiture(int v) : _vitesse(v) {}\nIl peut exister plusieurs constructeurs, avec des param√®tres diff√©rents (voir surcharge).\n‚Üí Voir la fiche d√©di√©e : constructeur\n\nDestructeurs\nUn destructeur est une m√©thode sp√©ciale appel√©e automatiquement √† la destruction de l‚Äôobjet.\nIl permet de lib√©rer des ressources (m√©moire, fichiers‚Ä¶).\n~Voiture(); // syntaxe\n‚Üí Voir la fiche d√©di√©e : destructeur\n\nAccesseurs et mutateurs\nCe sont des m√©thodes d√©clar√©s en section publique (public), qui permettent d‚Äôacc√©der aux attributs priv√©s ou prot√©g√©s de mani√®re contr√¥l√©e en respectant l‚Äôencapsulation.\n\nUn accesseur (getter) permet de lire la valeur d‚Äôun attribut.\nUn mutateur (setter) permet de modifier sa valeur.\n\nExemple :\nclass Personne {\nprivate:\n    std::string _nom;\n \npublic:\n    // Setter : modifie la valeur de _nom\n    void setNom(const std::string&amp; nom) {\n        _nom = nom;\n    }\n    // Getter : retourne la valeur de _nom\n    const std::string&amp; getNom() const {\n        return _nom;\n    }\n};\n‚Üí Voir les fiches d√©di√©es : accesseur, mutateur\n\nSurcharge de m√©thode\nLe C++ autorise plusieurs m√©thodes avec le m√™me nom mais des signatures diff√©rentes (nombre ou type de param√®tres). Le compilateur choisit automatiquement la plus adapt√©es en fonction des arguments pass√©s lors de l‚Äôappel.\n// m√©thode sans argument :\nvoid afficher();        \n \n// surcharge: m√©thode suppl√©mentaire de m√™me nom, avec un param√®tre de type std::string :\nvoid afficher(std::string nom);  \n‚Üí Voir les fiches d√©di√©es : surcharge et surcharge de fonction\n\nM√©thodes virtuelles\nUne m√©thode virtuelle est une m√©thode qui peut √™tre red√©finie dans une classe d√©riv√©e.\nElle permet le polymorphisme en C++.\nvirtual void parler();\n‚Üí Voir la fiche d√©di√©e : m√©thode virtuelle\n\nVoir aussi\n‚Üí classe, objet, fonction, attribut, constructeur, destructeur, accesseur, mutateur, m√©thode statique, m√©thode virtuelle, m√©thode const, surcharge de fonction, polymorphisme\nSouhaites-tu que je te g√©n√®re maintenant une fiche sp√©cifique pour l‚Äôune des m√©thodes particuli√®res list√©es ici ?\n\n\nNom anglais: method\n\n\n\nUne m√©thode est une fonction d√©finie √† l‚Äôint√©rieur d‚Äôune classe. Elle d√©crit une action qu‚Äôun objet peut effectuer ou une op√©ration qu‚Äôil peut subir.\nComparaison avec le C: En C, on d√©finit des fonctions ind√©pendantes. En C++, les m√©thodes sont attach√©es √† des objets et peuvent agir directement sur leurs attributs.\n\nR√¥le des m√©thodes\nLes m√©thodes permettent aux objets :\n\nd‚Äôinteragir avec leurs propres attributs,\nde r√©aliser des comportements sp√©cifiques,\nde r√©pondre √† des actions ext√©rieures.\n\nLes m√©thodes font partie int√©grante de ce qui rend la programmation orient√©e objet si puissante. Elles permettent de lier donn√©es et comportements dans un m√™me ensemble coh√©rent.\nD√©finir une m√©thode\nUne m√©thode est d√©clar√©e √† l‚Äôint√©rieur de la classe :\nclass Voiture\n{\npublic:\n    void demarrer(); // d√©claration de la m√©thode\n};\nElle est ensuite d√©finie (g√©n√©ralement en dehors de la classe) :\nvoid Voiture::demarrer()\n{\n    // Code pour d√©marrer la voiture\n}\nUtiliser une m√©thode\nOn appelle une m√©thode sur un objet avec l‚Äôop√©rateur point (.) :\nVoiture v;\nv.demarrer();\nCela ex√©cute l‚Äôaction associ√©e pour cet objet pr√©cis.\nM√©thodes particuli√®res\nSelon leur r√¥le, on distingue plusieurs usages particuliers de m√©thodes :\n\naccesseur (getter) : m√©thode qui lit un attribut.\nmutateur (setter) : m√©thode qui modifie un attribut.\nM√©thodes d‚Äôaction : m√©thodes qui font agir l‚Äôobjet sans n√©cessairement lire ou modifier un attribut (ex: d√©marrer(), freiner()).\n\n\nRemarque : Accesseur et mutateur ne sont pas des types diff√©rents de m√©thode ; ce sont des usages particuliers de la m√©thode.\n"},"nom-pleinement-qualifi√©":{"slug":"nom-pleinement-qualifi√©","filePath":"nom pleinement qualifi√©.md","title":"nom pleinement qualifi√©","links":["espace-de-noms"],"tags":[],"content":"\nNom anglais: fully qualified name\n\n\nUn nom pleinement qualifi√© (ou fully qualified name) est un nom qui inclut l‚Äôespace de noms  (on dit aussi de son contexte) dans lequel un √©l√©ment est d√©fini.\nIl permet de d√©signer un √©l√©ment **de mani√®re pr√©cise et sans ambigu√Øt√©, m√™me s‚Äôil existe ailleurs un autre du m√™me nom.\nComparaison C/C++: le concept de nom pleinement qualifi√© n‚Äôexiste pas en C, car le langage ne dispose pas d‚Äôespace de nom\n\nExemple\nstd::cout &lt;&lt; &quot;Bonjour&quot;;\n\ncout est d√©fini dans l‚Äô espace de noms (namespace) std\nSon nom pleinement qualifi√© est donc std::cout\n\nPourquoi l‚Äôutiliser\n\nPour √©viter les conflits de noms\nPour √™tre explicite sur la provenance d‚Äôun √©l√©ment\nUtile quand plusieurs √©l√©ments du m√™me nom existent dans des contextes diff√©rents\n\nAutre exemple\nmath::calcul();        // appelle calcul dans le namespace math\nphysique::calcul();    // appelle une autre fonction calcul\nR√©sum√©\n\nUn nom pleinement qualifi√© est un nom pr√©c√©d√© de son espace de noms (ou de son contexte), utilis√© pour identifier clairement un √©l√©ment parmi plusieurs portant le m√™me nom.\n"},"objet":{"slug":"objet","filePath":"objet.md","title":"objet","links":["classe","attribut","m√©thode","structure","fonction","C++","compilateur","constructeur","constructeur-par-d√©faut","objet","pile","constructeur-param√©tr√©","compilation","constructeur-par-copie","membre","C++98","string","publique"],"tags":[],"content":"\nNom anglais: object\n\n\nUn objet est une instance concr√®te d‚Äôune classe. C‚Äôest une entit√© qui regroupe des attributs (donn√©es) et des m√©thodes (fonctions) d√©finis par sa classe.\nComparaison C/C++: Un objet est similaire √† une variable de type structure (struct), mais avec des fonctions (les m√©thodes) associ√©es en plus des donn√©es.\n\n\nObjets et classes\nUne classe est un plan, un mod√®le. Un objet est une r√©alisation concr√®te de ce plan. Chaque objet poss√®de ses propres copies des attributs et peut utiliser les m√©thodes d√©finies dans la classe.\n\nComparaison C/C++: On peut se repr√©senter une classe un peu comme une structure en C. En C++, un objet est √† la classe ce que la variable est √† la structure en C. Par exemple, en C, on peut d√©finir une structure Voiture, en faire un type avec typedef, puis d√©clarer une variable ma_voiture de ce type. De mani√®re √©quivalente, en C++, on peut d√©finir une classe Voiture, puis cr√©er un objet maVoiture qui est une instance de cette classe.\n\n\nExemple\nAvec une classe Voiture, on peut cr√©er plusieurs objets :\nVoiture voiture1;\nVoiture voiture2;\nChaque voiture (voiture1 et voiture2) est un objet distinct.\nPar exemple :\n\nvoiture1 pourrait √™tre rouge, de marque Toyota, roulant √† 120 km/h.\nvoiture2 pourrait √™tre bleue, de marque Ford, roulant √† 80 km/h.\n\nChaque objet poss√®de ses propres valeurs pour ses attributs et peut effectuer ses propres actions via ses m√©thodes.\n\nObjets et m√©moire\nChaque objet occupe une zone distincte en m√©moire. M√™me s‚Äôils sont cr√©√©s √† partir de la m√™me classe, les objets sont ind√©pendants les uns des autres.\nTu as tout √† fait raison. Voici une version enrichie et rigoureusement structur√©e de la section ‚ÄúCr√©er un objet‚Äù, avec le titre ajust√© en ‚ÄúD√©clarer un objet‚Äù, et un nouveau paragraphe d√©di√© aux constructeurs, conforme √† ton style habituel :\n\nCr√©ation d‚Äôun objet\nLorsqu‚Äôon d√©clare un objet, le compilateur fait appel √† un constructeur de la classe concern√©e pour cr√©er l‚Äôobjet.\n‚Üí Voir la fiche d√©di√©e : constructeur\nCr√©ation √† partir du constructeur par d√©faut\nPour cr√©er un objet √† partir du constructeur par d√©faut, on utilise le nom de la classe comme type, suivi du nom de l‚Äôobjet :\nVoiture voiture1;\nVoiture voiture2;\n// voiture1 et voiture2 sont deux objets de type Voiture, cr√©√©s √† partir du constructeur par d√©faut\n\nCela cr√©e un objet automatique (stock√© sur la pile) de type NomDeLaClasse. Le constructeur par d√©faut est appel√©, ce qui veut dire que les attributs de l‚Äôobjet seront initialis√©s avec des valeurs uniquement si ce constructeur par d√©faut initialise les attributs.\n\n‚Üí Voir la fiche d√©di√©e : constructeur par d√©faut\nCr√©ation √† partir d‚Äôun constructeur param√©tr√©\nOn peut cr√©er un objet √† partir d‚Äôun constructeur sp√©cifique en ajoutant des parenth√®ses () (√† droite du nom de l‚Äôobjet) dans lesquelles on passe les arguments. S‚Äôil existe  plusieurs constructeur param√©tr√©s (c‚Äôest √† dire des constructeurs qui attendent des param√®tres en entr√©e), le compilateur choisira celui qui correspond aux types pass√©s en argument. Evidemment, si aucun constructeur acceptant les types pass√©s en argument n‚Äôexiste, la compilation √©chouera.\n\nEn C++, le choix du constructeur d√©pend des param√®tres fournis lors de la d√©claration de l‚Äôobjet.\n\n‚Üí Voir la fiche d√©di√©e : constructeur param√©tr√©\nCr√©ation √† partir d‚Äôun constructeur par copie\nOn peut aussi cr√©er un objet √† partir d‚Äôun autre objet de m√™me type. Le compilateur fait alors appel au constructeur par copie (si la classe ne poss√®de bien de constructeur par copie, le compilateur en cr√©e un automatiquement, mais avec certaines limitations).\n‚Üí Voir la fiche d√©di√©e : constructeur par copie\nExemples\nVoiture a;                   // constructeur par d√©faut\nVoiture b(&quot;Ford&quot;);           // constructeur avec param√®tre nom de type string\nVoiture c(&quot;Ford&quot;, 23000).    // constructeur avec param√®tres nom de type string et prix de type int\nVoiture d(a);                // constructeur par copie\nAttributs non initialis√©s\nLes attributs membres d‚Äôun objet ne sont pas initialis√©s automatiquement √† sa cr√©ation si le constructeur ne les initialise pas explicitement (en C++98 notamment), sauf cas particuliers. Les attributs non initialis√©s contiendront donc des valeurs ind√©termin√©es (m√©moire non initialis√©e).\n\nEn revanche, si ces attributs sont eux-m√™mes des objets d‚Äôune autre classe, alors leur propre constructeur par d√©faut sera automatiquement appel√©. Ils seront donc initialis√©s selon le comportement d√©fini dans ce constructeur par d√©faut.\n‚Üí Par exemple, un attribut de type string (std::string) sera initialis√© par d√©faut avec une  cha√Æne vide (&quot;&quot;).\n\n\nUtilisation d‚Äôun objet\nPour utiliser un objet, on se sert de l‚Äôop√©rateur point (.) pour acc√©der aux m√©thodes et aux attributs publiques d‚Äôun objet :\nnomDeLObjet.attribut = valeur;\nnomDeLObjet.methode();\n\nEvidemment, seuls les m√©thodes et attributs publiques sont accessibles de cette mani√®re depuis l‚Äôext√©rieur de la classe.\n"},"ofstream":{"slug":"ofstream","filePath":"ofstream.md","title":"ofstream","links":["classe","biblioth√®que-standard-C++","flux","C++","M√©thode"],"tags":[],"content":"\nNom pleinement qualifi√© : std::ofstream\n\n\nstd::ofstream (output file stream) est une classe de la biblioth√®que standard C++ qui permet d‚Äô√©crire dans des fichiers texte ou binaires.\nC‚Äôest un flux en √©criture, analogue √† std::cout, mais connect√© √† un fichier.\nComparaison C / C++: En langage C, on utilise des fonctions comme fopen(), fprintf(), fputs() ou fclose() pour √©crire dans des fichiers. Ces fonctions obligent √† g√©rer manuellement les pointeurs, les erreurs, et les conversions de type, ce qui peut les rendre moins s√ªres. En C++, std::ofstream fournit une interface orient√©e objet, compatible avec std::string et &lt;&lt;, et garantit une fermeture automatique du fichier gr√¢ce au principe du RAII.\n\nInclude\nstd::ofstream appartient √† la biblioth√®que standard C++. Il faut inclure :\n#include &lt;fstream&gt;\nD√©claration et ouverture du fichier\nstd::ofstream fichier(&quot;sortie.txt&quot;); // ouverture directe\nOu bien :\nstd::ofstream fichier;\nfichier.open(&quot;sortie.txt&quot;);\n‚Üí Par d√©faut, le fichier est √©cras√©.\nPour ajouter √† la fin d‚Äôun fichier existant, utiliser le mode std::ios::app :\nstd::ofstream fichier(&quot;log.txt&quot;, std::ios::app);\nV√©rification d‚Äôouverture\nif (!fichier) {\n    std::cerr &lt;&lt; &quot;Erreur : impossible d‚Äôouvrir le fichier en √©criture.&quot; &lt;&lt; std::endl;\n}\n√âcriture de contenu\n√âcrire texte ou variables :\nfichier &lt;&lt; &quot;Nom : &quot; &lt;&lt; nom &lt;&lt; &quot;, √Çge : &quot; &lt;&lt; age &lt;&lt; std::endl;\n√âcrire caract√®re par caract√®re :\nfichier.put(&#039;A&#039;);\n√âcrire une ligne :\nfichier &lt;&lt; ligne &lt;&lt; &quot;\\n&quot;;\nM√©thodes utiles\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeR√¥leopen(&quot;nom&quot;)Ouvre le fichieris_open()V√©rifie si le fichier est ouvertclose()Ferme le fichierput(c)√âcrit un caract√®rewrite(p, n)√âcrit n caract√®res (utilis√© pour binaire)flush()Force l‚Äô√©criture imm√©diate sur le disquefail()Teste s‚Äôil y a eu une erreur\nExemple complet\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nint main() {\n    std::ofstream fichier(&quot;resultat.txt&quot;);\n    if (!fichier) {\n        std::cerr &lt;&lt; &quot;Erreur : impossible de cr√©er le fichier.&quot; &lt;&lt; std::endl;\n        return 1;\n    }\n \n    std::string nom = &quot;Alice&quot;;\n    int age = 30;\n    fichier &lt;&lt; &quot;Nom : &quot; &lt;&lt; nom &lt;&lt; &quot;, √Çge : &quot; &lt;&lt; age &lt;&lt; std::endl;\n \n    fichier.close(); // facultatif mais recommand√©\n    return 0;\n}"},"op√©rateur":{"slug":"op√©rateur","filePath":"op√©rateur.md","title":"op√©rateur","links":["valeur","surcharge","C++","flux","classe","objet","op√©rateur"],"tags":[],"content":"\nNom anglais: operator\n\n\nUn op√©rateur est un symbole ou mot-cl√© qui permet d‚Äôeffectuer une op√©ration sur une ou plusieurs valeurs (appel√©es op√©randes).\nLes op√©rateurs servent √† calculer, comparer, affecter, ou manipuler des objets ou de la m√©moire.\nComparaison C/C++: En C, on parle aussi d‚Äôop√©rateurs, mais la surcharge n‚Äôexiste pas, contrairement au C++.\n\nExemples courants d‚Äôop√©rateurs symboliques\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOp√©rateurSignificationExemple+Additiona + b-Soustractiona - b*Multiplicationa * b/Divisiona / b==Comparaison d‚Äô√©galit√©a == b=Affectationa = 5&lt;&lt;Insertion dans un fluxstd::cout &lt;&lt; x\nOp√©rateurs mots-cl√©s (sp√©ciaux)\nCertains op√©rateurs ne sont pas des symboles mais des mots-cl√©s du langage :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMot-cl√©R√¥lenewAlloue dynamiquement de la m√©moiredeleteLib√®re une m√©moire allou√©e avec newsizeofDonne la taille d‚Äôun type ou objet (en octets)typeidDonne des infos sur un type (RTTI)\n\nCes op√©rateurs peuvent aussi √™tre surcharg√©s (operator new, operator delete, etc.).\n\nSurcharge d‚Äôop√©rateurs\nEn C++, on peut surcharger certains op√©rateurs pour les adapter √† des classes personnalis√©es.\nExemples classiques :\n\n&lt;&lt; pour l‚Äôaffichage d‚Äôobjet\n== pour comparer deux objets\n= pour red√©finir l‚Äôop√©rateur d‚Äôaffectation\n\nR√©sum√©\n\nUn op√©rateur est un √©l√©ment syntaxique (symbole ou mot-cl√©) permettant d‚Äôappliquer une op√©ration sur des valeurs ou objets.\nEn C++, la surcharge permet de les adapter aux classes d√©finies par l‚Äôutilisateur.\n"},"organisation-des-fichiers-d'une-classe":{"slug":"organisation-des-fichiers-d'une-classe","filePath":"organisation des fichiers d'une classe.md","title":"organisation des fichiers d'une classe","links":["C++","classe","attribut","m√©thode","publique","priv√©","prot√©g√©"],"tags":[],"content":"\nEn C++, par convention, chaque classe doit √™tre r√©partie dans deux fichiers distincts :\n\nun fichier d‚Äôen-t√™te (.hpp) contenant la d√©claration de la classe (attributs et prototypes des m√©thodes, sans leur code),\nun fichier d‚Äôimpl√©mentation (.cpp) contenant la d√©finition des m√©thodes (c‚Äôest-√†-dire leur corps).\n\nCette s√©paration favorise la clart√©, la compilation efficace et la r√©utilisabilit√©.\n\n√Ä 42, cette organisation est obligatoire, et doit inclure les quatre √©l√©ments de la forme canonique :  le constructeur par d√©faut, le constructeur par copie, l‚Äôop√©rateur d‚Äôaffectation, et le destructeur.\n\nFichier d‚Äôen-t√™te (header)\nNom\nLe fichier .hpp de la classe doit par convention √™tre nomm√© comme la classe. Exemple : maClassse.hpp.\nGardes d‚Äôinclusion:\nLe fichier doit d√©buter par les gardes d‚Äôinclusion qui emp√™chent le fichier d‚Äô√™tre inclus plusieurs fois dans le m√™me programme (ce qui causerait une erreur de red√©finition) : sous la forme\n#ifndef NOMDECLASSE_HPP\n#define NOMDECLASSE_HPP\n// ... contenu de la classe ...\n#endif\nOu bien plus simplement :\n#pragma once\nInclusions\nLe header doit ensuite inclure les include mais uniquement ce qui est strictement requis pour la d√©claration (et non pour l‚Äôimpl√©mentation). Par exemple :\n#include &lt;string&gt; // si on a std::string comme attribut\nD√©claration de la classe\nOn d√©clare ensuite la classe avec ses parties publiques, priv√©es, etc. Par exemple :\nclass MaClasse\n{\npublic:\n    MaClasse();\n    MaClasse(const MaClasse&amp; other);\n    MaClasse&amp; operator=(const MaClasse&amp; other);\n    ~MaClasse();\n \n    void faireQuelqueChose(); // m√©thode publique\n \nprivate:\n    int _x;                  // attribut priv√©\n    std::string _nom;\n};\nPas d‚Äôimpl√©mentation\nAucune fonction ne doit contenir de code dans le .hpp.\nJamais de `using namespace\nCela pollue l‚Äôespace global et peut causer des conflits dans tous les fichiers qui incluent ce .hpp.\n\nFichier d‚Äôimpl√©mentation (source ou impl√©mentation)\nLe fichier source .cpp contient la d√©finition des m√©thodes d√©clar√©es dans le .hpp. C‚Äôest ici que l‚Äôon √©crit le corps de chaque fonction.\nNom\nLe fichier source doit porter le m√™me nom que le.hpp, mais avec l‚Äôextension .cpp. Exemple : MaClasse.cpp`.\nInclusion\nLe fichier .cpp doit commencer par l‚Äôinclusion du fichier .hpp correspondant :\n#include &quot;MaClasse.hpp&quot;\nCela garantit que toutes les d√©clarations sont coh√©rentes avec celles expos√©es √† l‚Äôext√©rieur.\nD√©finition des m√©thodes\nLes m√©thodes sont d√©finies en pr√©cisant le nom de la classe suivi de l‚Äôop√©rateur :: :\nvoid MaClasse::faireQuelqueChose() {\n    // code de la m√©thode\n}\nAcc√®s aux membres\nLe .cpp a un acc√®s complet aux attributs priv√©s et prot√©g√©s (private et protected) de la classe.\nLibert√© des includes\nDans ce fichier, on peut inclure (avec include) tous les fichiers n√©cessaires √† l‚Äôimpl√©mentation, m√™me s‚Äôils ne sont pas pr√©sents dans le .hpp."},"paradigme-de-programmation":{"slug":"paradigme-de-programmation","filePath":"paradigme de programmation.md","title":"paradigme de programmation","links":["programmation-imp√©rative","programmation-proc√©durale","C++","programmation-orient√©e-objet","objet","programmation-fonctionnelle","programmation-d√©clarative","programmation-orient√©e-donn√©e"],"tags":[],"content":"\nNom anglais: programming paradigm\n\n\nUn paradigme de programmation est une mani√®re de penser et d‚Äôorganiser la cr√©ation de programmes. C‚Äôest une approche g√©n√©rale qui influence comment on structure le code et comment on r√©sout les probl√®mes.\nComparaison C/C++: Le C est principalement de la programmation imp√©rativeet de la programmation proc√©durale. Le C++ ajoute la programmation orient√©e objet (POO) et d‚Äôautres paradigmes.\n\nPrincipaux paradigmes\n\nLa programmation imp√©rative: D√©crit comment le programme doit faire les choses, √©tape par √©tape. (Ex : C, C++)\nLa programmation proc√©durale : Organise le code en fonctions et proc√©dures. (Ex : C)\nLa programmation orient√©e objet : Organise le code en objets qui contiennent donn√©es et comportements. (Ex : C++, Java)\nLa programmation fonctionnelle : Construit le programme avec des fonctions pures sans effets de bord. (Ex : Haskell, certaines parties modernes de C++)\nLa programmation d√©clarative : D√©crit ce que l‚Äôon veut obtenir, sans d√©tailler comment. (Ex : SQL)\nLa programmation orient√©e donn√©e : Approche qui privil√©gie la structure et l‚Äôagencement des donn√©es avant tout\n\nExemple rapide\nEn programmation imp√©rative :\nint x = 0;\nx = x + 1;\nOn d√©crit comment changer x.\nEn programmation d√©clarative :\nSELECT * FROM utilisateurs WHERE age &gt; 18;\nOn d√©crit ce que l‚Äôon veut, sans expliquer comment l‚Äôobtenir."},"param√®tre":{"slug":"param√®tre","filePath":"param√®tre.md","title":"param√®tre","links":["fonction","argument","C++","r√©f√©rence","Argument","objet","pointeur","classe","valeur-par-d√©faut"],"tags":[],"content":"\nNom anglais: parameter\n\n\nUn param√®tre est une variable d√©clar√©e dans une fonction, qui re√ßoit une valeur lors de l‚Äôappel √† cette fonction. Cette valeur transmise s‚Äôappelle un argument.\nLe param√®tre est utilis√© √† l‚Äôint√©rieur de la fonction pour travailler avec la donn√©e re√ßue.\nComparaison C/C++ : En C comme en C++, les param√®tres peuvent √™tre pass√©s par valeur ou par adresse (pointeur). En C++, on peut aussi utiliser les r√©f√©rences.\n\n\nExemple\nvoid saluer(std::string nom) {\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n}\nIci, nom est le param√®tre de la fonction saluer. Il recevra une valeur (un argument) lors de l‚Äôappel de la fonction.\n\nParam√®tre vs argument\nCes deux notions sont proches, mais √† ne pas confondre :\n\nParam√®tre : variable d√©clar√©e dans la d√©finition de la fonction (ex : std::string nom)\nArgument : valeur fournie lors de l‚Äôappel (ex : &quot;Alice&quot;)\n\n‚Üí Voir la fiche d√©di√©e : argument\n\nTypes de param√®tres\nUn param√®tre peut √™tre :\n\nde type fondamental (int, char, float, etc.)\nde type objet (std::string, std::vector, etc.)\nde type r√©f√©rence (std::string&amp;, const T&amp;)\nde type pointeur (int*, char*)\nun type personnalis√© (d√©fini par une classe)\n\nvoid afficher(int valeur);             // par valeur\nvoid afficher(const std::string&amp; s);   // par r√©f√©rence constante\nvoid afficher(int* ptr);               // par pointeur\n\nParam√®tre par d√©faut\nUn param√®tre par d√©faut est un param√®tre auquel on assigne une valeur implicite dans la d√©claration de la fonction :\nvoid saluer(std::string nom = &quot;inconnu&quot;) {\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n}\nAppels possibles :\nsaluer();           // affiche &quot;Bonjour, inconnu&quot;\nsaluer(&quot;Alice&quot;);    // affiche &quot;Bonjour, Alice&quot;\n‚Üí Voir la fiche d√©di√©e : valeur par d√©faut\n\nVoir aussi\n‚Üí fonction, argument, r√©f√©rence\n‚Üí valeur par d√©faut, pointeur, classe"},"pile-algorithmique-LIFO":{"slug":"pile-algorithmique-LIFO","filePath":"pile algorithmique LIFO.md","title":"pile algorithmique LIFO","links":["conteneur-adaptateur","conteneur-standard-de-la-STL","C++","conteneur-s√©quentiel","file-double","it√©rateur","STL","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","conteneur","vecteur"],"tags":[],"content":"\nNom anglais: stack\nNom pleinement qualifi√©: std::stack\n\n\nUne pile algorithmique LIFO (Last in, first out) stack est un conteneur adaptateur qui fait partie des conteneur standard de la STL en C++. Elle impl√©mente le comportement d‚Äôune pile (LIFO ‚Äì Last In, First Out), o√π le dernier √©l√©ment ajout√© est le premier retir√©.\nElle repose sur un conteneur s√©quentiel sous-jacent (une file double deque par d√©faut) mais expose une interface restreinte : acc√®s uniquement au sommet, sans it√©rateur ni parcours.\n\n\nInclude\nPour utiliser std::stack il faut l‚Äôinclusion suivante :\n#include &lt;stack&gt;\n\nEspace de nom\nLes  piles algorithmiques LIFO  stack font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::stack\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nstd::stack&lt;Type&gt; maPile;\n \n// exemple :\nstd::stack&lt;int&gt; pileEntiers;\nstd::stack&lt;std::string&gt; pileMots;\nSp√©cification du conteneur sous-jacent\nstd::stack&lt;int, std::vector&lt;int&gt; &gt; pileVec;  // avec vector\nstd::stack&lt;int, std::deque&lt;int&gt; &gt; pileDeque; // par d√©faut\n\nImpl√©mentation interne\nUne stack&lt;T&gt; est un conteneur adaptateur encapsulant :\n\nun conteneur s√©quentiel (file double deque par d√©faut)\nune interface limit√©e √† LIFO :\n\npush() ‚Üí ajoute au sommet\npop() ‚Üí retire le sommet\ntop() ‚Üí acc√®de au sommet\n\n\n\n\nElle ne fournit pas d‚Äôit√©rateur, pas de parcours, pas d‚Äôacc√®s al√©atoire.\n\n\nStack et m√©moire\nLa stack repose sur le conteneur sous-jacent pour la gestion de m√©moire :\n\npar d√©faut une file double deque, mais on peut utiliser un vecteur vector si besoin\nl‚Äôallocation se fait via les m√©thodes push() et pop()\nla m√©moire suit l‚Äôordre strict LIFO (Last in, first out), id√©al pour simuler des appels imbriqu√©s ou des structures temporaires\n\n\nQuand et pourquoi utiliser une pile algorithmique LIFO\nUne stack est id√©ale d√®s qu‚Äôil faut un stockage temporaire LIFO.\nElle est couramment utilis√©e pour :\n\nsimuler la pile d‚Äôex√©cution (ex : analyse r√©cursive, parcours d‚Äôarbre)\ntraiter des expressions invers√©es (notation post-fix√©e)\nannuler des op√©rations dans une interface utilisateur (undo stack)\n\nElle offre une interface tr√®s simple et des performances optimales pour ce type d‚Äôusage.\n\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptiontop()Acc√®de √† l‚Äô√©l√©ment au sommet de la pilesize()Retourne le nombre d‚Äô√©l√©ments stock√©sempty()V√©rifie si la pile est vide\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionpush(val)Empile un nouvel √©l√©ment au sommetpop()Retire l‚Äô√©l√©ment au sommet\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionoperator=Affecte une autre pileswap()√âchange deux piles\n\nRemarques importantes\n\nLa stack ne permet aucun acc√®s √† ses √©l√©ments internes, √† part le sommet\nElle ne fournit pas d‚Äôit√©rateur\nElle repose sur un conteneur s√©quentiel (modifiable par template)\nElle est con√ßue uniquement pour des sc√©narios LIFO purs\n"},"pile":{"slug":"pile","filePath":"pile.md","title":"pile","links":["variable","objet","tas","bloc","compilateur"],"tags":[],"content":"\nNom anglais : stack\n\n\nLa pile est une zone m√©moire utilis√©e pour stocker les variables locales et les objets cr√©√©s sans new (ceux cr√©√©e avec new sont allou√©s sur le tas).\nElle suit le principe LIFO (Last In, First Out: premier entr√© premier sorti) et la m√©moire est automatiquement lib√©r√©e √† la fin du bloc.\n\nCaract√©ristiques\n\nAllocation automatique\nTr√®s rapide\nG√©r√©e par le compilateur\nCapacit√© limit√©e\n\nExemple\nvoid f() {\n    int x = 42; // allou√© sur la pile\n} // x est d√©truit ici"},"pointeur":{"slug":"pointeur","filePath":"pointeur.md","title":"pointeur","links":["allocation-dynamique-de-la-m√©moire"],"tags":[],"content":"\nNom anglais : pointer\n\n\nUn pointeur est une variable sp√©ciale qui stocke l‚Äôadresse d‚Äôune autre variable.\nIl permet de travailler indirectement sur cette variable en utilisant son adresse m√©moire.\n\nSyntaxe de base\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n√âcritureSignificationint* ptr;D√©clare un pointeur vers un intptr = &amp;x;Stocke l‚Äôadresse de x dans ptr*ptrD√©r√©f√©rence : acc√®de √† la valeur point√©e\n\nLe symbole * est utilis√© pour d√©clarer un pointeur, mais aussi pour acc√©der √† la valeur point√©e (on parle alors de d√©r√©f√©rencement).\nLe symbole &amp; est utilis√© pour obtenir l‚Äôadresse d‚Äôune variable.\n\nExemple complet\n#include &lt;iostream&gt;\n \nint main() {\n    int x = 42;\n    int* ptr = &amp;x;  // pointeur vers x\n \n    std::cout &lt;&lt; &quot;Adresse de x : &quot; &lt;&lt; &amp;x &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Valeur de ptr : &quot; &lt;&lt; ptr &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Valeur point√©e : &quot; &lt;&lt; *ptr &lt;&lt; std::endl;\n \n    *ptr = 100; // on modifie x via le pointeur\n \n    std::cout &lt;&lt; &quot;Nouvelle valeur de x : &quot; &lt;&lt; x &lt;&lt; std::endl;\n}\nSortie possible :\nAdresse de x : 0x7ffeefbff55c  \nValeur de ptr : 0x7ffeefbff55c  \nValeur point√©e : 42  \nNouvelle valeur de x : 100  \n\n√Ä retenir\n\nUn pointeur pointe vers une variable (via son adresse)\nOn peut modifier cette variable √† travers le pointeur\nIl est possible d‚Äôavoir des pointeurs vers n‚Äôimporte quel type (int, char, std::string, etc.)\n\nPr√©cautions\n\nNe jamais d√©r√©f√©rencer un pointeur nul (nullptr) ‚Üí crash\nToujours s‚Äôassurer que le pointeur pointe vers une adresse valide\nLors d‚Äôune allocation dynamique de la m√©moire avec new, ne pas oublier de faire un delete\n\nR√©sum√©\n\nUn pointeur permet de travailler sur une variable √† travers son adresse.\nC‚Äôest un outil fondamental pour la programmation bas niveau, la gestion m√©moire et le passage par pointeur.\n"},"polymorphisme":{"slug":"polymorphisme","filePath":"polymorphisme.md","title":"polymorphisme","links":["programmation-orient√©e-objet","objet","m√©thode","virtuel","classe","h√©ritage","classe-de-base"],"tags":[],"content":"\nNom anglais: polymorphism\n\n\nLe polymorphisme est un principe de laprogrammation orient√©e objet qui permet d‚Äôutiliser plusieurs types d‚Äôobjets diff√©rents √† travers une m√™me interface. En C++, le polymorphisme est principalement possible gr√¢ce aux m√©thodes virtuelles.\nComparaison avec le C: En C, il n‚Äôy a pas de polymorphisme natif. En C++, le polymorphisme permet √† un m√™me appel de m√©thode de se comporter diff√©remment selon le type r√©el de l‚Äôobjet.\n\nPourquoi utiliser le polymorphisme\nLe polymorphisme permet :\n\nd‚Äô√©crire du code plus g√©n√©rique, capable de traiter des objets diff√©rents de mani√®re uniforme,\nde remplacer un objet par un autre sans changer le code qui l‚Äôutilise,\nde simplifier la gestion d‚Äôune famille de classes li√©es par h√©ritage.\n\nFonctionnement du polymorphisme\nPour que le polymorphisme fonctionne :\n\nla classe de base doit d√©clarer ses m√©thodes importantes comme virtuelles avec le mot-cl√© virtual,\non utilise des pointeurs ou r√©f√©rences vers la classe de base pour manipuler les objets,\n√† l‚Äôex√©cution, la bonne version de la m√©thode est appel√©e automatiquement, selon le type r√©el de l‚Äôobjet.\n\nExemple\nclass Vehicule\n{\npublic:\n    virtual void demarrer()\n    {\n        std::cout &lt;&lt; &quot;Vehicule d√©marre&quot; &lt;&lt; std::endl;\n    }\n};\n \nclass Voiture : public Vehicule\n{\npublic:\n    void demarrer() override\n    {\n        std::cout &lt;&lt; &quot;Voiture d√©marre&quot; &lt;&lt; std::endl;\n    }\n};\n \nVehicule* v = new Voiture();\nv-&gt;demarrer(); // Affiche &quot;Voiture d√©marre&quot; gr√¢ce au polymorphisme\nM√™me si v est un pointeur vers Vehicule, la m√©thode Voiture::demarrer() est appel√©e.\nR√©sum√©\nLe polymorphisme repose sur :\n\nl‚Äôh√©ritage,\nles m√©thodes virtuelles,\nappel dynamique des m√©thodes.\n\nIl permet une grande flexibilit√© dans la conception des programmes orient√©s objet."},"priv√©":{"slug":"priv√©","filePath":"priv√©.md","title":"priv√©","links":["classe","attribut","m√©thode","objet","encapsulation","structure","C++","accesseur","mutateur","membre","fonction-friend","publique","prot√©g√©","ami"],"tags":[],"content":"\nNom anglais: private section\n\n\nLa partie priv√©e d‚Äôune classe regroupe les attributs et m√©thodes inaccessibles depuis l‚Äôext√©rieur.\nElle sert √† prot√©ger les d√©tails d‚Äôimpl√©mentation internes de l‚Äôobjet, et √† faire respecter le principe fondamental d‚Äôencapsulation.\nComparaison C/C++: On peut comparer avec les structures en C: En C, tous les membres d‚Äôune structure sont accessibles librement. En C++, on peut restreindre explicitement l‚Äôacc√®s aux membres d‚Äôune classe avec le mot-cl√© private:.\n\n\nR√¥le de la partie priv√©e\nLa section private est utilis√©e pour :\n\nprot√©ger l‚Äô√©tat interne de l‚Äôobjet (donn√©es sensibles, impl√©mentations internes),\nforcer l‚Äôacc√®s √† ces donn√©es via des m√©thodes contr√¥l√©es, sp√©cifiquement destin√©es √† cet effet (accesseurs, mutateurs),\n√©viter les utilisations non pr√©vues ou dangereuses.\n\nElle contribue √† garantir la robustesse et la s√©curit√© du code en interdisant les manipulations directes.\n\nD√©claration\nOn utilise le mot-cl√© private: dans une classe pour regrouper les membres inaccessibles depuis l‚Äôext√©rieur, sauf pour :\n\nles m√©thodes membres de la classe,\nles fonction friend autoris√©es explicitement.\n\nclass Voiture\n{\nprivate:\n    int _vitesse;\n    void verifierMoteur();\n};\nIci, _vitesse et verifierMoteur() sont invisibles depuis l‚Äôext√©rieur de la classe.\n\nC‚Äôest dans la partie priv√©e que l‚Äôon place la majorit√© des attributs, pour respecter les bonnes pratiques de l‚Äôencapsulation.\n\n\nAcc√®s\nLes membres priv√©s ne peuvent pas √™tre utilis√©s depuis l‚Äôext√©rieur de la classe, ni √† l‚Äôaide d‚Äôun objet, ni sans objet :\nVoiture v;\nv._vitesse = 100;      // ‚ùå Erreur : _vitesse est priv√©\nv.verifierMoteur();    // ‚ùå Erreur : m√©thode priv√©e\nVoiture::verifierMoteur();    // ‚ùå Erreur : m√©thode priv√©e\nSeules les m√©thodes d√©clar√©es dans la classe elle-m√™me ont le droit d‚Äôy acc√©der aux membres priv√©s :\nclass Voiture {\npublic:\n    void demarrer() {\n        verifierMoteur();   // ‚úÖ OK : m√©thode priv√©e appel√©e en interne\n    }\n \nprivate:\n    void verifierMoteur();\n};\n\nVoir aussi\n‚Üí Voir √©galement : publique, prot√©g√©, encapsulation, ami"},"programmation-d√©clarative":{"slug":"programmation-d√©clarative","filePath":"programmation d√©clarative.md","title":"programmation d√©clarative","links":["paradigme-de-programmation"],"tags":[],"content":"\nNom anglais: declarative programming\n\n\nLa programmation d√©clarative est un paradigme de programmation qui consiste √† d√©crire ce que l‚Äôon veut obtenir, sans pr√©ciser comment y parvenir. Le syst√®me d√©cide de la mani√®re d‚Äôatteindre le r√©sultat.\nExemple : SQL est un langage d√©claratif.\n\nCaract√©ristiques principales\n\nExprime des objectifs, pas des √©tapes.\nCache les d√©tails de l‚Äôex√©cution.\nUtilis√©e pour les requ√™tes, les interfaces, et certaines optimisations automatiques.\n"},"programmation-fonctionnelle":{"slug":"programmation-fonctionnelle","filePath":"programmation fonctionnelle.md","title":"programmation fonctionnelle","links":["paradigme-de-programmation","C++"],"tags":[],"content":"\nNom anglais: functional programming\n\n\nLa programmation fonctionnelle est un paradigme de programmation qui consid√®re le programme comme une suite de fonctions pures, sans effets de bord et sans modification d‚Äô√©tat.\nExemple : Haskell est purement fonctionnel. C++moderne permet aussi un style fonctionnel avec std::function, lambda, etc.\n\nCaract√©ristiques principales\n\nPas de modification d‚Äô√©tat (variables immuables).\nPas d‚Äôeffets de bord (pas d‚Äôentr√©es/sorties cach√©es).\nFonctions comme objets de premi√®re classe.\n"},"programmation-imp√©rative":{"slug":"programmation-imp√©rative","filePath":"programmation imp√©rative.md","title":"programmation imp√©rative","links":["paradigme-de-programmation","C++"],"tags":[],"content":"\nNom anglais: imperative programming\n\n\nLa programmation imp√©rative est un paradigme de programmation qui consiste √† d√©crire pr√©cis√©ment les √©tapes √† suivre pour r√©soudre un probl√®me. Le programme est une suite d‚Äôinstructions qui modifient l‚Äô√©tat du syst√®me.\nExemple : Le C et le C++ (partie classique) sont majoritairement imp√©ratifs.\n\nCaract√©ristiques principales\n\nD√©crit comment faire les choses.\nUtilise des variables modifiables (√©tat mutable).\nSuit une logique s√©quentielle (instructions, boucles, conditions).\n"},"programmation-orient√©e-donn√©e":{"slug":"programmation-orient√©e-donn√©e","filePath":"programmation orient√©e donn√©e.md","title":"programmation orient√©e donn√©e","links":["paradigme-de-programmation","structure","C++","programmation-orient√©e-objet","objet","classe","pointeur","cache","encapsulation","pile","tas"],"tags":[],"content":"\nNom anglais: data-oriented programming / data-oriented design\n\n\nLa programmation orient√©e donn√©e est un paradigme de programmation bas√© sur une approche qui privil√©gie la structure et l‚Äôagencement des donn√©es avant tout, en mettant l‚Äôaccent sur leur acc√®s rapide, leur localit√© en m√©moire, et leur traitement s√©quentiel.\nCette approche est particuli√®rement utilis√©e dans les domaines o√π la performance est critique, comme les moteurs de jeux, la simulation, ou les syst√®mes embarqu√©s.\nComparaison C/C++ : En C, la conception est naturellement orient√©e donn√©e (structures, tableaux). En C++, on peut m√™ler cette approche √† la programmation orient√©e objet pour optimiser le code bas niveau.\n\n\nPrincipes\n\nOrganiser les donn√©es pour favoriser les parcours m√©moire s√©quentiels\nMinimiser les objets complexes ou classes imbriqu√©es\n√âviter les pointeurs inutiles et la fragmentation m√©moire\nFavoriser les tableaux de structures simples (struct) plut√¥t que des structures contenant des objets\n\n\nExemple\nMoins performant (objet complexe) :\nstruct Entite {\n    float x;\n    float y;\n    float vx;\n    float vy;\n};\n \nstd::vector&lt;Entite&gt; entites;\nPlus performant (stockage parall√®le) :\nstd::vector&lt;float&gt; posX, posY, velX, velY;\n\nLe second exemple permet un acc√®s plus contigu en m√©moire, ce qui favorise le cache CPU.\n\n\nQuand utiliser l‚Äôapproche orient√©e donn√©e ?\n\nLorsque la performance prime sur la mod√©lisation\nDans des contextes √† tr√®s grand volume de donn√©es\nPour √©crire du code proche de la machine, o√π l‚Äôagencement m√©moire compte plus que la structure abstraite\n\n\nVoir aussi\n‚Üí structure, classe, objet, encapsulation, pointeur, pile, tas\n‚Üí paradigme de programmation, programmation orient√©e objet"},"programmation-orient√©e-objet":{"slug":"programmation-orient√©e-objet","filePath":"programmation orient√©e objet.md","title":"programmation orient√©e objet","links":["paradigme-de-programmation","objet","attribut","m√©thode","C++","encapsulation","h√©ritage","classe","polymorphisme"],"tags":[],"content":"\nAbr√©viation: POO\nNom anglais: oriented-object programming\nAbr√©viation anglaise: OOP\n\n\nLa programmation orient√©e objet est un paradigme de programmation qui repose sur la mod√©lisation du programme en objet.\nUn objet est une entit√© autonome qui combine des donn√©es (les variables contenues dans l‚Äôobjet, appel√©es attributs) et des fonctions (appel√©es m√©thodes) pour manipuler ces donn√©es.\nChaque objet repr√©sente une r√©alit√© concr√®te ou abstraite du probl√®me √† r√©soudre.\nComparaison C/C++ : Le C++est con√ßu pour la POO d√®s ses d√©buts (c‚Äô√©tait m√™me l‚Äôune des raisons principales de sa cr√©ation √† partir du C).\n\nObjectifs principaux de la POO\n\nMieux organiser le code\nFavoriser la r√©utilisation gr√¢ce √† l‚Äôencapsulation et l‚Äôh√©ritage\nSimplifier la maintenance et l‚Äô√©volution du logiciel\nMod√©liser fid√®lement des concepts du monde r√©el\n\nConcepts fondamentaux de la POO\nPour appr√©hender la POO, il faut comprendre les concepts suivants:\n\nles classes (mod√®les ou un plans pour cr√©er les objets)\nles objets (les instances concr√®tes d‚Äôune classe)\nl‚Äôencapsulation (pour prot√©ger les donn√©es d‚Äôun objet en les rendant accessibles uniquement via des m√©thodes sp√©cifiques)\nl‚Äôh√©ritage (une classe peut h√©riter des attributs et des m√©thodes d‚Äôune autre classe)\nle polymorphisme (la capacit√© pour diff√©rents objets d‚Äô√™tre utilis√©s √† travers une interface commune)\n\nüìú Pourquoi utiliser la programmation orient√©e objet ?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAvantageD√©tailOrganisation claireLe programme est d√©coup√© en petites unit√©s logiques (objets).R√©utilisationOn peut utiliser les m√™mes classes dans plusieurs projets.Extensibilit√©Ajouter de nouvelles fonctionnalit√©s est plus facile.MaintenanceLe code est plus simple √† corriger et √† am√©liorer.\nExemple simple en C++\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n \nclass Voiture\n{\nprivate:\n    std::string couleur;\n \npublic:\n    Voiture(const std::string&amp; c) : couleur(c) {}\n \n    void afficher()\n    {\n        std::cout &lt;&lt; &quot;La voiture est de couleur &quot; &lt;&lt; couleur &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;\n    }\n};\n \nint main()\n{\n    Voiture v(&quot;rouge&quot;);\n    v.afficher();\n    return 0;\n}\nIci :\n\n\nVoiture est une classe.\n\n\nv est un objet.\n\n\ncouleur est un attribut.\n\n\nafficher() est une m√©thode.\n\n\n\nüß† √Ä retenir\n\n\nPOO (OOP en anglais) est un mod√®le bas√© sur la cr√©ation d‚Äôobjets qui combinent donn√©es et comportements.\n\n\nElle rend les programmes plus proches de notre mani√®re naturelle de comprendre le monde.\n\n\nLes concepts-cl√©s sont : classe, objet, encapsulation, h√©ritage, polymorphisme.\n\n\n\nVeux-tu aussi que je te pr√©pare en bonus une carte mentale (mindmap) tr√®s simple sur la POO que tu pourrais int√©grer visuellement dans Obsidian ? üéØ\n(√áa aide √©norm√©ment √† m√©moriser pour les projets C++ de 42 !)"},"programmation-proc√©durale":{"slug":"programmation-proc√©durale","filePath":"programmation proc√©durale.md","title":"programmation proc√©durale","links":["paradigme-de-programmation","programmation-imp√©rative"],"tags":[],"content":"\nNom anglais: procedural programming\n\n\nLa programmation proc√©durale est un paradigme de programmation qui est une forme particuli√®re de programmation imp√©rative qui organise le code en fonctions et proc√©dures pour am√©liorer la lisibilit√© et la r√©utilisation.\nExemple : Le C est un langage proc√©dural typique.\n\nCaract√©ristiques principales\n\nBas√©e sur les fonctions.\nPermet de r√©utiliser et de structurer le code.\nUtilise l‚Äô√©tat global modifi√© par diff√©rentes fonctions.\n"},"prot√©g√©":{"slug":"prot√©g√©","filePath":"prot√©g√©.md","title":"prot√©g√©","links":["classe","attribut","m√©thode","classe-d√©riv√©e","priv√©","publique","h√©ritage","C++","classe-de-base","objet","membre","prot√©g√©"],"tags":[],"content":"\nNom anglais: protected\n\n\nLa partie prot√©g√©e (protected) d‚Äôune classe contient des attributs et m√©thodes inaccessibles depuis l‚Äôext√©rieur, mais accessibles depuis les classe d√©riv√©es.\nC‚Äôest un compromis entre priv√© (private = totalement cach√©) et publique (public = totalement ouvert).\nComparaison C/C++ : En C, il n‚Äôexiste pas de notion de protection par h√©ritage. En C++, protected permet √† une classe d√©riv√©e d‚Äôacc√©der √† certains √©l√©ments de sa classe de base.\n\n\nR√¥le de la partie prot√©g√©e\nLa section protected est utilis√©e pour :\n\npermettre √† une classe d√©riv√©e d‚Äôacc√©der √† des ressources internes de la classe de base (voir h√©ritage),\ncacher ces ressources au reste du code ext√©rieur,\nstructurer un h√©ritage contr√¥l√© sans tout exposer en publique.\n\n\nD√©claration\nOn utilise le mot-cl√© protected: dans une classe pour d√©signer une section accessible uniquement :\n\npar la classe elle-m√™me,\npar ses classe d√©riv√©es,\nmais pas par l‚Äôext√©rieur.\n\nclass Vehicule\n{\nprotected:\n    int _vitesse;\n \n    void ajusterVitesse(int v);\n};\nIci, _vitesse et ajusterVitesse() sont accessibles dans les sous-classes, mais pas dans le main() ni par un objet.\n\nAcc√®s\nUn membre d√©clar√© protected n‚Äôest pas accessible depuis l‚Äôext√©rieur de la classe, ni m√™me depuis un objet instanci√©.\nEn revanche, il est enti√®rement accessible depuis une classe d√©riv√©e, comme si c‚Äô√©tait un membre priv√© de cette sous-classe.\nCela permet d‚Äô√©tendre la classe de base sans exposer tous ses d√©tails internes au reste du programme.\nPar exemple :\nclass Voiture : public Vehicule {\npublic:\n    void booster() {\n        _vitesse += 50;          // ‚úÖ OK : accessible dans la classe d√©riv√©e\n        ajusterVitesse(150);     // ‚úÖ OK aussi\n    }\n};\n \nint main() {\n    Voiture v;\n    v._vitesse = 100;           // ‚ùå Erreur : membre prot√©g√©\n    v.ajusterVitesse(150);      // ‚ùå Erreur aussi\n}\n\nQuand utiliser protected ?\n\nLorsqu‚Äôon √©crit une classe de base destin√©e √† √™tre √©tendue,\net qu‚Äôon veut offrir des outils internes aux sous-classes, sans exposer ces outils √† tout le programme.\n\n\n‚ö†Ô∏è L‚Äôusage de protected doit rester exceptionnel et r√©fl√©chi.\nDans beaucoup de cas, il vaut mieux garder les attributs priv√©s et exposer des m√©thodes prot√©g√©es.\n\n\nVoir aussi\n‚Üí Voir √©galement : priv√©, publique, h√©ritage, classe d√©riv√©e"},"pr√©dicat":{"slug":"pr√©dicat","filePath":"pr√©dicat.md","title":"pr√©dicat","links":["C++","fonction","foncteur","STL","C++11"],"tags":[],"content":"\nNom anglais: predicate\n\n\nEn C++, un pr√©dicat est une fonction ou foncteur qui retourne une valeur bool√©enne (true ou false) lorsqu‚Äôelle est appliqu√©e √† un ou plusieurs arguments.\nLes pr√©dicats sont souvent utilis√©s avec les fonctions de la STL, comme find_if, count_if, remove_if, sort, etc.\n\n\nPrototype g√©n√©ral\nbool pred(const T&amp; value);               // pr√©dicat unaire\nbool pred(const T1&amp; a, const T2&amp; b);     // pr√©dicat binaire\n\nUtilisation\nUn pr√©dicat permet de d√©finir un crit√®re personnalis√© de s√©lection, de tri, de filtrage, etc.\nIl peut √™tre :\n\nune fonction libre (bool is_even(int x) { return x % 2 == 0; })\nune fonction membre\nun foncteur (objet fonctionnel)\nune lambda (√† partir de C++11)\n\n\nExemples\nbool is_negative(int n) { return n &lt; 0; }\n \nstd::vector&lt;int&gt; v = {-1, 2, -3, 4};\n \nauto it = std::find_if(v.begin(), v.end(), is_negative); // cherche le 1er √©l√©ment &lt; 0\nAvec une lambda (C++11) :\nstd::count_if(v.begin(), v.end(), [](int x) { return x % 2 == 0; }); // compte les pairs\n\nRemarques\n\nLe type bool est obligatoire pour que le pr√©dicat soit valide.\nEn g√©n√©ral, les pr√©dicats sont l√©gers et rapides, car ils sont souvent appel√©s de nombreuses fois dans une boucle algorithmique.\nLes fonctions comme sort, find_if, all_of, etc., attendent souvent un pr√©dicat unaire ou binaire.\n"},"publique":{"slug":"publique","filePath":"publique.md","title":"publique","links":["classe","m√©thode","attribut","objet","C++","encapsulation","accesseur","mutateur","structure","priv√©","prot√©g√©"],"tags":[],"content":"\nNom anglais: public\n\n\nLa partie publique d‚Äôune classe regroupe les m√©thodes et √©ventuellement les attributs qui sont librement accessibles depuis l‚Äôext√©rieur de l‚Äôobjet. C‚Äôest ce qui constitue l‚Äôinterface visible de l‚Äôobjet. On utilise le mot cl√© public: pour d√©clarer la section publique d‚Äôune classe.\nComparaison C/C++: On peut faire la parall√®le avec une structure en C: Dans une structure en C, tous les membres sont automatiquement accessibles publiquement. En C++, la partie publique est d√©finie explicitement avec public:.\n\n\nR√¥le de la partie publique\nLa partie publique sert √† :\n\nd√©finir ce que l‚Äôutilisateur peut voir et utiliser,\nmasquer la complexit√© interne (gr√¢ce √† l‚Äôencapsulation),\nproposer une interface claire et stable pour interagir avec l‚Äôobjet.\n\n\nD√©claration\nOn utilise le mot-cl√© public: dans une classe pour ouvrir une section d‚Äôacc√®s libre au sein de laquelle on va pouvoir d√©clarer les m√©thodes et attributs qui seront accessibles depuis l‚Äôext√©rieur de la classe.\n\nD√©clarer des attributs en public est rarement conseill√©, car cela viole le principe d‚Äôencapsulation. On pr√©f√®re exposer leur valeur via des accesseurs (getter) ou des mutateurs (setter), qui sont des m√©thodes publiques impl√©ment√©es pour cela.\n\nclass Voiture\n{\npublic:\n    void demarrer();\n    int getVitesse() const;\n};\nIci, demarrer() et getVitesse() sont des m√©thodes accessibles √† l‚Äôext√©rieur.\n\nAcc√®s\nTout ce qui est d√©clar√© en partie publique est accessible via l‚Äôop√©rateur point (.), comme on le fait pour acc√©der √† un membre d‚Äôune structure en C :\nobjet.methode();\nPar exemple :\nVoiture v;\nv.demarrer(); // m√©thode publique appel√©e comme on le ferait pour un champ de struct\nIci, on appelle directement demarrer() parce qu‚Äôelle est dans la partie publique.\n\nVoir aussi\n‚Üí Voir √©galement : priv√©, prot√©g√©, encapsulation"},"r√©f√©rence":{"slug":"r√©f√©rence","filePath":"r√©f√©rence.md","title":"r√©f√©rence","links":["pointeur","C++","objet","fonction"],"tags":[],"content":"\nNom anglais : reference\n\n\nUne r√©f√©rence permet de travailler sur une variable sans faire de copie, tout en gardant une syntaxe simple et naturelle.\nElle √©vite les erreurs fr√©quentes des pointeurs (comme les pointeurs nuls ou les erreurs de d√©r√©f√©rencement) tout en offrant une acc√®s direct √† la m√©moire.\nComparaison C/C++: Les r√©f√©rences n‚Äôexistent pas en C++.\n\nPourquoi utiliser une r√©f√©rence\nLes r√©f√©rences sont id√©ales pour :\n\nPasser des variables √† une fonction sans les copier (plus efficace en terme de ressources)\nModifier une variable depuis une autre fonction\nRetourner un objet depuis une fonction sans duplication\nSimplifier le code par rapport √† l‚Äôutilisation des * et &amp; des pointeurs\n\nSyntaxe de base\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n√âcritureSignificationint&amp; ref = x;Cr√©e une r√©f√©rence √† la variable xref = 10;Affecte la valeur 10 √† x via son alias&amp;refDonne l‚Äôadresse de x (car ref est x)\n‚Üí Une r√©f√©rence doit √™tre initialis√©e au moment de sa d√©claration, et ne peut plus √™tre chang√©e ensuite.\nExemple complet\n#include &lt;iostream&gt;\n \nint main() {\n    int x = 42;\n    int&amp; ref = x;  // ref est un alias de x\n \n    std::cout &lt;&lt; &quot;Adresse de x : &quot; &lt;&lt; &amp;x &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Adresse de ref : &quot; &lt;&lt; &amp;ref &lt;&lt; std::endl;\n    std::cout &lt;&lt; &quot;Valeur via ref : &quot; &lt;&lt; ref &lt;&lt; std::endl;\n \n    ref = 100; // modifie x via la r√©f√©rence\n \n    std::cout &lt;&lt; &quot;Nouvelle valeur de x : &quot; &lt;&lt; x &lt;&lt; std::endl;\n}\nSortie possible :\nAdresse de x : 0x7ffeefbff55c  \nAdresse de ref : 0x7ffeefbff55c  \nValeur via ref : 42  \nNouvelle valeur de x : 100  \n\nR√©f√©rences constantes\n\nUne r√©f√©rence constante (const &amp;) permet de r√©f√©rencer une variable sans pouvoir la modifier.\nC‚Äôest tr√®s utile pour passer des objets lourds √† une fonction sans copie, tout en garantissant qu‚Äôils ne seront pas modifi√©s.\n\nvoid afficher(const std::string&amp; texte) {\n    std::cout &lt;&lt; texte &lt;&lt; std::endl;\n}\n\nAucune copie\nImpossible de modifier texte dans la fonction\nTr√®s utilis√© pour les objets comme std::string, std::vector, etc.\n\nDiff√©rences avec les pointeurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCaract√©ristiqueR√©f√©rencePointeurPeut √™tre null‚ùå Non‚úÖ OuiPeut √™tre r√©assign√©e‚ùå Non‚úÖ OuiAcc√®s √† la valeurdirect (ref)indirect (*ptr)D√©clarationint&amp; r = x;int* p = &amp;x;N√©cessite * pour acc√©der‚ùå Non‚úÖ Oui (*ptr)\n√Ä savoir\n\nUne r√©f√©rence n‚Äôest pas une copie : elle modifie directement la variable d‚Äôorigine\nC‚Äôest la forme privil√©gi√©e pour :\n\nLe passage par r√©f√©rence en fonction\nLe retour d‚Äôobjet sans copie\nUne √©criture claire et s√ªre\n\n\nUne fois initialis√©e, une r√©f√©rence ne peut plus √™tre li√©e √† autre chose\n\nR√©sum√©\n\nUne r√©f√©rence en C++ est un alias permanent d‚Äôune variable.\nElle permet de travailler directement sur une variable sans utiliser de pointeur.\nElle est plus naturelle, s√ªre et lisible que les pointeurs dans la majorit√© des cas.\n"},"scripts":{"slug":"scripts","filePath":"scripts.md","title":"scripts","links":[],"tags":[],"content":""},"stat":{"slug":"stat","filePath":"stat.md","title":"stat","links":["fonction","Unix","C++","macro"],"tags":[],"content":"\nBiblioth√®que : #include &lt;sys/stat.h&gt;\n\n\nLa fonction stat de la biblioth√®que sys/stat.h permet d‚Äôobtenir des informations d√©taill√©es sur un fichier ou un r√©pertoire sans avoir √† l‚Äôouvrir ni √† le lire.\nElle remplit une structure struct stat contenant des m√©tadonn√©es comme :  le type (fichier, dossier‚Ä¶), la taille, les permissions, la date de modification, etc.\nC‚Äôest un outil de bas niveau tr√®s utilis√© en Unix / Linux pour analyser un fichier avant de l‚Äôutiliser.\nComparaison C/C++: sys/stat.h est une biblioth√®que C POSIX, disponible sur la plupart des syst√®mes Unix/Linux, qui permet d‚Äôobtenir des m√©tadonn√©es syst√®me sur des fichiers.  Elle est utilisable en C comme en C++, car le C++ est compatible avec les headers C.\n\nContenu de la biblioth√®que sys/stat\nLe fichier d‚Äôen-t√™te #include &lt;sys/stat.h&gt; fait partie de l‚ÄôAPI POSIX.\nIl contient :\n\nla structure stat\nla fonction stat()\ndes macros pour tester le type de fichier (S_ISDIR, S_ISREG, etc.)\n\nLa structure struct stat\nC‚Äôest une structure C (remplie par la fonction stat()) avec les m√©tadonn√©es du fichier ou dossier (taille, permissions, date de cr√©ation, etc).\nstruct stat {\n    mode_t st_mode;     // type de fichier + permissions\n    off_t st_size;      // taille en octets\n    time_t st_mtime;    // derni√®re modification\n    uid_t st_uid;       // propri√©taire (utilisateur)\n    gid_t st_gid;       // groupe propri√©taire\n    ...\n};\nLe champ st_mode\nCe champ contient :\n\nles permissions du fichier (lecture, √©criture, ex√©cution)\net le type du fichier (r√©pertoire, fichier r√©gulier, etc.)\n\nIl s‚Äôutilise avec des macros de test comme S_ISDIR.\nLa fonction stat()\nPrototype :\nint stat(const char *pathname, struct stat *buf);\n\npathname : chemin du fichier √† analyser\nbuf : pointeur vers une struct stat √† remplir\n\nRetour :\n\n0 si tout s‚Äôest bien pass√©\n-1 en cas d‚Äôerreur (fichier inexistant, permissions‚Ä¶)\n\nLa macro S_ISDIR\nS_ISDIR(s.st_mode)\n\nV√©rifie si le fichier point√© est un dossier\nRetourne un bool√©en (true ou false)\n\nAutres macros utiles\n\nS_ISREG() : fichier r√©gulier\nS_ISLNK() : lien symbolique\nS_ISCHR() / S_ISBLK() : p√©riph√©riques\n\nExemple minimal\n#include &lt;sys/stat.h&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    struct stat s;\n    if (stat(&quot;chemin&quot;, &amp;s) == 0) {\n        if (S_ISDIR(s.st_mode))\n            std::cout &lt;&lt; &quot;C&#039;est un dossier&quot; &lt;&lt; std::endl;\n        else if (S_ISREG(s.st_mode))\n            std::cout &lt;&lt; &quot;C&#039;est un fichier&quot; &lt;&lt; std::endl;\n    } else {\n        std::cerr &lt;&lt; &quot;Erreur : acc√®s impossible&quot; &lt;&lt; std::endl;\n    }\n}"},"strftime":{"slug":"strftime","filePath":"strftime.md","title":"strftime","links":["biblioth√®que-standard-C++"],"tags":[],"content":"\nNom pleinement qualifi√© : std::strftime\n\n\nLa fonction strftime de la biblioth√®que standard C++ permet de formater une date (structure tm) en une cha√Æne lisible, selon un mod√®le personnalis√©.\n\nInclude\n#include &lt;ctime&gt;\nExemple\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::time_t now = std::time(0);\n    std::tm* utc = std::gmtime(&amp;now);\n    \n    char buffer[80];\n    std::strftime(buffer, 80, &quot;%Y-%m-%d %H:%M:%S&quot;, utc);\n \n    std::cout &lt;&lt; &quot;UTC : &quot; &lt;&lt; buffer &lt;&lt; std::endl;\n}\n\nLe format %Y-%m-%d %H:%M:%S donne une date du type 2025-05-07 16:42:00.\n\nUsage concret\n\nCr√©er des cha√Ænes lisibles pour logs, affichage, fichiers\nAdapter le format selon les besoins (%d/%m/%Y, %A, %I:%M %p, etc.)\n"},"string":{"slug":"string","filePath":"string.md","title":"string","links":["objet","biblioth√®que-standard-C++","m√©thode"],"tags":[],"content":"\nNom pleinement qualifi√©: std::string\n\n\nstd::string est un objet de la biblioth√®que standard C++ permettant de manipuler des cha√Ænes de caract√®res dynamiques.\nIl est plus puissant, plus s√©curis√© et plus pratique que les tableaux de char en C (char[]).\nComparaison C/C++ : alors qu‚Äôen C on utilise des char* ou char[] termin√©s par \\0, std::string g√®re tout automatiquement (taille, m√©moire, fin de cha√Æne‚Ä¶).\n\nInclude\nPour utiliser std::string il faut inclure :\n#include &lt;string&gt;\nCaract√©ristiques principales\n\nStocke une cha√Æne de caract√®res modifiable\nTaille dynamique (cro√Æt ou r√©tr√©cit automatiquement)\nOp√©rations de base faciles (+, +=, [], ==, etc.)\nFournit des m√©thodes puissantes pour la manipulation de texte (recherche, extraction, modification)\nCompatible avec const char* gr√¢ce √† c_str()\n\nComparaison avec un char[] (en C)\n\nla taille d‚Äôune std::stringest dynamique et auto-g√©r√©e, alors que la taille d‚Äôun char[] est fixe ou doit √™tre g√©r√©e manuellement\nla fin de cha√Æne d‚Äôune std::stringest g√©r√©e automatiquement, alors que pour un char[] un \\0 est requis\ndes fonctions int√©gr√©es (m√©thodes) sont accessibles avec une std::string\nla s√©curit√© d‚Äôune std::string est forte, tandis que les risque de d√©passement de m√©moire (buffer overflow) sont importants avec un char[]\n\nSyntaxe de base\n#include &lt;string&gt;\n \nstd::string s1;                     // cha√Æne vide\nstd::string s2 = &quot;Bonjour&quot;;         // initialisation classique\nstd::string s3(&quot;Salut&quot;);            // autre fa√ßon\nstd::string s4 = s2 + &quot; √† tous&quot;;    // concat√©nation\nPrincipales fonctions associ√©es\nPour une std::string str :\nConstruction / modification\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstr.length()Renvoie la longueur (nombre de caract√®res)str.size()Identique √† length()str.empty()Renvoie true si la cha√Æne est videstr.clear()Vide compl√®tement la cha√Ænestr += &quot;abc&quot;Ajoute &quot;abc&quot; √† la finstr1 + str2Cr√©e une nouvelle cha√Æne r√©sultant de la concat√©nation de str1 et str2str.append(&quot;abc&quot;)Ajoute &quot;abc&quot; √† la fin de la chainestr.insert(pos, s)Ins√®re s √† la position posstr.erase(pos, len)Supprime len caract√®res √† partir de posstr.replace(p, l, s)Remplace une portion par une autre cha√Æne :p est la position de d√©but dans la cha√Æne, l la longueur (nombre de caract√®res √† remplacer) et s la nouvelle chaine qui remplace la portion sp√©cifi√©e.\nAcc√®s et lecture\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstr[i]Acc√®s non v√©rifi√© √† un caract√®restr.at(i)Acc√®s v√©rifi√© (exception si hors-limite)str.front()Premier caract√®restr.back()Dernier caract√®restr.c_str()Retourne un const char* (compatible C)\nRecherche\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstr.find(&quot;abc&quot;)Position de &quot;abc&quot;, ou std::string::npos si non trouv√©str.rfind(&quot;abc&quot;)Idem, mais cherche √† l‚Äôenversstr.find_first_of(&quot;ae&quot;)Premier des caract√®res donn√©sstr.find_last_of(&quot;ae&quot;)Dernier des caract√®res donn√©s\nExtraction\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFonctionDescriptionstr.substr(pos, len)Extrait une sous-cha√Ænestr.copy(buf, len, pos)Copie dans un buffer C (char*)\nIt√©ration\nstd::string s = &quot;Test&quot;;\n \nfor (size_t i = 0; i &lt; s.size(); i++)\n\tstd::cout &lt;&lt; s[i] &lt;&lt; std::endl;\n \nfor (char c : s) // C++11+\n\tstd::cout &lt;&lt; c &lt;&lt; std::endl;\n‚ö†Ô∏è Attention\n\nL‚Äôop√©rateur [] ne v√©rifie pas les limites ‚ûù pr√©f√©rer at() si doute\nstd::string n‚Äôest pas un tableau C ‚ûù pas de strlen() ou strcpy()\nPour un char* utilisable en C : s.c_str() (lecture seule)\n\nBonnes pratiques\n\nUtiliser std::string plut√¥t que char* pour √©viter les erreurs m√©moire\nNe pas manipuler directement les buffers internes (data() ou &amp;s[0]) sans raison\nPr√©f√©rer les m√©thodes (find, replace, etc.) aux fonctions C (strtok, strcpy, etc.)\n\nR√©sum√©\n\nstd::string est un objet de la biblioth√®que standard C++ con√ßu pour manipuler facilement et en s√©curit√© des cha√Ænes de caract√®res.\nIl remplace les char[] du C avec une interface intuitive, des fonctionnalit√©s puissantes, et une gestion automatique de la m√©moire.\n"},"structure-d'un-programme-en-C++":{"slug":"structure-d'un-programme-en-C++","filePath":"structure d'un programme en C++.md","title":"structure d'un programme en C++","links":["compilateur","directive-de-pr√©processeur"],"tags":[],"content":"Qu‚Äôest-ce que la structure d‚Äôun programme en C++?\n\nLa structure d‚Äôun programme en C++, c‚Äôest l‚Äôorganisation minimale n√©cessaire pour qu‚Äôun code soit compris par le compilateur et ex√©cutable par l‚Äôordinateur.\n\nUn programme C++ se construit toujours autour de ces 3 √©l√©ments principaux :\n\ndirective de pr√©processeur\nmain (fonction principale)\ninstruction\n"},"structure":{"slug":"structure","filePath":"structure.md","title":"structure","links":["membre","bloc","C++","m√©thode","constructeur","h√©ritage","classe","attribut","destructeur","membre-statique","surcharge-d'op√©rateur","liste-d'initialisation","objet","encapsulation","programmation-orient√©e-donn√©e","publique","priv√©"],"tags":[],"content":"\nNom anglais: struct / structure\n\n\nUne structure (struct) est un type d√©fini par l‚Äôutilisateur permettant de regrouper plusieurs membres (ou champs) ‚Äî g√©n√©ralement de types diff√©rents ‚Äî dans un m√™me bloc coh√©rent.\nComparaison C/C++ : En C, une structure est un agr√©gat de donn√©es sans comportement. En C++, une struct peut aussi contenir des m√©thodes, des constructeurs, de l‚Äôh√©ritage, etc., comme une classe.\nLa seule diff√©rence entre struct et class en C++ est la visibilit√© par d√©faut : public pour struct, private pour class.\n\n\nD√©finir une structure\nUne strucure struct regroupe plusieurs champs, d√©finis comme des attributs internes :\nstruct Point {\n    int x;\n    int y;\n};\n\nUne fois d√©clar√©e, on peut utiliser cette struct comme n‚Äôimporte quel type :\n\nPoint p;\np.x = 3;\np.y = 4;\n\nParticularit√©s des structures en C++\nContrairement au langage C, une struct en C++ peut contenir :\n\ndes m√©thodes\ndes constructeurs\ndes destructeurs\ndes membre statiques\nde l‚Äôh√©ritage\ndes surcharge d‚Äôop√©rateurs\n\nstruct Point {\n    int x;\n    int y;\n \n    Point(int x_, int y_) : x(x_), y(y_) {}\n \n    void afficher() const {\n        std::cout &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;\n    }\n};\n\nInitialisation\nEn C++, on peut initialiser une structure struct avec une liste d‚Äôinitialisation :\nPoint a = {1, 2};  // initialisation directe\nPoint b(3, 4);     // appel du constructeur\n\nDiff√©rences struct vs class\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n√âl√©mentstructureclasseVisibilit√© par d√©fautpublicprivateH√©ritage par d√©fautpublicprivateFonctionnalit√©sidentiquesidentiques\n\nEn C++, la distinction struct / class est une convention de style.\nOn utilise g√©n√©ralement struct pour des types simples, proches de la donn√©e brute, ou comme objets sans logique m√©tier.\n\n\nExemple complet\n#include &lt;iostream&gt;\n \nstruct Rectangle {\n    int largeur;\n    int hauteur;\n \n    Rectangle(int l, int h) : largeur(l), hauteur(h) {}\n \n    int surface() const {\n        return largeur * hauteur;\n    }\n};\n \nint main() {\n    Rectangle r(4, 5);\n    std::cout &lt;&lt; r.surface() &lt;&lt; std::endl; // 20\n}\n\nQuand utiliser une struct ?\n\nPour des donn√©es simples, sans logique m√©tier complexe\nPour des types de valeur (coordonn√©es, couples, paires‚Ä¶)\nPour repr√©senter une agr√©gation de donn√©es sans encapsulation forte\nEn programmation orient√©e donn√©e ou dans des API publiques comme structures d‚Äô√©change\n\n\nVoir aussi\n‚Üí classe, attribut, m√©thode, constructeur\n‚Üí publique, priv√©, objet, h√©ritage, encapsulation"},"surcharge-d'op√©rateur":{"slug":"surcharge-d'op√©rateur","filePath":"surcharge d'op√©rateur.md","title":"surcharge d'op√©rateur","links":["op√©rateur","classe","objet","surcharge","this","attribut","priv√©","r√©f√©rence","flux","fonction"],"tags":[],"content":"\nNom anglais: operator overloading\n\n\nSurcharger un op√©rateur signifie d√©finir son comportement personnalis√© pour une classe donn√©e. Cela permet, par exemple, d‚Äôutiliser +, == ou &lt;&lt; avec des objets comme s‚Äôils √©taient des types natifs.\nLa surcharge se fait en √©crivant une fonction sp√©ciale appel√©e operatorXXX, o√π XXX est l‚Äôop√©rateur √† surcharger.\nComparaison C/C++: En C, la surcharge n‚Äôexiste pas.\n\n√âtapes pour surcharger un op√©rateur\n\nChoisir l‚Äôop√©rateur √† surcharger (ex. +, &lt;&lt;, ==, etc.)\nD√©finir une fonction nomm√©e operatorXXX\nPlacer cette fonction :\n\n√† l‚Äôint√©rieur de la classe si elle agit sur this,\n√† l‚Äôext√©rieur, avec le mot-cl√© friend si elle a besoin d‚Äôacc√©der √† des attributs priv√©s.\n\n\n\nExemple 1: surcharger operator+ pour une classe Point\nclass Point\n{\npublic:\n    int x, y;\n \n    Point(int a, int b) : x(a), y(b) {}\n \n    // Surcharge de +\n    Point operator+(const Point&amp; autre) const\n    {\n        return Point(x + autre.x, y + autre.y);\n    }\n};\nUtilisation :\nPoint p1(1, 2), p2(3, 4);\nPoint p3 = p1 + p2; // OK gr√¢ce √† operator+\nExemple 2: surcharger operator&lt;&lt; pour affichage avec std::cout\nclass Voiture\n{\nprivate:\n    std::string marque;\n    int vitesse;\n \npublic:\n    Voiture(std::string m, int v) : marque(m), vitesse(v) {}\n \n    // Surcharge de &lt;&lt;\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Voiture&amp; v)\n    {\n        os &lt;&lt; v.marque &lt;&lt; &quot; - &quot; &lt;&lt; v.vitesse &lt;&lt; &quot; km/h&quot;;\n        return os;\n    }\n};\nUtilisation :\nVoiture v(&quot;Toyota&quot;, 120);\nstd::cout &lt;&lt; v;\nBonnes pratiques\n\nLa fonction operatorXXX doit √™tre claire et coh√©rente avec le sens de l‚Äôop√©rateur\nLe retour peut √™tre un objet (comme pour +) ou une r√©f√©rence √† un flux (comme pour &lt;&lt;)\nRespecter la const-correctness (const apr√®s la m√©thode si elle ne modifie rien)\nNe surcharger que si √ßa a du sens pour  l‚Äôobjet\n\nCe qu‚Äôon peut et ne peut pas surcharger\n‚úÖ Op√©rateurs fr√©quents :\n\n+, -, *, /, %\n==, !=, &lt;, &lt;=, &gt;, &gt;=\n&lt;&lt;, &gt;&gt; (pour les flux)\n[], (), -&gt;\n\n‚ùå Op√©rateurs non surchargeables :\n\n. (acc√®s membre)\n:: (port√©e)\n.* (pointeur vers membre)\nsizeof, typeid, alignof\n\nR√©sum√©\n\nSurcharger un op√©rateur permet d‚Äô√©tendre le comportement naturel d‚Äôun symbole (+, &lt;&lt;, etc.) √† des objets personnalis√©s.\nIl suffit d‚Äô√©crire une fonction sp√©ciale operatorXXX, qui peut √™tre interne ou externe √† la classe selon le contexte.\n"},"surcharge-de-fonction":{"slug":"surcharge-de-fonction","filePath":"surcharge de fonction.md","title":"surcharge de fonction","links":["surcharge","C++","fonction","compilateur","m√©thode","classe","constructeur","objet","constructeur-par-d√©faut","polymorphisme"],"tags":[],"content":"\nNom anglais: function overloading\n\n\nLa surcharge de fonction est un type de surcharge qui permet en C++ de d√©finir plusieurs fonctions portant le m√™me nom, mais avec des param√®tres diff√©rents (type, nombre ou ordre).\nLe compilateur choisit automatiquement la bonne version √† appeler selon les arguments fournis.\nComparaison C/C++ : en langage C, la surcharge n‚Äôexiste pas ‚Äî chaque fonction doit avoir un nom unique.\n\nPourquoi surcharger une fonction\n\nPour √©viter de multiplier les noms (ex : afficherInt, afficherTexte‚Ä¶)\nPour simplifier l‚Äôinterface du code\nPour g√©rer facilement des types ou cas diff√©rents\n\nComment surcharger une fonction\nIl suffit de d√©clarer plusieurs fonctions portant le m√™me nom, mais :\n\navec un nombre diff√©rent d‚Äôarguments\nou avec des types diff√©rents\nou dans un ordre diff√©rent (si les types sont distincts)\n\nLes diff√©rentes formes de surcharge de fonction\nLa surcharge permet de d√©finir plusieurs fonctions du m√™me nom, qui diff√®rent par leur signature. Voici les cas principaux :\nSurcharge par type d‚Äôargument\nOn peut d√©finir plusieurs versions d‚Äôune fonction qui acceptent des types de param√®tres diff√©rents.\nvoid afficher(int n);\nvoid afficher(std::string texte);\nvoid afficher(double d);\n \nafficher(42);         // ‚Üí version int\nafficher(&quot;Bonjour&quot;);  // ‚Üí version string\nafficher(3.14);       // ‚Üí version double\nSurcharge par nombre d‚Äôarguments\nOn peut surcharger une fonction en lui donnant un nombre diff√©rent de param√®tres.\nint additionner(int a, int b) {\n    return a + b;\n}\n \nint additionner(int a, int b, int c) {\n    return a + b + c;\n}\n \nadditionner(2, 3);       // ‚Üí version √† 2 arguments\nadditionner(1, 2, 3);    // ‚Üí version √† 3 arguments\nSurcharge par ordre des types\nDeux fonctions peuvent avoir les m√™mes types d‚Äôarguments, mais dans un ordre diff√©rent.\nvoid afficher(std::string texte, int nombre);\nvoid afficher(int nombre, std::string texte);\nSurcharge avec types de retour diff√©rents\nLe type de retour peut diff√©rer, mais ne suffit pas √† lui seul √† distinguer deux fonctions.  La signature des param√®tres doit aussi diff√©rer.\nint multiplier(int a, int b) {\n    return a * b;\n}\n \nfloat multiplier(float a, float b) {\n    return a * b;\n}\n \nint main() {\n    int x = multiplier(2, 3);       // ‚Üí int\n    float y = multiplier(2.5f, 4);  // ‚Üí float\n}\n\nCette surcharge par type de retour diff√©rent est autoris√©e, car les param√®tres sont diff√©rents (int, float). Deux fonctions multiplier(int, int) retournant int et float provoquerait une erreur.\n\nSurcharge √† l‚Äôint√©rieur d‚Äôune classe\nOn peut surcharger plusieurs m√©thodes dans une m√™me classe.\nclass Afficheur {\npublic:\n    void afficher(int n);\n    void afficher(double d);\n};\n\nDans une classe, on surcharge tr√®s fr√©quemment les constructeurs, ce qui permet de cr√©er des objets √† partir de diff√©rents jeux de param√®tres ‚Äî ou sans param√®tre du tout, dans le cas du constructeur par d√©faut.\n\nclass Voiture {\npublic:\n    Voiture();                               // constructeur par d√©faut\n    Voiture(std::string marque);             // constructeur avec 1 param√®tre\n    Voiture(std::string marque, int annee);  // constructeur avec 2 param√®tres\n};\n\nVoir aussi\n‚Üí classe, objet\n‚Üí  constructeur, polymorphisme"},"surcharge":{"slug":"surcharge","filePath":"surcharge.md","title":"surcharge","links":["C++","fonction","op√©rateur","compilateur","programmation-orient√©e-objet","surcharge-de-fonction","surcharge-d'op√©rateur","objet","signature","polymorphisme","constructeur","classe"],"tags":[],"content":"\nNom anglais : overloading\n\n\nLa surcharge est un m√©canisme du C++ qui permet de d√©finir plusieurs fonctions ou op√©rateurs portant le m√™me nom, mais avec des param√®tres diff√©rents.\nLe compilateur choisit automatiquement la bonne version √† appeler en fonction des arguments fournis.\nComparaison C/C++ : En C, la surcharge n‚Äôexiste pas. En C++, elle fait partie des fonctionnalit√©s essentielles du langage, permettant une √©criture plus claire, plus souple, et qui respecte le paradigme de la programmation orient√©e objet.\n\n\nExemple simple de surcharge\n#include &lt;iostream&gt;\n \nint additionner(int a, int b) {\n    std::cout &lt;&lt; &quot;[int] &quot;;\n    return a + b;\n}\n \nfloat additionner(float a, float b) {\n    std::cout &lt;&lt; &quot;[float] &quot;;\n    return a + b;\n}\n \nint main() {\n    std::cout &lt;&lt; additionner(2, 3) &lt;&lt; std::endl;     // [int] 5\n    std::cout &lt;&lt; additionner(1.5f, 2.5f) &lt;&lt; std::endl; // [float] 4\n}\n\nTypes de surcharge\nIl existe deux types de surcharge :\n\nla surcharge de fonction\nla surcharge d‚Äôop√©rateur\n\nSurcharge de fonction\nLa surcharge de fonction permet de d√©clarer plusieurs fonctions ayant le m√™me nom mais des signatures diff√©rentes (types ou nombre de param√®tres).\nC‚Äôest le compilateur qui choisit automatiquement la bonne version selon les arguments.\n‚Üí Voir la fiche d√©di√©e : surcharge de fonction\nSurcharge d‚Äôop√©rateur\nLa surcharge d‚Äôop√©rateur permet de red√©finir le comportement d‚Äôun op√©rateur pour des objets d‚Äôune classe : op√©rateur +, ==, &lt;&lt;, etc.\nCela permet d‚Äôutiliser une syntaxe naturelle avec ses propres types.\n‚Üí Voir la fiche d√©di√©e : surcharge d‚Äôop√©rateur\n\nPourquoi utiliser la surcharge ?\nLa surcharge permet de :\n\nutiliser des noms coh√©rents pour des op√©rations similaires,\n√©viter l‚Äôinflation de noms comme additionnerInt, additionnerFloat, etc.\nrendre le code plus expressif et plus facile √† maintenir.\n\n\nLimites de la surcharge\nCertains √©l√©ments ne peuvent pas √™tre surcharg√©s, ou pr√©sentent des restrictions :\n\nOn ne peut pas surcharger uniquement le type de retour\nOn ne peut pas cr√©er de nouveaux op√©rateurs (**, %%, etc.)\nCertains op√©rateurs ne sont pas surchargeables (::, ., .*, sizeof, typeid, etc.)\n\n\nVoir aussi\n‚Üí surcharge de fonction, surcharge d‚Äôop√©rateur\n‚Üí fonction, op√©rateur, signature, polymorphisme\n‚Üí programmation orient√©e objet, constructeur, classe, objet"},"surcharg√©":{"slug":"surcharg√©","filePath":"surcharg√©.md","title":"surcharg√©","links":["surcharge"],"tags":[],"content":"\nNom anglais: overloaded / overloading\n\n‚Üí voir l‚Äôarticle surcharge"},"syntaxe":{"slug":"syntaxe","filePath":"syntaxe.md","title":"syntaxe","links":[],"tags":[],"content":""},"syst√®me-d‚Äôexploitation":{"slug":"syst√®me-d‚Äôexploitation","filePath":"syst√®me d‚Äôexploitation.md","title":"syst√®me d‚Äôexploitation","links":["terminal"],"tags":[],"content":"Qu‚Äôest-ce qu‚Äôun syst√®me d‚Äôexploitation?\n\nUn syst√®me d‚Äôexploitation (souvent abr√©g√© en OS, pour Operating System) est un logiciel essentiel qui sert d‚Äôinterface entre l‚Äôutilisateur et le mat√©riel de l‚Äôordinateur.\nIl g√®re l‚Äôex√©cution des programmes, l‚Äôorganisation des fichiers, la m√©moire, les p√©riph√©riques, et contr√¥le les ressources du syst√®me.\n\nEn r√©sum√©\n\nIl fait fonctionner l‚Äôordinateur.\nIl g√®re la m√©moire, le processeur, les disques, les p√©riph√©riques (clavier, souris, imprimante‚Ä¶).\nIl offre une interface pour lancer des applications (interface graphique ou terminal).\n\nExemples de syst√®mes d‚Äôexploitation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSyst√®mePlateformeWindowsPCmacOSMacLinux (Ubuntu, Fedora‚Ä¶)PC, serveursAndroidSmartphones/tablettesiOSiPhone/iPad\n√Ä retenir\n\nSans syst√®me d‚Äôexploitation, un ordinateur ne peut pas fonctionner.\nIl coordonne tous les composants mat√©riels et logiciels.\nIl offre aux utilisateurs un environnement stable et organis√© pour travailler.\n"},"tampon-de-sortie":{"slug":"tampon-de-sortie","filePath":"tampon de sortie.md","title":"tampon de sortie","links":["flush"],"tags":[],"content":"\nNom anglais: output buffer\n\n\nLe tampon de sortie est une zone temporaire de m√©moire utilis√©e pour stocker les donn√©es √† afficher avant qu‚Äôelles ne soient r√©ellement envoy√©es √† la sortie (comme l‚Äô√©cran).\nCela permet d‚Äôoptimiser les performances en regroupant les √©critures.\n\nPourquoi utiliser un tampon ?\nLes √©critures directes (comme √† l‚Äô√©cran ou dans un fichier) sont lentes.\nLe tampon permet :\n\nde stocker temporairement ce qu‚Äôon veut afficher,\nd‚Äôenvoyer le tout en une seule fois, plus efficacement,\nde r√©duire le nombre d‚Äôop√©rations co√ªteuses.\n\nQuand le tampon est-il vid√© (flush) ?\nLe tampon est vid√© (envoy√© √† la sortie) :\n\nautomatiquement, √† la fin du programme,\nquand un saut de ligne est rencontr√© (selon le syst√®me),\nquand on appelle explicitement un flush, par exemple avec std::endl ou std::flush,\nparfois, lors d‚Äôune lecture utilisateur (std::cin).\n\nExemple\nstd::cout &lt;&lt; &quot;Bonjour&quot;; // rien ne s‚Äôaffiche encore peut-√™tre\nstd::cout &lt;&lt; std::endl; // flush ‚Üí le texte est envoy√© √† l‚Äô√©cran\nR√©sum√©\n\nLe tampon de sortie est un m√©canisme d‚Äôoptimisation qui retarde l‚Äôaffichage pour le rendre plus efficace.\nOn peut le forcer √† se vider (flush) avec std::endl ou std::flush.\n"},"tampon":{"slug":"tampon","filePath":"tampon.md","title":"tampon","links":[],"tags":[],"content":""},"tas":{"slug":"tas","filePath":"tas.md","title":"tas","links":["allocation-dynamique-de-la-m√©moire","objet","bloc","pile"],"tags":[],"content":"\nNom anglais : heap\n\n\nLe tas est une zone m√©moire utilis√©e pour l‚Äôallocation dynamique de la m√©moire avec new ou malloc.\nElle permet de cr√©er des objets qui survivent au-del√† du bloc o√π ils ont √©t√© cr√©√©s.\nComparaison C/C++: Le C utilise le mot-cl√© malloc pour allouer de la m√©moire; le C++ utilise de pr√©f√©rence new\n\nCaract√©ristiques\n\nAllocation manuelle\nPlus lent que la pile\nContr√¥le total sur la dur√©e de vie\nRisque de fuites m√©moire si delete oubli√© (comme le free en C)\n\nExemple\nint* p = new int(42);  // allou√© sur le tas\ndelete p;              // lib√©ration manuelle"},"terminal":{"slug":"terminal","filePath":"terminal.md","title":"terminal","links":["syst√®me-d‚Äôexploitation","interface-graphique","interpr√©teur-de-commande","interfaces-graphiques"],"tags":[],"content":"Qu‚Äôest-ce qu‚Äôun terminal?\n\nUn terminal est une interface en ligne de commande qui permet √† l‚Äôutilisateur d‚Äôenvoyer des instructions directement au syst√®me d‚Äôexploitation en tapant du texte.\nC‚Äôest un outil puissant pour lancer des programmes, naviguer dans les fichiers, installer des logiciels, et administrer un syst√®me.\n\nEn r√©sum√©\n\nLe terminal affiche du texte et attend des commandes que l‚Äôutilisateur tape.\nIl permet de contr√¥ler l‚Äôordinateur sans interface graphique.\nIl communique souvent avec un interpr√©teur de commande (comme bash, zsh, ou fish).\n\nüìö Exemples de terminaux\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTerminalPlateformeTerminal.appmacOSGNOME TerminalLinuxWindows Terminal / PowerShellWindows\n√Ä retenir\n\nLe terminal est plus rapide que les interfaces graphiques pour beaucoup de t√¢ches techniques.\nC‚Äôest l‚Äôoutil principal des d√©veloppeurs, administrateurs syst√®me, et utilisateurs avanc√©s.\nOn y utilise des commandes comme ls, cd, mkdir, g++, etc.\n"},"this":{"slug":"this","filePath":"this.md","title":"this","links":["C++","m√©thode","classe","objet","attribut","fonction","param√®tre"],"tags":[],"content":"\nNom anglais: this pointer\n\n\nEn C++, le mot-cl√© this est un pointeur implicite disponible dans chaque m√©thode non statique d‚Äôune classe. Il pointe vers l‚Äôobjet courant sur lequel la m√©thode a √©t√© appel√©e.\nComparaison C/C++: this  n‚Äôexiste pas en C.\n\n\n√Ä quoi sert this\n\nAcc√©der explicitement √† l‚Äôobjet courant\nR√©soudre des conflits de noms (ex : entre un attribut et un param√®tre)\nRetourner l‚Äôobjet courant depuis une m√©thode (return *this;)\nCha√Æner des appels de m√©thodes (objet.methode1().methode2();)\nPasser l‚Äôobjet courant √† une autre fonction (autreFonction(this);)\n\n\nExemple de base\nclass Personne {\nprivate:\n    std::string nom;\n \npublic:\n    void setNom(std::string nom) {\n        this-&gt;nom = nom;  // √©vite la confusion avec le param√®tre\n    }\n \n    void afficherNom() {\n        std::cout &lt;&lt; &quot;Nom : &quot; &lt;&lt; this-&gt;nom &lt;&lt; std::endl;\n    }\n};\n\nIci, this-&gt;nom d√©signe l‚Äôattribut, tandis que nom seul d√©signe le param√®tre.\n\n\nthis dans une m√©thode fluide\nclass Compteur {\nprivate:\n    int valeur;\n \npublic:\n    Compteur&amp; incrementer() {\n        valeur++;\n        return *this;  // permet le cha√Ænage\n    }\n};\nUtilisation :\nCompteur c;\nc.incrementer().incrementer();  // Cha√Ænage gr√¢ce √† `return *this`\n\nType de this\n\nDans une m√©thode non const : ClassName* this\nDans une m√©thode const : const ClassName* this\n\n\nR√©sum√©\n\nLe mot-cl√© this est un pointeur vers l‚Äôobjet courant, utile pour manipuler explicitement l‚Äôinstance en cours dans les m√©thodes.\nIl permet de clarifier le code, de cha√Æner les appels, et d‚Äô√©viter les confusions de nom dans les m√©thodes d‚Äôune classe.\n"},"time":{"slug":"time","filePath":"time.md","title":"time","links":["biblioth√®que-standard-C++","C","C++"],"tags":[],"content":"\nNom pleinement qualifi√© : std::time\n\n\nLa fonction time de la biblioth√®que standard C++ permet d‚Äôobtenir le nombre de secondes √©coul√©es depuis le 1er janvier 1970 (epoch UNIX).\nC‚Äôest la base pour travailler avec la date et l‚Äôheure en C ou C++.\n\nInclude\n#include &lt;ctime&gt;\nExemple\n#include &lt;ctime&gt;\n#include &lt;iostream&gt;\n \nint main() {\n    std::time_t now = std::time(0);  // ou std::time(NULL)\n    std::cout &lt;&lt; now &lt;&lt; std::endl;   // nombre de secondes depuis 1970\n}\n\nüî∏ Retourne un std::time_t, g√©n√©ralement un long int.\n\nUsage concret\n\nObtenir l‚Äôheure actuelle brute\nPasser ce temps √† gmtime ou localtime pour le d√©coder\nMesurer des dur√©es simples\n"},"toupper":{"slug":"toupper","filePath":"toupper.md","title":"toupper","links":["Nom-pleinement-qualifi√©","fonction","biblioth√®que-standard-C++"],"tags":[],"content":"\nNom pleinement qualifi√©: std::toupper\n\n\nstd::toupper est une fonction de labiblioth√®que standard C++ qui permet de convertir un caract√®re en majuscule, si c‚Äôest une lettre minuscule.\nElle fait partie de l‚Äôen-t√™te &lt;cctype&gt;.\n\nD√©claration\nint std::toupper(int c);\n\nPrend un caract√®re (en int) en param√®tre\nRetourne la version majuscule si applicable, sinon le caract√®re inchang√©\n\nUtilisation\n#include &lt;iostream&gt;\n#include &lt;cctype&gt;\n \nint main()\n{\n    char lettre = &#039;a&#039;;\n    char maj = std::toupper(lettre); // maj = &#039;A&#039;\n \n    std::cout &lt;&lt; maj &lt;&lt; std::endl;\n    return 0;\n}\nAttention\n\nstd::toupper prend et retourne un int, mais on peut le convertir en char si n√©cessaire\nNe pas lui passer de valeurs invalides (id√©alement, utilise un unsigned char ou EOF)\n\nR√©sum√©\n\nstd::toupper convertit un caract√®re minuscule en majuscule.\nElle est d√©finie dans &lt;cctype&gt; et retourne un int, que l‚Äôon peut convertir en char.\n"},"type-interne":{"slug":"type-interne","filePath":"type interne.md","title":"type interne","links":["classe","C++.","membre","C++","programmation-orient√©e-objet","publique","priv√©"],"tags":[],"content":"\nNom anglais: nested type / internal type\n\n\nUn type interne est un type (comme une classe, une struct, ou un enum) d√©fini √† l‚Äôint√©rieur d‚Äôune classe en C++. Il est lui-m√™me un membre de la classe.\nComparaison C/C++ : En C, on peut aussi d√©finir des struct ou enum √† l‚Äôint√©rieur d‚Äôautres structures, mais en C++ c‚Äôest plus syst√©matique et utilis√© dans la programmation orient√©e objet.\n\nPourquoi utiliser un type interne\nLes types internes permettent :\n\nde organiser le code logiquement,\nde limiter la port√©e d‚Äôun type au sein d‚Äôune classe,\nde structurer des relations fortes entre plusieurs types.\n\nIls sont souvent utilis√©s pour mod√©liser des concepts √©troitement li√©s √† une seule classe.\nExemple\nclass Voiture\n{\npublic:\n    enum class TypeMoteur { Essence, Diesel, Electrique }; // type interne\n \nprivate:\n    TypeMoteur moteur;\n};\nIci, TypeMoteur est un type interne √† la classe Voiture.\nR√©sum√©\nUn type interne est un membre qui d√©finit un nouveau type au sein d‚Äôune classe.\nIl suit les m√™mes r√®gles publique ou priv√© selon o√π il est plac√©."},"valeur-par-d√©faut":{"slug":"valeur-par-d√©faut","filePath":"valeur par d√©faut.md","title":"valeur par d√©faut","links":["param√®tre","fonction","argument","C++","classe","m√©thode","organisation-des-fichiers-d'une-classe","valeur-par-d√©faut","surcharge-de-fonction","surcharge","param√®tres","compilateur"],"tags":[],"content":"\nNom anglais: default argument / default parameter\n\n\nUne valeur par d√©faut est une valeur assign√©e √† un param√®tre dans la d√©claration d‚Äôune fonction.\nSi l‚Äôappel de la fonction n‚Äôindique pas d‚Äôargument pour ce param√®tre, la valeur par d√©faut sera utilis√©e automatiquement.\nComparaison C/C++ : Le C ne permet pas de d√©finir des valeurs par d√©faut. Cette fonctionnalit√© est propre √† C++ et am√©liore la souplesse d‚Äôappel des fonctions.\n\n\nExemple simple\nvoid saluer(std::string nom = &quot;inconnu&quot;) {\n    std::cout &lt;&lt; &quot;Bonjour, &quot; &lt;&lt; nom &lt;&lt; std::endl;\n}\nAppels possibles :\nsaluer(&quot;Alice&quot;);  // affiche &quot;Bonjour, Alice&quot;\nsaluer();         // affiche &quot;Bonjour, inconnu&quot;\n\nR√®gles √† conna√Ætre\n\nLa valeur par d√©faut doit √™tre d√©finie dans la d√©claration de la fonction, g√©n√©ralement dans le fichier .hpp.\nSi plusieurs param√®tres ont une valeur par d√©faut, ils doivent √™tre plac√©s √† la fin (apr√®s tous les param√®tres obligatoires).\n\n// D√©claration valide :\nvoid afficher(int a, int b = 0, int c = 1);\n \n// ‚ùå Erreur : les param√®tres avec valeurs par d√©faut ne doivent pas pr√©c√©der ceux qui n‚Äôen ont pas :\nvoid afficher(int a = 0, int b, int c = 1);\n\nUtilisation en classe\nDans une classe, les valeurs par d√©faut sont g√©n√©ralement d√©finies dans la d√©claration de la m√©thode dans le .hpp :\nclass Voiture {\npublic:\n    void deplacer(int vitesse = 50);\n};\n\nLa valeur par d√©faut n‚Äôest pas r√©p√©t√©e dans la d√©finition de la m√©thode dans le .cpp.\n\n‚Üí Voir la fiche d√©di√©e : organisation des fichiers d‚Äôune classe\n\nPi√®ges √† √©viter\n\nNe pas m√©langer valeur par d√©fautet surcharge de fonction de mani√®re ambigu√´.\nEn cas de surcharge, seules les d√©clarations sans valeur par d√©faut doivent accompagner celles qui en ont.\n\n\nLorsqu‚Äôon utilise √† la fois des fonctions surcharg√©es et des param√®tres avec des valeurs par d√©faut, cela peut cr√©er des conflits ou des ambigu√Øt√©s pour le compilateur, qui ne saura pas quelle version appeler.\n\nvoid afficher(int a = 0);\n// √©viter d‚Äôajouter aussi : void afficher(); ‚Üí ambigu avec afficher(int)\n\nVoir aussi\n‚Üí fonction, param√®tre, argument\n‚Üí surcharge de fonction, classe, organisation des fichiers d‚Äôune classe"},"valeur":{"slug":"valeur","filePath":"valeur.md","title":"valeur","links":["C++","variable","fonction","litt√©ral","param√®tre","argument","r√©f√©rence","objet","valeur-par-d√©faut"],"tags":[],"content":"\nNom anglais: value\n\n\nEn C++, une valeur est une donn√©e concr√®te qu‚Äôon peut affecter √† une variable, passer √† une fonction, ou manipuler dans une expression. Elle repr√©sente le contenu r√©el en m√©moire, comme 42, &quot;bonjour&quot;, 3.14, ou encore true.\nComparaison C/C++ : Le concept de valeur est identique dans les deux langages : une valeur est le contenu d‚Äôune variable ou d‚Äôun litt√©ral.\n\n\nValeur vs litt√©ral\nUn litt√©ral est une valeur √©crite en dur dans le code :\nint x = 42;       // 42 est un litt√©ral ‚Üí c‚Äôest une valeur\nbool actif = true; // true est une valeur\nTout litt√©ral est une valeur, mais une valeur peut aussi venir d‚Äôune variable, d‚Äôun param√®tre, d‚Äôun retour de fonction, etc.\n\nValeur, param√®tre et argument\nCes notions sont souvent confondues. Voici un tableau pour clarifier :\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTermeD√©finitionvaleurUne donn√©e concr√®te (42, &quot;ok&quot;, 3.14, etc.)param√®treUne variable d√©clar√©e dans une fonction pour recevoir une valeurargumentUne valeur fournie lors de l‚Äôappel de la fonction\nExemple\nvoid afficherMessage(std::string message) {\n    std::cout &lt;&lt; message &lt;&lt; std::endl;\n}\n \nafficherMessage(&quot;Bonjour&quot;);\n\n&quot;Bonjour&quot; est une valeur\nmessage est un param√®tre\n&quot;Bonjour&quot; est aussi l‚Äôargument pass√© √† la fonction\n\n\nValeur vs r√©f√©rence\nPar d√©faut, les fonctions prennent leurs param√®tres par valeur :\nvoid doubler(int n) {\n    n = n * 2; // copie ‚Üí l‚Äôoriginal ne change pas\n}\nMais en passant une r√©f√©rence, on manipule directement l‚Äôobjet d‚Äôorigine :\nvoid doublerRef(int&amp; n) {\n    n = n * 2; // modification directe de la variable\n}\n\nLes valeurs sont copi√©es, les r√©f√©rences sont partag√©es.\n\n\nTypes de valeurs\nUne valeur peut √™tre :\n\nun litt√©ral (42, &quot;ok&quot;, true, 3.14)\nune variable √©valu√©e (x, nom, a + b)\nune expression (f(4), t[3], tab.size()\n\n\nExemple r√©capitulatif\nint a = 5;             // 5 est une valeur\nint b = a + 3;         // a + 3 est une expression qui produit une valeur\nstd::string s = &quot;ok&quot;;  // &quot;ok&quot; est une valeur de type string\n\nVoir aussi\n‚Üí variable, litt√©ral\n‚Üíparam√®tre, argument\n‚Üír√©f√©rence, fonction, valeur par d√©faut"},"variable":{"slug":"variable","filePath":"variable.md","title":"variable","links":[],"tags":[],"content":""},"vecteur":{"slug":"vecteur","filePath":"vecteur.md","title":"vecteur","links":["conteneur","STL","C++","m√©thode","biblioth√®que-standard-C++","nom-pleinement-qualifi√©","cache","it√©rateur"],"tags":[],"content":"\nNom anglais: vector\nNom pleinement qualifi√©: std::vector\n\n\nUn vector est un conteneur dynamique fourni par la STL (Standard Template Library) en C++. Il permet de stocker une s√©quence de donn√©es dans une structure qui peut changer de taille automatiquement.\nIl fonctionne comme un tableau dynamique, dont la m√©moire est allou√©e dynamiquement et peut √™tre r√©allou√©e automatiquement en cas de besoin. Contrairement √† un tableau C, un vector conna√Æt sa propre taille et offre des m√©thodes puissantes pour ins√©rer, supprimer, acc√©der et it√©rer sur les √©l√©ments.\nComparaison C/C++ : Un vector est une encapsulation √©volu√©e d‚Äôun tableau C. Il offre :\n\nune taille connue (size())\nune capacit√© extensible (reserve())\ndes m√©thodes s√ªres (at())\nune m√©moire auto-g√©r√©e\n\n\n\nInclude\nPour utiliser std::vector il faut l‚Äôinclusion suivante :\n#include &lt;vector&gt;\n\nEspace de nom\nLes vecteurs font partie de la STL de la biblioth√®que standard C++. Il faut donc les utiliser via leur nom pleinement qualifi√© :\n‚Üí std::vector\nou bien d√©clarer un :\n‚Üí using namespace std\n\nSyntaxe\nD√©claration\nPour d√©clarer un vector il faut utiliser la syntaxe suivante :\nstd::vector&lt;type&gt; myVector;\n \n// exemple pour un vecteur d&#039;int :\nstd::vector&lt;int&gt; myIntVector;\n \n// exemple pour un vecteur de std::string :\nstd::vector&lt;std::string&gt; myStringVector;\n \n// exemple avec initialisation :\nstd::vector&lt;int&gt; v(10, 5); // 10 √©l√©ments valant 5\nInitialisation\nIl existe plusieurs fa√ßon d‚Äôinitialiser un vecteur:\n‚Üí En C++98\nstd::vector&lt;int&gt; v1;                // vecteur vide\nstd::vector&lt;int&gt; v2(10);            // 10 √©l√©ments initialis√©s √† 0\nstd::vector&lt;int&gt; v3(10, 5);         // 10 √©l√©ments valant 5\nint arr[] = {1, 2, 3, 4};\nstd::vector&lt;int&gt; v4(arr, arr + 4);  // copie depuis un tableau C\n‚Üí En C++11 et plus\nstd::vector&lt;int&gt; v5 = {1, 2, 3, 4};       // initialisation par liste\nstd::vector&lt;std::string&gt; v6{&quot;a&quot;, &quot;b&quot;};    // initialisation par accolades\nstd::vector&lt;int&gt; v7{10};                 // un seul √©l√©ment valant 10 (‚ö†Ô∏è pas 10 √©l√©ments !)\nstd::vector&lt;int&gt; v8{10, 5};              // deux √©l√©ments : 10 et 5\n\n‚ö†Ô∏è Attention : std::vector&lt;int&gt; v(10, 5); cr√©e 10 √©l√©ments de valeur 5\nTandis que std::vector&lt;int&gt; v{10, 5}; cr√©e un vecteur avec les √©l√©ments 10 et 5\n\n\nImpl√©mentation interne\nUn vector&lt;T&gt; encapsule :\n\nun tableau dynamique en m√©moire contigu√´ (de type T*)\nune taille courante (size)\nune capacit√© (taille allou√©e r√©elle, ‚â• taille utilis√©e)\nune logique d‚Äôagrandissement automatique (souvent √ó2)\n\n\nEn C++98, vector est impl√©ment√© via un tableau C allou√© avec new T[], et g√©r√© manuellement en interne.\n\n\nVecteur et m√©moire\nLe std::vector alloue sa m√©moire de fa√ßon contigu√´, ce qui signifie que tous les √©l√©ments sont stock√©s dans un seul bloc lin√©aire de m√©moire. Cela permet :\n\nun acc√®s extr√™mement rapide par index (O(1))\nune excellente localit√© m√©moire, favorable au cache du processeur\nune compatibilit√© naturelle avec les pointeurs (&amp;vec[0])\n\nMais contrairement √† un tableau statique, le vector g√®re dynamiquement sa capacit√©. Pour √©viter de devoir r√©allouer de la m√©moire √† chaque push_back(), il maintient deux tailles distinctes :\n\nsize() : nombre r√©el d‚Äô√©l√©ments stock√©s\ncapacity() : espace allou√© actuellement (‚â• size())\n\nQuand on d√©passe capacity(), le vector alloue un nouveau bloc, souvent de taille doubl√©e, puis copie tous les √©l√©ments dedans.\nOn peut contr√¥ler cela avec :\n\nreserve(n) pour allouer de l‚Äôespace √† l‚Äôavance\nresize(n) pour ajuster la taille logique\nclear() pour supprimer tous les √©l√©ments (mais la capacit√© reste)\nshrink_to_fit() n‚Äôexiste pas en C++98 (ajout√© en C++11)\n\nCette strat√©gie d‚Äôallocation anticip√©e am√©liore fortement les performances, notamment dans les boucles avec push_back(), en r√©duisant le nombre de r√©allocations. Elle implique en contrepartie que certaines op√©rations (comme push_back() au-del√† de la capacit√©) peuvent √™tre co√ªteuses, car elles impliquent une reallocation compl√®te.\n\nQuand et pourquoi utiliser un vecteur\nUn vecteur (std::vector) est le conteneur de choix lorsqu‚Äôil faut stocker une s√©quence de taille variable avec un acc√®s rapide par index (O(1)). Il est id√©al pour les cas o√π les √©l√©ments sont principalement ajout√©s √† la fin et o√π les parcours s√©quentiels sont fr√©quents. Gr√¢ce √† sa m√©moire contigu√´, il offre d‚Äôexcellentes performances en termes de localit√© m√©moire (cache-friendly). On l‚Äôutilise d√®s qu‚Äôon veut une alternative souple √† un tableau C statique, avec une gestion automatique de la taille et une compatibilit√© naturelle avec les algorithmes STL.\n\nSouhaites-tu maintenant celui pour deque, list ou un autre ?\nM√©thodes principales\nAcc√®s et propri√©t√©s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionsize()Retourne le nombre d‚Äô√©l√©ments stock√©scapacity()Retourne la capacit√© allou√©e (‚â• size())empty()V√©rifie si le vector est videoperator[]Acc√®s direct sans v√©rificationat(index)Acc√®s s√©curis√© (avec v√©rification d‚Äôindex)front() / back()Acc√®s au premier / dernier √©l√©mentmax_size()Nombre maximal th√©orique d‚Äô√©l√©ments (d√©pend de l‚Äôimpl√©mentation)\nAjout et suppression\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionpush_back(val)Ajoute val √† la fin (agrandit si besoin)pop_back()Supprime le dernier √©l√©mentinsert(pos, val)Ins√®re val √† la position pos (d√©cale le reste)erase(pos)Supprime l‚Äô√©l√©ment √† la position posclear()Vide compl√®tement le vecteur\nGestion m√©moire\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionreserve(n)Alloue de l‚Äôespace pour au moins n √©l√©mentsresize(n)Redimensionne la taille √† n (ajoute ou retire)shrink_to_fit()‚ùå N‚Äôexiste pas en C++98 (C++11 uniquement)\nIt√©rateurs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionbegin() / end()It√©rateurs sur le d√©but / fin du conteneurrbegin() / rend()It√©rateurs invers√©s\n\nLes it√©rateurs permettent un parcours standard avec for, std::find, etc.\n\nAssignation et copie\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nM√©thodeDescriptionassign(n, val)Remplit le vecteur avec n copies de valoperator=Affecte un autre vecteur\n\nRemarques importantes\n\nstd::vector stocke ses donn√©es dans une zone m√©moire contigu√´ : tr√®s bon pour le cache et les performances\nLes insertions au milieu ou au d√©but sont lentes (O(n))\nLes it√©rateurs peuvent devenir invalides apr√®s un push_back() si la capacit√© est d√©pass√©e\n"},"virtuel":{"slug":"virtuel","filePath":"virtuel.md","title":"virtuel","links":["m√©thode","classe-de-base","surcharge","classe-d√©riv√©e","polymorphisme","C++","objet"],"tags":[],"content":"\nNom anglais: virtual\n\n\nLe mot-cl√© virtual sert √† marquer une m√©thode dans une classe de base pour permettre sa surcharge correcte (override) dans une classe d√©riv√©e. Il active ce qu‚Äôon appelle le polymorphisme dynamique en C++.\nComparaison C/C++: En C, il n‚Äôy a pas de concept de m√©thode virtuelle. En C++, virtual est indispensable pour que l‚Äôappel d‚Äôune m√©thode sur un objet utilise la bonne version selon son type r√©el.\n\nPourquoi utiliser virtual\nLe mot-cl√© virtual :\n\npermet aux classe d√©riv√©es de red√©finir une m√©thode,\ngarantit que l‚Äôappel √† la m√©thode utilisera la bonne version √† l‚Äôex√©cution,\nrend possible le polymorphisme, o√π un m√™me appel se comporte diff√©remment selon l‚Äôobjet.\n\nD√©finir une m√©thode virtuelle\nOn ajoute le mot-cl√© virtual devant la d√©claration de la m√©thode dans la classe de base :\nclass Vehicule\n{\npublic:\n    virtual void demarrer();\n};\nEnsuite, dans la classe d√©riv√©e :\nclass Voiture : public Vehicule\n{\npublic:\n    void demarrer() override; // surcharge\n};\nLe mot-cl√© override (voir l‚Äôarticle sur la surcharge) dans la classe enfant n‚Äôest pas obligatoire mais fortement recommand√© pour √©viter les erreurs.\nExemple\nVehicule* v = new Voiture();\nv-&gt;demarrer();\nM√™me si v est un pointeur vers Vehicule, c‚Äôest la version Voiture::demarrer() qui sera appel√©e, gr√¢ce √† virtual."}}